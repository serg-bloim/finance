{"version":3,"file":"finjs.js","sources":["collections/Maps.kt","../../../finjs/src/Checkpoint.kt","../../../finjs/src/Condition.kt","../../../finjs/src/Fin.kt","generated/_Arrays.kt","kotlin/collections.kt","kotlin/kotlin.kt","kotlin/math.kt","../../../finjs/src/Strats.kt","util/Standard.kt","generated/_ArraysJs.kt"],"sourcesContent":["/*\r\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\r\n * that can be found in the license/LICENSE.txt file.\r\n */\r\n\r\n@file:kotlin.jvm.JvmMultifileClass\r\n@file:kotlin.jvm.JvmName(\"MapsKt\")\r\n\r\npackage kotlin.collections\r\n\r\nimport kotlin.contracts.*\r\n\r\nprivate object EmptyMap : Map<Any?, Nothing>, Serializable {\r\n    private const val serialVersionUID: Long = 8246714829545688274\r\n\r\n    override fun equals(other: Any?): Boolean = other is Map<*, *> && other.isEmpty()\r\n    override fun hashCode(): Int = 0\r\n    override fun toString(): String = \"{}\"\r\n\r\n    override val size: Int get() = 0\r\n    override fun isEmpty(): Boolean = true\r\n\r\n    override fun containsKey(key: Any?): Boolean = false\r\n    override fun containsValue(value: Nothing): Boolean = false\r\n    override fun get(key: Any?): Nothing? = null\r\n    override val entries: Set<Map.Entry<Any?, Nothing>> get() = EmptySet\r\n    override val keys: Set<Any?> get() = EmptySet\r\n    override val values: Collection<Nothing> get() = EmptyList\r\n\r\n    private fun readResolve(): Any = EmptyMap\r\n}\r\n\r\n/**\r\n * Returns an empty read-only map of specified type.\r\n *\r\n * The returned map is serializable (JVM).\r\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\r\n */\r\npublic fun <K, V> emptyMap(): Map<K, V> = @Suppress(\"UNCHECKED_CAST\") (EmptyMap as Map<K, V>)\r\n\r\n/**\r\n * Returns a new read-only map with the specified contents, given as a list of pairs\r\n * where the first value is the key and the second is the value.\r\n *\r\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\r\n *\r\n * Entries of the map are iterated in the order they were specified.\r\n *\r\n * The returned map is serializable (JVM).\r\n *\r\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\r\n */\r\npublic fun <K, V> mapOf(vararg pairs: Pair<K, V>): Map<K, V> =\r\n    if (pairs.size > 0) pairs.toMap(LinkedHashMap(mapCapacity(pairs.size))) else emptyMap()\r\n\r\n/**\r\n * Returns an empty read-only map.\r\n *\r\n * The returned map is serializable (JVM).\r\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun <K, V> mapOf(): Map<K, V> = emptyMap()\r\n\r\n/**\r\n * Returns an empty new [MutableMap].\r\n *\r\n * The returned map preserves the entry iteration order.\r\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@kotlin.internal.InlineOnly\r\npublic inline fun <K, V> mutableMapOf(): MutableMap<K, V> = LinkedHashMap()\r\n\r\n/**\r\n * Returns a new [MutableMap] with the specified contents, given as a list of pairs\r\n * where the first component is the key and the second is the value.\r\n *\r\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\r\n *\r\n * Entries of the map are iterated in the order they were specified.\r\n *\r\n * @sample samples.collections.Maps.Instantiation.mutableMapFromPairs\r\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\r\n */\r\npublic fun <K, V> mutableMapOf(vararg pairs: Pair<K, V>): MutableMap<K, V> =\r\n    LinkedHashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\r\n\r\n/**\r\n * Returns an empty new [HashMap].\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@kotlin.internal.InlineOnly\r\npublic inline fun <K, V> hashMapOf(): HashMap<K, V> = HashMap<K, V>()\r\n\r\n/**\r\n * Returns a new [HashMap] with the specified contents, given as a list of pairs\r\n * where the first component is the key and the second is the value.\r\n *\r\n * @sample samples.collections.Maps.Instantiation.hashMapFromPairs\r\n */\r\npublic fun <K, V> hashMapOf(vararg pairs: Pair<K, V>): HashMap<K, V> = HashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\r\n\r\n/**\r\n * Returns an empty new [LinkedHashMap].\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@kotlin.internal.InlineOnly\r\npublic inline fun <K, V> linkedMapOf(): LinkedHashMap<K, V> = LinkedHashMap<K, V>()\r\n\r\n/**\r\n * Returns a new [LinkedHashMap] with the specified contents, given as a list of pairs\r\n * where the first component is the key and the second is the value.\r\n *\r\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\r\n *\r\n * Entries of the map are iterated in the order they were specified.\r\n *\r\n * @sample samples.collections.Maps.Instantiation.linkedMapFromPairs\r\n */\r\npublic fun <K, V> linkedMapOf(vararg pairs: Pair<K, V>): LinkedHashMap<K, V> = pairs.toMap(LinkedHashMap(mapCapacity(pairs.size)))\r\n\r\n/**\r\n * Calculate the initial capacity of a map, based on Guava's com.google.common.collect.Maps approach. This is equivalent\r\n * to the Collection constructor for HashSet, (c.size()/.75f) + 1, but provides further optimisations for very small or\r\n * very large sizes, allows support non-collection classes, and provides consistency for all map based class construction.\r\n */\r\n@PublishedApi\r\ninternal fun mapCapacity(expectedSize: Int): Int {\r\n    if (expectedSize < 3) {\r\n        return expectedSize + 1\r\n    }\r\n    if (expectedSize < INT_MAX_POWER_OF_TWO) {\r\n        return expectedSize + expectedSize / 3\r\n    }\r\n    return Int.MAX_VALUE // any large value\r\n}\r\n\r\nprivate const val INT_MAX_POWER_OF_TWO: Int = Int.MAX_VALUE / 2 + 1\r\n\r\n/** Returns `true` if this map is not empty. */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun <K, V> Map<out K, V>.isNotEmpty(): Boolean = !isEmpty()\r\n\r\n/**\r\n * Returns `true` if this nullable map is either null or empty.\r\n * @sample samples.collections.Maps.Usage.mapIsNullOrEmpty\r\n */\r\n@SinceKotlin(\"1.3\")\r\n@kotlin.internal.InlineOnly\r\npublic inline fun <K, V> Map<out K, V>?.isNullOrEmpty(): Boolean {\r\n    contract {\r\n        returns(false) implies (this@isNullOrEmpty != null)\r\n    }\r\n\r\n    return this == null || isEmpty()\r\n}\r\n\r\n/**\r\n * Returns the [Map] if its not `null`, or the empty [Map] otherwise.\r\n *\r\n * @sample samples.collections.Maps.Usage.mapOrEmpty\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun <K, V> Map<K, V>?.orEmpty(): Map<K, V> = this ?: emptyMap()\r\n\r\n/**\r\n * Returns this map if it's not empty\r\n * or the result of calling [defaultValue] function if the map is empty.\r\n *\r\n * @sample samples.collections.Maps.Usage.mapIfEmpty\r\n */\r\n@SinceKotlin(\"1.3\")\r\n@kotlin.internal.InlineOnly\r\npublic inline fun <M, R> M.ifEmpty(defaultValue: () -> R): R where M : Map<*, *>, M : R =\r\n    if (isEmpty()) defaultValue() else this\r\n\r\n/**\r\n * Checks if the map contains the given key.\r\n *\r\n * This method allows to use the `x in map` syntax for checking whether an object is contained in the map.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.contains(key: K): Boolean = containsKey(key)\r\n\r\n/**\r\n * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.get(key: K): V? =\r\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, V>).get(key)\r\n\r\n/**\r\n * Allows to use the index operator for storing values in a mutable map.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun <K, V> MutableMap<K, V>.set(key: K, value: V): Unit {\r\n    put(key, value)\r\n}\r\n\r\n/**\r\n * Returns `true` if the map contains the specified [key].\r\n *\r\n * Allows to overcome type-safety restriction of `containsKey` that requires to pass a key of type `K`.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun <@kotlin.internal.OnlyInputTypes K> Map<out K, *>.containsKey(key: K): Boolean =\r\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, *>).containsKey(key)\r\n\r\n/**\r\n * Returns `true` if the map maps one or more keys to the specified [value].\r\n *\r\n * Allows to overcome type-safety restriction of `containsValue` that requires to pass a value of type `V`.\r\n *\r\n * @sample samples.collections.Maps.Usage.containsValue\r\n */\r\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\r\n@kotlin.internal.InlineOnly\r\npublic inline fun <K, @kotlin.internal.OnlyInputTypes V> Map<K, V>.containsValue(value: V): Boolean = this.containsValue(value)\r\n\r\n\r\n/**\r\n * Removes the specified key and its corresponding value from this map.\r\n *\r\n * @return the previous value associated with the key, or `null` if the key was not present in the map.\r\n\r\n * Allows to overcome type-safety restriction of `remove` that requires to pass a key of type `K`.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun <@kotlin.internal.OnlyInputTypes K, V> MutableMap<out K, V>.remove(key: K): V? =\r\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableMap<K, V>).remove(key)\r\n\r\n/**\r\n * Returns the key component of the map entry.\r\n *\r\n * This method allows to use destructuring declarations when working with maps, for example:\r\n * ```\r\n * for ((key, value) in map) {\r\n *     // do something with the key and the value\r\n * }\r\n * ```\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun <K, V> Map.Entry<K, V>.component1(): K = key\r\n\r\n/**\r\n * Returns the value component of the map entry.\r\n *\r\n * This method allows to use destructuring declarations when working with maps, for example:\r\n * ```\r\n * for ((key, value) in map) {\r\n *     // do something with the key and the value\r\n * }\r\n * ```\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun <K, V> Map.Entry<K, V>.component2(): V = value\r\n\r\n/**\r\n * Converts entry to [Pair] with key being first component and value being second.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun <K, V> Map.Entry<K, V>.toPair(): Pair<K, V> = Pair(key, value)\r\n\r\n/**\r\n * Returns the value for the given key, or the result of the [defaultValue] function if there was no entry for the given key.\r\n *\r\n * @sample samples.collections.Maps.Usage.getOrElse\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun <K, V> Map<K, V>.getOrElse(key: K, defaultValue: () -> V): V = get(key) ?: defaultValue()\r\n\r\n\r\ninternal inline fun <K, V> Map<K, V>.getOrElseNullable(key: K, defaultValue: () -> V): V {\r\n    val value = get(key)\r\n    if (value == null && !containsKey(key)) {\r\n        return defaultValue()\r\n    } else {\r\n        @Suppress(\"UNCHECKED_CAST\")\r\n        return value as V\r\n    }\r\n}\r\n\r\n/**\r\n * Returns the value for the given [key] or throws an exception if there is no such key in the map.\r\n *\r\n * If the map was created by [withDefault], resorts to its `defaultValue` provider function\r\n * instead of throwing an exception.\r\n *\r\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and\r\n * no implicit default value was provided for that map.\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic fun <K, V> Map<K, V>.getValue(key: K): V = getOrImplicitDefault(key)\r\n\r\n/**\r\n * Returns the value for the given key. If the key is not found in the map, calls the [defaultValue] function,\r\n * puts its result into the map under the given key and returns it.\r\n *\r\n * Note that the operation is not guaranteed to be atomic if the map is being modified concurrently.\r\n *\r\n * @sample samples.collections.Maps.Usage.getOrPut\r\n */\r\npublic inline fun <K, V> MutableMap<K, V>.getOrPut(key: K, defaultValue: () -> V): V {\r\n    val value = get(key)\r\n    return if (value == null) {\r\n        val answer = defaultValue()\r\n        put(key, answer)\r\n        answer\r\n    } else {\r\n        value\r\n    }\r\n}\r\n\r\n/**\r\n * Returns an [Iterator] over the entries in the [Map].\r\n *\r\n * @sample samples.collections.Maps.Usage.forOverEntries\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun <K, V> Map<out K, V>.iterator(): Iterator<Map.Entry<K, V>> = entries.iterator()\r\n\r\n/**\r\n * Returns a [MutableIterator] over the mutable entries in the [MutableMap].\r\n *\r\n */\r\n@kotlin.jvm.JvmName(\"mutableIterator\")\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun <K, V> MutableMap<K, V>.iterator(): MutableIterator<MutableMap.MutableEntry<K, V>> = entries.iterator()\r\n\r\n/**\r\n * Populates the given [destination] map with entries having the keys of this map and the values obtained\r\n * by applying the [transform] function to each entry in this [Map].\r\n */\r\npublic inline fun <K, V, R, M : MutableMap<in K, in R>> Map<out K, V>.mapValuesTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\r\n    return entries.associateByTo(destination, { it.key }, transform)\r\n}\r\n\r\n/**\r\n * Populates the given [destination] map with entries having the keys obtained\r\n * by applying the [transform] function to each entry in this [Map] and the values of this map.\r\n *\r\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\r\n * the value associated with the former one.\r\n */\r\npublic inline fun <K, V, R, M : MutableMap<in R, in V>> Map<out K, V>.mapKeysTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\r\n    return entries.associateByTo(destination, transform, { it.value })\r\n}\r\n\r\n/**\r\n * Puts all the given [pairs] into this [MutableMap] with the first component in the pair being the key and the second the value.\r\n */\r\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Array<out Pair<K, V>>): Unit {\r\n    for ((key, value) in pairs) {\r\n        put(key, value)\r\n    }\r\n}\r\n\r\n/**\r\n * Puts all the elements of the given collection into this [MutableMap] with the first component in the pair being the key and the second the value.\r\n */\r\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Iterable<Pair<K, V>>): Unit {\r\n    for ((key, value) in pairs) {\r\n        put(key, value)\r\n    }\r\n}\r\n\r\n/**\r\n * Puts all the elements of the given sequence into this [MutableMap] with the first component in the pair being the key and the second the value.\r\n */\r\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Sequence<Pair<K, V>>): Unit {\r\n    for ((key, value) in pairs) {\r\n        put(key, value)\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a new map with entries having the keys of this map and the values obtained by applying the [transform]\r\n * function to each entry in this [Map].\r\n *\r\n * The returned map preserves the entry iteration order of the original map.\r\n *\r\n * @sample samples.collections.Maps.Transformations.mapValues\r\n */\r\npublic inline fun <K, V, R> Map<out K, V>.mapValues(transform: (Map.Entry<K, V>) -> R): Map<K, R> {\r\n    return mapValuesTo(LinkedHashMap<K, R>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\r\n}\r\n\r\n/**\r\n * Returns a new Map with entries having the keys obtained by applying the [transform] function to each entry in this\r\n * [Map] and the values of this map.\r\n *\r\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\r\n * the value associated with the former one.\r\n *\r\n * The returned map preserves the entry iteration order of the original map.\r\n *\r\n * @sample samples.collections.Maps.Transformations.mapKeys\r\n */\r\npublic inline fun <K, V, R> Map<out K, V>.mapKeys(transform: (Map.Entry<K, V>) -> R): Map<R, V> {\r\n    return mapKeysTo(LinkedHashMap<R, V>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\r\n}\r\n\r\n/**\r\n * Returns a map containing all key-value pairs with keys matching the given [predicate].\r\n *\r\n * The returned map preserves the entry iteration order of the original map.\r\n * @sample samples.collections.Maps.Filtering.filterKeys\r\n */\r\npublic inline fun <K, V> Map<out K, V>.filterKeys(predicate: (K) -> Boolean): Map<K, V> {\r\n    val result = LinkedHashMap<K, V>()\r\n    for (entry in this) {\r\n        if (predicate(entry.key)) {\r\n            result.put(entry.key, entry.value)\r\n        }\r\n    }\r\n    return result\r\n}\r\n\r\n/**\r\n * Returns a map containing all key-value pairs with values matching the given [predicate].\r\n *\r\n * The returned map preserves the entry iteration order of the original map.\r\n *  @sample samples.collections.Maps.Filtering.filterValues\r\n */\r\npublic inline fun <K, V> Map<out K, V>.filterValues(predicate: (V) -> Boolean): Map<K, V> {\r\n    val result = LinkedHashMap<K, V>()\r\n    for (entry in this) {\r\n        if (predicate(entry.value)) {\r\n            result.put(entry.key, entry.value)\r\n        }\r\n    }\r\n    return result\r\n}\r\n\r\n\r\n/**\r\n * Appends all entries matching the given [predicate] into the mutable map given as [destination] parameter.\r\n *\r\n * @return the destination map.\r\n * @sample samples.collections.Maps.Filtering.filterTo\r\n */\r\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\r\n    for (element in this) {\r\n        if (predicate(element)) {\r\n            destination.put(element.key, element.value)\r\n        }\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Returns a new map containing all key-value pairs matching the given [predicate].\r\n *\r\n * The returned map preserves the entry iteration order of the original map.\r\n * @sample samples.collections.Maps.Filtering.filter\r\n */\r\npublic inline fun <K, V> Map<out K, V>.filter(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\r\n    return filterTo(LinkedHashMap<K, V>(), predicate)\r\n}\r\n\r\n/**\r\n * Appends all entries not matching the given [predicate] into the given [destination].\r\n *\r\n * @return the destination map.\r\n * @sample samples.collections.Maps.Filtering.filterNotTo\r\n */\r\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterNotTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\r\n    for (element in this) {\r\n        if (!predicate(element)) {\r\n            destination.put(element.key, element.value)\r\n        }\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Returns a new map containing all key-value pairs not matching the given [predicate].\r\n *\r\n * The returned map preserves the entry iteration order of the original map.\r\n * @sample samples.collections.Maps.Filtering.filterNot\r\n */\r\npublic inline fun <K, V> Map<out K, V>.filterNot(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\r\n    return filterNotTo(LinkedHashMap<K, V>(), predicate)\r\n}\r\n\r\n/**\r\n * Returns a new map containing all key-value pairs from the given collection of pairs.\r\n *\r\n * The returned map preserves the entry iteration order of the original collection.\r\n * If any of two pairs would have the same key the last one gets added to the map.\r\n */\r\npublic fun <K, V> Iterable<Pair<K, V>>.toMap(): Map<K, V> {\r\n    if (this is Collection) {\r\n        return when (size) {\r\n            0 -> emptyMap()\r\n            1 -> mapOf(if (this is List) this[0] else iterator().next())\r\n            else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\r\n        }\r\n    }\r\n    return toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\r\n}\r\n\r\n/**\r\n * Populates and returns the [destination] mutable map with key-value pairs from the given collection of pairs.\r\n */\r\npublic fun <K, V, M : MutableMap<in K, in V>> Iterable<Pair<K, V>>.toMap(destination: M): M =\r\n    destination.apply { putAll(this@toMap) }\r\n\r\n/**\r\n * Returns a new map containing all key-value pairs from the given array of pairs.\r\n *\r\n * The returned map preserves the entry iteration order of the original array.\r\n * If any of two pairs would have the same key the last one gets added to the map.\r\n */\r\npublic fun <K, V> Array<out Pair<K, V>>.toMap(): Map<K, V> = when (size) {\r\n    0 -> emptyMap()\r\n    1 -> mapOf(this[0])\r\n    else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\r\n}\r\n\r\n/**\r\n *  Populates and returns the [destination] mutable map with key-value pairs from the given array of pairs.\r\n */\r\npublic fun <K, V, M : MutableMap<in K, in V>> Array<out Pair<K, V>>.toMap(destination: M): M =\r\n    destination.apply { putAll(this@toMap) }\r\n\r\n/**\r\n * Returns a new map containing all key-value pairs from the given sequence of pairs.\r\n *\r\n * The returned map preserves the entry iteration order of the original sequence.\r\n * If any of two pairs would have the same key the last one gets added to the map.\r\n */\r\npublic fun <K, V> Sequence<Pair<K, V>>.toMap(): Map<K, V> = toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\r\n\r\n/**\r\n * Populates and returns the [destination] mutable map with key-value pairs from the given sequence of pairs.\r\n */\r\npublic fun <K, V, M : MutableMap<in K, in V>> Sequence<Pair<K, V>>.toMap(destination: M): M =\r\n    destination.apply { putAll(this@toMap) }\r\n\r\n/**\r\n * Returns a new read-only map containing all key-value pairs from the original map.\r\n *\r\n * The returned map preserves the entry iteration order of the original map.\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic fun <K, V> Map<out K, V>.toMap(): Map<K, V> = when (size) {\r\n    0 -> emptyMap()\r\n    1 -> toSingletonMap()\r\n    else -> toMutableMap()\r\n}\r\n\r\n/**\r\n * Returns a new mutable map containing all key-value pairs from the original map.\r\n *\r\n * The returned map preserves the entry iteration order of the original map.\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic fun <K, V> Map<out K, V>.toMutableMap(): MutableMap<K, V> = LinkedHashMap(this)\r\n\r\n/**\r\n * Populates and returns the [destination] mutable map with key-value pairs from the given map.\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.toMap(destination: M): M =\r\n    destination.apply { putAll(this@toMap) }\r\n\r\n/**\r\n * Creates a new read-only map by replacing or adding an entry to this map from a given key-value [pair].\r\n *\r\n * The returned map preserves the entry iteration order of the original map.\r\n * The [pair] is iterated in the end if it has a unique key.\r\n */\r\npublic operator fun <K, V> Map<out K, V>.plus(pair: Pair<K, V>): Map<K, V> =\r\n    if (this.isEmpty()) mapOf(pair) else LinkedHashMap(this).apply { put(pair.first, pair.second) }\r\n\r\n/**\r\n * Creates a new read-only map by replacing or adding entries to this map from a given collection of key-value [pairs].\r\n *\r\n * The returned map preserves the entry iteration order of the original map.\r\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] collection.\r\n */\r\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Iterable<Pair<K, V>>): Map<K, V> =\r\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\r\n\r\n/**\r\n * Creates a new read-only map by replacing or adding entries to this map from a given array of key-value [pairs].\r\n *\r\n * The returned map preserves the entry iteration order of the original map.\r\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] array.\r\n */\r\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Array<out Pair<K, V>>): Map<K, V> =\r\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\r\n\r\n/**\r\n * Creates a new read-only map by replacing or adding entries to this map from a given sequence of key-value [pairs].\r\n *\r\n * The returned map preserves the entry iteration order of the original map.\r\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] sequence.\r\n */\r\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Sequence<Pair<K, V>>): Map<K, V> =\r\n    LinkedHashMap(this).apply { putAll(pairs) }.optimizeReadOnlyMap()\r\n\r\n/**\r\n * Creates a new read-only map by replacing or adding entries to this map from another [map].\r\n *\r\n * The returned map preserves the entry iteration order of the original map.\r\n * Those entries of another [map] that are missing in this map are iterated in the end in the order of that [map].\r\n */\r\npublic operator fun <K, V> Map<out K, V>.plus(map: Map<out K, V>): Map<K, V> =\r\n    LinkedHashMap(this).apply { putAll(map) }\r\n\r\n\r\n/**\r\n * Appends or replaces the given [pair] in this mutable map.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pair: Pair<K, V>) {\r\n    put(pair.first, pair.second)\r\n}\r\n\r\n/**\r\n * Appends or replaces all pairs from the given collection of [pairs] in this mutable map.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Iterable<Pair<K, V>>) {\r\n    putAll(pairs)\r\n}\r\n\r\n/**\r\n * Appends or replaces all pairs from the given array of [pairs] in this mutable map.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Array<out Pair<K, V>>) {\r\n    putAll(pairs)\r\n}\r\n\r\n/**\r\n * Appends or replaces all pairs from the given sequence of [pairs] in this mutable map.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Sequence<Pair<K, V>>) {\r\n    putAll(pairs)\r\n}\r\n\r\n/**\r\n * Appends or replaces all entries from the given [map] in this mutable map.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(map: Map<K, V>) {\r\n    putAll(map)\r\n}\r\n\r\n/**\r\n * Returns a map containing all entries of the original map except the entry with the given [key].\r\n *\r\n * The returned map preserves the entry iteration order of the original map.\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic operator fun <K, V> Map<out K, V>.minus(key: K): Map<K, V> =\r\n    this.toMutableMap().apply { minusAssign(key) }.optimizeReadOnlyMap()\r\n\r\n/**\r\n * Returns a map containing all entries of the original map except those entries\r\n * the keys of which are contained in the given [keys] collection.\r\n *\r\n * The returned map preserves the entry iteration order of the original map.\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic operator fun <K, V> Map<out K, V>.minus(keys: Iterable<K>): Map<K, V> =\r\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\r\n\r\n/**\r\n * Returns a map containing all entries of the original map except those entries\r\n * the keys of which are contained in the given [keys] array.\r\n *\r\n * The returned map preserves the entry iteration order of the original map.\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic operator fun <K, V> Map<out K, V>.minus(keys: Array<out K>): Map<K, V> =\r\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\r\n\r\n/**\r\n * Returns a map containing all entries of the original map except those entries\r\n * the keys of which are contained in the given [keys] sequence.\r\n *\r\n * The returned map preserves the entry iteration order of the original map.\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic operator fun <K, V> Map<out K, V>.minus(keys: Sequence<K>): Map<K, V> =\r\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\r\n\r\n/**\r\n * Removes the entry with the given [key] from this mutable map.\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(key: K) {\r\n    remove(key)\r\n}\r\n\r\n/**\r\n * Removes all entries the keys of which are contained in the given [keys] collection from this mutable map.\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Iterable<K>) {\r\n    this.keys.removeAll(keys)\r\n}\r\n\r\n/**\r\n * Removes all entries the keys of which are contained in the given [keys] array from this mutable map.\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Array<out K>) {\r\n    this.keys.removeAll(keys)\r\n}\r\n\r\n/**\r\n * Removes all entries from the keys of which are contained in the given [keys] sequence from this mutable map.\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Sequence<K>) {\r\n    this.keys.removeAll(keys)\r\n}\r\n\r\n\r\n// do not expose for now @PublishedApi\r\ninternal fun <K, V> Map<K, V>.optimizeReadOnlyMap() = when (size) {\r\n    0 -> emptyMap()\r\n    1 -> toSingletonMapOrSelf()\r\n    else -> this\r\n}\r\n","data class Checkpoint(\r\n    val date: Date,\r\n    val sergeySalary: Int,\r\n    val valyaSalary: Int,\r\n    val downpayment: Int,\r\n    val freeMoney: Int,\r\n    val expenses: Expenses,\r\n    val savingGoals: SavingGoals,\r\n    val flags: Map<String, Any> = mapOf(),\r\n    val messages: Array<String> = arrayOf()\r\n) {\r\n    fun messageArray() = messages\r\n    fun modifyDownpayment(increase: Int) = copy(downpayment = downpayment + increase)\r\n    @JsName(\"hasFlag\")\r\n    fun hasFlag(flagName:String) = flags.containsKey(flagName)\r\n}\r\n","class Condition {\r\n}\r\nclass Action","import kotlin.js.JsName\r\nimport kotlin.js.unsafeCast\r\nimport kotlin.math.min\r\nimport kotlin.js.Date as DateJS\r\n\r\nfun main() {\r\n    println(\"v3\")\r\n}\r\n@JsName(\"calc\")\r\nfun calc(init: dynamic, strats: Array<dynamic>): Array<Checkpoint> {\r\n    val initialCheckpoint = Checkpoint(\r\n        date = Date.from(init.date.unsafeCast<DateJS>()).copy(day = 1),\r\n        sergeySalary = init.sergeySalary,\r\n        valyaSalary = init.valyaSalary,\r\n        downpayment = init.downpayment,\r\n        freeMoney = init.freeMoney,\r\n        expenses = Expenses(init.expenses.life, init.expenses.rent),\r\n        savingGoals = SavingGoals(downpayment = init.goals.downpayment)\r\n    )\r\n    val proc = Processor()\r\n    val kstrats: List<Strategy> = strats.map { s ->\r\n        return@map when (s.type) {\r\n            \"BuyHouse\" -> BuyHouse(s.price, s.downpaymentPctn, s.mortgage)\r\n            \"MakeBaby\" -> MakeBaby(\r\n                hasFlag(s.conditionFlag),\r\n                s.delay,\r\n                s.workBeforeDecret,\r\n                s.decretAfterBirth,\r\n                s.newSalary\r\n            )\r\n            \"Custom\"->CustomStrat(s.once, s.condition, s.effect)\r\n            else -> NoopStrategy()\r\n        }\r\n    }\r\n    val strat = StratChain(*kstrats.toTypedArray())\r\n\r\n    val iters = dynamic2Int(init.iters)\r\n    var next = initialCheckpoint\r\n    var res = mutableListOf(initialCheckpoint)\r\n    for (i in 0 until iters) {\r\n        next = next.copy(messages = emptyArray())\r\n        println(\"$i \" + next)\r\n        next = strat.run(next)\r\n        next = proc.run(next)\r\n        res.add(next)\r\n    }\r\n    return res.toTypedArray()\r\n}\r\n\r\nfun dynamic2Int(a: dynamic): Int {\r\n    return a\r\n}\r\n\r\nprivate fun hasFlag(flag: String): (Checkpoint) -> Boolean = { it.flags.containsKey(flag) }\r\n\r\ndata class SavingGoals(val downpayment: Int = 0) {\r\n\r\n}\r\n\r\ndata class Expenses(val life: Int, val rent: Int, val mortgage: Int = 0) {\r\n    val total = life + rent + mortgage\r\n}\r\n\r\nclass Processor {\r\n    fun run(cp: Checkpoint): Checkpoint {\r\n        val income = cp.sergeySalary + cp.valyaSalary\r\n        val savings = income - cp.expenses.total\r\n        val dp = min(savings, cp.savingGoals.downpayment)\r\n        return cp.copy(\r\n            date = cp.date.plusMonths(1),\r\n            downpayment = cp.downpayment + dp,\r\n            freeMoney = cp.freeMoney + (savings - dp),\r\n            savingGoals = cp.savingGoals.copy(),\r\n            expenses = cp.expenses.copy()\r\n        )\r\n    }\r\n}\r\n\r\ndata class Date(val year: Int, val month: Int, val day: Int) {\r\n    fun plusMonths(addMonths: Int): Date {\r\n        val addYears = (month + addMonths) / 12\r\n        val newMonth = (month + addMonths) % 12\r\n        return Date(year + addYears, newMonth, day)\r\n    }\r\n\r\n    override fun toString() = \"${day.toString().padStart(2, '0')}/${month.toString().padStart(2, '0')}/$year\"\r\n\r\n    companion object {\r\n        fun now() = from(DateJS())\r\n        fun from(date: DateJS) = with(date) { Date(getFullYear(), getMonth(), getDate()) }\r\n    }\r\n}","/*\r\n * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license \r\n * that can be found in the license/LICENSE.txt file.\r\n */\r\n\r\n@file:kotlin.jvm.JvmMultifileClass\r\n@file:kotlin.jvm.JvmName(\"ArraysKt\")\r\n\r\npackage kotlin.collections\r\n\r\n//\r\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\r\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\r\n//\r\n\r\nimport kotlin.random.*\r\n\r\n/**\r\n * Returns 1st *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun <T> Array<out T>.component1(): T {\r\n    return get(0)\r\n}\r\n\r\n/**\r\n * Returns 1st *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun ByteArray.component1(): Byte {\r\n    return get(0)\r\n}\r\n\r\n/**\r\n * Returns 1st *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun ShortArray.component1(): Short {\r\n    return get(0)\r\n}\r\n\r\n/**\r\n * Returns 1st *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun IntArray.component1(): Int {\r\n    return get(0)\r\n}\r\n\r\n/**\r\n * Returns 1st *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun LongArray.component1(): Long {\r\n    return get(0)\r\n}\r\n\r\n/**\r\n * Returns 1st *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun FloatArray.component1(): Float {\r\n    return get(0)\r\n}\r\n\r\n/**\r\n * Returns 1st *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun DoubleArray.component1(): Double {\r\n    return get(0)\r\n}\r\n\r\n/**\r\n * Returns 1st *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun BooleanArray.component1(): Boolean {\r\n    return get(0)\r\n}\r\n\r\n/**\r\n * Returns 1st *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun CharArray.component1(): Char {\r\n    return get(0)\r\n}\r\n\r\n/**\r\n * Returns 2nd *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun <T> Array<out T>.component2(): T {\r\n    return get(1)\r\n}\r\n\r\n/**\r\n * Returns 2nd *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun ByteArray.component2(): Byte {\r\n    return get(1)\r\n}\r\n\r\n/**\r\n * Returns 2nd *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun ShortArray.component2(): Short {\r\n    return get(1)\r\n}\r\n\r\n/**\r\n * Returns 2nd *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun IntArray.component2(): Int {\r\n    return get(1)\r\n}\r\n\r\n/**\r\n * Returns 2nd *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun LongArray.component2(): Long {\r\n    return get(1)\r\n}\r\n\r\n/**\r\n * Returns 2nd *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun FloatArray.component2(): Float {\r\n    return get(1)\r\n}\r\n\r\n/**\r\n * Returns 2nd *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun DoubleArray.component2(): Double {\r\n    return get(1)\r\n}\r\n\r\n/**\r\n * Returns 2nd *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun BooleanArray.component2(): Boolean {\r\n    return get(1)\r\n}\r\n\r\n/**\r\n * Returns 2nd *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun CharArray.component2(): Char {\r\n    return get(1)\r\n}\r\n\r\n/**\r\n * Returns 3rd *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun <T> Array<out T>.component3(): T {\r\n    return get(2)\r\n}\r\n\r\n/**\r\n * Returns 3rd *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun ByteArray.component3(): Byte {\r\n    return get(2)\r\n}\r\n\r\n/**\r\n * Returns 3rd *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun ShortArray.component3(): Short {\r\n    return get(2)\r\n}\r\n\r\n/**\r\n * Returns 3rd *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun IntArray.component3(): Int {\r\n    return get(2)\r\n}\r\n\r\n/**\r\n * Returns 3rd *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun LongArray.component3(): Long {\r\n    return get(2)\r\n}\r\n\r\n/**\r\n * Returns 3rd *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun FloatArray.component3(): Float {\r\n    return get(2)\r\n}\r\n\r\n/**\r\n * Returns 3rd *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun DoubleArray.component3(): Double {\r\n    return get(2)\r\n}\r\n\r\n/**\r\n * Returns 3rd *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun BooleanArray.component3(): Boolean {\r\n    return get(2)\r\n}\r\n\r\n/**\r\n * Returns 3rd *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun CharArray.component3(): Char {\r\n    return get(2)\r\n}\r\n\r\n/**\r\n * Returns 4th *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun <T> Array<out T>.component4(): T {\r\n    return get(3)\r\n}\r\n\r\n/**\r\n * Returns 4th *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun ByteArray.component4(): Byte {\r\n    return get(3)\r\n}\r\n\r\n/**\r\n * Returns 4th *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun ShortArray.component4(): Short {\r\n    return get(3)\r\n}\r\n\r\n/**\r\n * Returns 4th *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun IntArray.component4(): Int {\r\n    return get(3)\r\n}\r\n\r\n/**\r\n * Returns 4th *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun LongArray.component4(): Long {\r\n    return get(3)\r\n}\r\n\r\n/**\r\n * Returns 4th *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun FloatArray.component4(): Float {\r\n    return get(3)\r\n}\r\n\r\n/**\r\n * Returns 4th *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun DoubleArray.component4(): Double {\r\n    return get(3)\r\n}\r\n\r\n/**\r\n * Returns 4th *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun BooleanArray.component4(): Boolean {\r\n    return get(3)\r\n}\r\n\r\n/**\r\n * Returns 4th *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun CharArray.component4(): Char {\r\n    return get(3)\r\n}\r\n\r\n/**\r\n * Returns 5th *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun <T> Array<out T>.component5(): T {\r\n    return get(4)\r\n}\r\n\r\n/**\r\n * Returns 5th *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun ByteArray.component5(): Byte {\r\n    return get(4)\r\n}\r\n\r\n/**\r\n * Returns 5th *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun ShortArray.component5(): Short {\r\n    return get(4)\r\n}\r\n\r\n/**\r\n * Returns 5th *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun IntArray.component5(): Int {\r\n    return get(4)\r\n}\r\n\r\n/**\r\n * Returns 5th *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun LongArray.component5(): Long {\r\n    return get(4)\r\n}\r\n\r\n/**\r\n * Returns 5th *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun FloatArray.component5(): Float {\r\n    return get(4)\r\n}\r\n\r\n/**\r\n * Returns 5th *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun DoubleArray.component5(): Double {\r\n    return get(4)\r\n}\r\n\r\n/**\r\n * Returns 5th *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun BooleanArray.component5(): Boolean {\r\n    return get(4)\r\n}\r\n\r\n/**\r\n * Returns 5th *element* from the collection.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline operator fun CharArray.component5(): Char {\r\n    return get(4)\r\n}\r\n\r\n/**\r\n * Returns `true` if [element] is found in the array.\r\n */\r\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.contains(element: T): Boolean {\r\n    return indexOf(element) >= 0\r\n}\r\n\r\n/**\r\n * Returns `true` if [element] is found in the array.\r\n */\r\npublic operator fun ByteArray.contains(element: Byte): Boolean {\r\n    return indexOf(element) >= 0\r\n}\r\n\r\n/**\r\n * Returns `true` if [element] is found in the array.\r\n */\r\npublic operator fun ShortArray.contains(element: Short): Boolean {\r\n    return indexOf(element) >= 0\r\n}\r\n\r\n/**\r\n * Returns `true` if [element] is found in the array.\r\n */\r\npublic operator fun IntArray.contains(element: Int): Boolean {\r\n    return indexOf(element) >= 0\r\n}\r\n\r\n/**\r\n * Returns `true` if [element] is found in the array.\r\n */\r\npublic operator fun LongArray.contains(element: Long): Boolean {\r\n    return indexOf(element) >= 0\r\n}\r\n\r\n/**\r\n * Returns `true` if [element] is found in the array.\r\n */\r\npublic operator fun FloatArray.contains(element: Float): Boolean {\r\n    return indexOf(element) >= 0\r\n}\r\n\r\n/**\r\n * Returns `true` if [element] is found in the array.\r\n */\r\npublic operator fun DoubleArray.contains(element: Double): Boolean {\r\n    return indexOf(element) >= 0\r\n}\r\n\r\n/**\r\n * Returns `true` if [element] is found in the array.\r\n */\r\npublic operator fun BooleanArray.contains(element: Boolean): Boolean {\r\n    return indexOf(element) >= 0\r\n}\r\n\r\n/**\r\n * Returns `true` if [element] is found in the array.\r\n */\r\npublic operator fun CharArray.contains(element: Char): Boolean {\r\n    return indexOf(element) >= 0\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\r\n * \r\n * @sample samples.collections.Collections.Elements.elementAt\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun <T> Array<out T>.elementAt(index: Int): T {\r\n    return get(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\r\n * \r\n * @sample samples.collections.Collections.Elements.elementAt\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun ByteArray.elementAt(index: Int): Byte {\r\n    return get(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\r\n * \r\n * @sample samples.collections.Collections.Elements.elementAt\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun ShortArray.elementAt(index: Int): Short {\r\n    return get(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\r\n * \r\n * @sample samples.collections.Collections.Elements.elementAt\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun IntArray.elementAt(index: Int): Int {\r\n    return get(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\r\n * \r\n * @sample samples.collections.Collections.Elements.elementAt\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun LongArray.elementAt(index: Int): Long {\r\n    return get(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\r\n * \r\n * @sample samples.collections.Collections.Elements.elementAt\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun FloatArray.elementAt(index: Int): Float {\r\n    return get(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\r\n * \r\n * @sample samples.collections.Collections.Elements.elementAt\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun DoubleArray.elementAt(index: Int): Double {\r\n    return get(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\r\n * \r\n * @sample samples.collections.Collections.Elements.elementAt\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun BooleanArray.elementAt(index: Int): Boolean {\r\n    return get(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\r\n * \r\n * @sample samples.collections.Collections.Elements.elementAt\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun CharArray.elementAt(index: Int): Char {\r\n    return get(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\r\n * \r\n * @sample samples.collections.Collections.Elements.elementAtOrElse\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun <T> Array<out T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\r\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\r\n * \r\n * @sample samples.collections.Collections.Elements.elementAtOrElse\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun ByteArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Byte): Byte {\r\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\r\n * \r\n * @sample samples.collections.Collections.Elements.elementAtOrElse\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun ShortArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Short): Short {\r\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\r\n * \r\n * @sample samples.collections.Collections.Elements.elementAtOrElse\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun IntArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Int): Int {\r\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\r\n * \r\n * @sample samples.collections.Collections.Elements.elementAtOrElse\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun LongArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Long): Long {\r\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\r\n * \r\n * @sample samples.collections.Collections.Elements.elementAtOrElse\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun FloatArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Float): Float {\r\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\r\n * \r\n * @sample samples.collections.Collections.Elements.elementAtOrElse\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun DoubleArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Double): Double {\r\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\r\n * \r\n * @sample samples.collections.Collections.Elements.elementAtOrElse\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun BooleanArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean {\r\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\r\n * \r\n * @sample samples.collections.Collections.Elements.elementAtOrElse\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun CharArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char {\r\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\r\n * \r\n * @sample samples.collections.Collections.Elements.elementAtOrNull\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun <T> Array<out T>.elementAtOrNull(index: Int): T? {\r\n    return this.getOrNull(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\r\n * \r\n * @sample samples.collections.Collections.Elements.elementAtOrNull\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun ByteArray.elementAtOrNull(index: Int): Byte? {\r\n    return this.getOrNull(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\r\n * \r\n * @sample samples.collections.Collections.Elements.elementAtOrNull\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun ShortArray.elementAtOrNull(index: Int): Short? {\r\n    return this.getOrNull(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\r\n * \r\n * @sample samples.collections.Collections.Elements.elementAtOrNull\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun IntArray.elementAtOrNull(index: Int): Int? {\r\n    return this.getOrNull(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\r\n * \r\n * @sample samples.collections.Collections.Elements.elementAtOrNull\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun LongArray.elementAtOrNull(index: Int): Long? {\r\n    return this.getOrNull(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\r\n * \r\n * @sample samples.collections.Collections.Elements.elementAtOrNull\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun FloatArray.elementAtOrNull(index: Int): Float? {\r\n    return this.getOrNull(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\r\n * \r\n * @sample samples.collections.Collections.Elements.elementAtOrNull\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun DoubleArray.elementAtOrNull(index: Int): Double? {\r\n    return this.getOrNull(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\r\n * \r\n * @sample samples.collections.Collections.Elements.elementAtOrNull\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun BooleanArray.elementAtOrNull(index: Int): Boolean? {\r\n    return this.getOrNull(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\r\n * \r\n * @sample samples.collections.Collections.Elements.elementAtOrNull\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun CharArray.elementAtOrNull(index: Int): Char? {\r\n    return this.getOrNull(index)\r\n}\r\n\r\n/**\r\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun <T> Array<out T>.find(predicate: (T) -> Boolean): T? {\r\n    return firstOrNull(predicate)\r\n}\r\n\r\n/**\r\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun ByteArray.find(predicate: (Byte) -> Boolean): Byte? {\r\n    return firstOrNull(predicate)\r\n}\r\n\r\n/**\r\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun ShortArray.find(predicate: (Short) -> Boolean): Short? {\r\n    return firstOrNull(predicate)\r\n}\r\n\r\n/**\r\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun IntArray.find(predicate: (Int) -> Boolean): Int? {\r\n    return firstOrNull(predicate)\r\n}\r\n\r\n/**\r\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun LongArray.find(predicate: (Long) -> Boolean): Long? {\r\n    return firstOrNull(predicate)\r\n}\r\n\r\n/**\r\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun FloatArray.find(predicate: (Float) -> Boolean): Float? {\r\n    return firstOrNull(predicate)\r\n}\r\n\r\n/**\r\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun DoubleArray.find(predicate: (Double) -> Boolean): Double? {\r\n    return firstOrNull(predicate)\r\n}\r\n\r\n/**\r\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun BooleanArray.find(predicate: (Boolean) -> Boolean): Boolean? {\r\n    return firstOrNull(predicate)\r\n}\r\n\r\n/**\r\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun CharArray.find(predicate: (Char) -> Boolean): Char? {\r\n    return firstOrNull(predicate)\r\n}\r\n\r\n/**\r\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun <T> Array<out T>.findLast(predicate: (T) -> Boolean): T? {\r\n    return lastOrNull(predicate)\r\n}\r\n\r\n/**\r\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun ByteArray.findLast(predicate: (Byte) -> Boolean): Byte? {\r\n    return lastOrNull(predicate)\r\n}\r\n\r\n/**\r\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun ShortArray.findLast(predicate: (Short) -> Boolean): Short? {\r\n    return lastOrNull(predicate)\r\n}\r\n\r\n/**\r\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun IntArray.findLast(predicate: (Int) -> Boolean): Int? {\r\n    return lastOrNull(predicate)\r\n}\r\n\r\n/**\r\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun LongArray.findLast(predicate: (Long) -> Boolean): Long? {\r\n    return lastOrNull(predicate)\r\n}\r\n\r\n/**\r\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun FloatArray.findLast(predicate: (Float) -> Boolean): Float? {\r\n    return lastOrNull(predicate)\r\n}\r\n\r\n/**\r\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun DoubleArray.findLast(predicate: (Double) -> Boolean): Double? {\r\n    return lastOrNull(predicate)\r\n}\r\n\r\n/**\r\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun BooleanArray.findLast(predicate: (Boolean) -> Boolean): Boolean? {\r\n    return lastOrNull(predicate)\r\n}\r\n\r\n/**\r\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun CharArray.findLast(predicate: (Char) -> Boolean): Char? {\r\n    return lastOrNull(predicate)\r\n}\r\n\r\n/**\r\n * Returns first element.\r\n * @throws [NoSuchElementException] if the array is empty.\r\n */\r\npublic fun <T> Array<out T>.first(): T {\r\n    if (isEmpty())\r\n        throw NoSuchElementException(\"Array is empty.\")\r\n    return this[0]\r\n}\r\n\r\n/**\r\n * Returns first element.\r\n * @throws [NoSuchElementException] if the array is empty.\r\n */\r\npublic fun ByteArray.first(): Byte {\r\n    if (isEmpty())\r\n        throw NoSuchElementException(\"Array is empty.\")\r\n    return this[0]\r\n}\r\n\r\n/**\r\n * Returns first element.\r\n * @throws [NoSuchElementException] if the array is empty.\r\n */\r\npublic fun ShortArray.first(): Short {\r\n    if (isEmpty())\r\n        throw NoSuchElementException(\"Array is empty.\")\r\n    return this[0]\r\n}\r\n\r\n/**\r\n * Returns first element.\r\n * @throws [NoSuchElementException] if the array is empty.\r\n */\r\npublic fun IntArray.first(): Int {\r\n    if (isEmpty())\r\n        throw NoSuchElementException(\"Array is empty.\")\r\n    return this[0]\r\n}\r\n\r\n/**\r\n * Returns first element.\r\n * @throws [NoSuchElementException] if the array is empty.\r\n */\r\npublic fun LongArray.first(): Long {\r\n    if (isEmpty())\r\n        throw NoSuchElementException(\"Array is empty.\")\r\n    return this[0]\r\n}\r\n\r\n/**\r\n * Returns first element.\r\n * @throws [NoSuchElementException] if the array is empty.\r\n */\r\npublic fun FloatArray.first(): Float {\r\n    if (isEmpty())\r\n        throw NoSuchElementException(\"Array is empty.\")\r\n    return this[0]\r\n}\r\n\r\n/**\r\n * Returns first element.\r\n * @throws [NoSuchElementException] if the array is empty.\r\n */\r\npublic fun DoubleArray.first(): Double {\r\n    if (isEmpty())\r\n        throw NoSuchElementException(\"Array is empty.\")\r\n    return this[0]\r\n}\r\n\r\n/**\r\n * Returns first element.\r\n * @throws [NoSuchElementException] if the array is empty.\r\n */\r\npublic fun BooleanArray.first(): Boolean {\r\n    if (isEmpty())\r\n        throw NoSuchElementException(\"Array is empty.\")\r\n    return this[0]\r\n}\r\n\r\n/**\r\n * Returns first element.\r\n * @throws [NoSuchElementException] if the array is empty.\r\n */\r\npublic fun CharArray.first(): Char {\r\n    if (isEmpty())\r\n        throw NoSuchElementException(\"Array is empty.\")\r\n    return this[0]\r\n}\r\n\r\n/**\r\n * Returns the first element matching the given [predicate].\r\n * @throws [NoSuchElementException] if no such element is found.\r\n */\r\npublic inline fun <T> Array<out T>.first(predicate: (T) -> Boolean): T {\r\n    for (element in this) if (predicate(element)) return element\r\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\r\n}\r\n\r\n/**\r\n * Returns the first element matching the given [predicate].\r\n * @throws [NoSuchElementException] if no such element is found.\r\n */\r\npublic inline fun ByteArray.first(predicate: (Byte) -> Boolean): Byte {\r\n    for (element in this) if (predicate(element)) return element\r\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\r\n}\r\n\r\n/**\r\n * Returns the first element matching the given [predicate].\r\n * @throws [NoSuchElementException] if no such element is found.\r\n */\r\npublic inline fun ShortArray.first(predicate: (Short) -> Boolean): Short {\r\n    for (element in this) if (predicate(element)) return element\r\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\r\n}\r\n\r\n/**\r\n * Returns the first element matching the given [predicate].\r\n * @throws [NoSuchElementException] if no such element is found.\r\n */\r\npublic inline fun IntArray.first(predicate: (Int) -> Boolean): Int {\r\n    for (element in this) if (predicate(element)) return element\r\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\r\n}\r\n\r\n/**\r\n * Returns the first element matching the given [predicate].\r\n * @throws [NoSuchElementException] if no such element is found.\r\n */\r\npublic inline fun LongArray.first(predicate: (Long) -> Boolean): Long {\r\n    for (element in this) if (predicate(element)) return element\r\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\r\n}\r\n\r\n/**\r\n * Returns the first element matching the given [predicate].\r\n * @throws [NoSuchElementException] if no such element is found.\r\n */\r\npublic inline fun FloatArray.first(predicate: (Float) -> Boolean): Float {\r\n    for (element in this) if (predicate(element)) return element\r\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\r\n}\r\n\r\n/**\r\n * Returns the first element matching the given [predicate].\r\n * @throws [NoSuchElementException] if no such element is found.\r\n */\r\npublic inline fun DoubleArray.first(predicate: (Double) -> Boolean): Double {\r\n    for (element in this) if (predicate(element)) return element\r\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\r\n}\r\n\r\n/**\r\n * Returns the first element matching the given [predicate].\r\n * @throws [NoSuchElementException] if no such element is found.\r\n */\r\npublic inline fun BooleanArray.first(predicate: (Boolean) -> Boolean): Boolean {\r\n    for (element in this) if (predicate(element)) return element\r\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\r\n}\r\n\r\n/**\r\n * Returns the first element matching the given [predicate].\r\n * @throws [NoSuchElementException] if no such element is found.\r\n */\r\npublic inline fun CharArray.first(predicate: (Char) -> Boolean): Char {\r\n    for (element in this) if (predicate(element)) return element\r\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\r\n}\r\n\r\n/**\r\n * Returns the first element, or `null` if the array is empty.\r\n */\r\npublic fun <T> Array<out T>.firstOrNull(): T? {\r\n    return if (isEmpty()) null else this[0]\r\n}\r\n\r\n/**\r\n * Returns the first element, or `null` if the array is empty.\r\n */\r\npublic fun ByteArray.firstOrNull(): Byte? {\r\n    return if (isEmpty()) null else this[0]\r\n}\r\n\r\n/**\r\n * Returns the first element, or `null` if the array is empty.\r\n */\r\npublic fun ShortArray.firstOrNull(): Short? {\r\n    return if (isEmpty()) null else this[0]\r\n}\r\n\r\n/**\r\n * Returns the first element, or `null` if the array is empty.\r\n */\r\npublic fun IntArray.firstOrNull(): Int? {\r\n    return if (isEmpty()) null else this[0]\r\n}\r\n\r\n/**\r\n * Returns the first element, or `null` if the array is empty.\r\n */\r\npublic fun LongArray.firstOrNull(): Long? {\r\n    return if (isEmpty()) null else this[0]\r\n}\r\n\r\n/**\r\n * Returns the first element, or `null` if the array is empty.\r\n */\r\npublic fun FloatArray.firstOrNull(): Float? {\r\n    return if (isEmpty()) null else this[0]\r\n}\r\n\r\n/**\r\n * Returns the first element, or `null` if the array is empty.\r\n */\r\npublic fun DoubleArray.firstOrNull(): Double? {\r\n    return if (isEmpty()) null else this[0]\r\n}\r\n\r\n/**\r\n * Returns the first element, or `null` if the array is empty.\r\n */\r\npublic fun BooleanArray.firstOrNull(): Boolean? {\r\n    return if (isEmpty()) null else this[0]\r\n}\r\n\r\n/**\r\n * Returns the first element, or `null` if the array is empty.\r\n */\r\npublic fun CharArray.firstOrNull(): Char? {\r\n    return if (isEmpty()) null else this[0]\r\n}\r\n\r\n/**\r\n * Returns the first element matching the given [predicate], or `null` if element was not found.\r\n */\r\npublic inline fun <T> Array<out T>.firstOrNull(predicate: (T) -> Boolean): T? {\r\n    for (element in this) if (predicate(element)) return element\r\n    return null\r\n}\r\n\r\n/**\r\n * Returns the first element matching the given [predicate], or `null` if element was not found.\r\n */\r\npublic inline fun ByteArray.firstOrNull(predicate: (Byte) -> Boolean): Byte? {\r\n    for (element in this) if (predicate(element)) return element\r\n    return null\r\n}\r\n\r\n/**\r\n * Returns the first element matching the given [predicate], or `null` if element was not found.\r\n */\r\npublic inline fun ShortArray.firstOrNull(predicate: (Short) -> Boolean): Short? {\r\n    for (element in this) if (predicate(element)) return element\r\n    return null\r\n}\r\n\r\n/**\r\n * Returns the first element matching the given [predicate], or `null` if element was not found.\r\n */\r\npublic inline fun IntArray.firstOrNull(predicate: (Int) -> Boolean): Int? {\r\n    for (element in this) if (predicate(element)) return element\r\n    return null\r\n}\r\n\r\n/**\r\n * Returns the first element matching the given [predicate], or `null` if element was not found.\r\n */\r\npublic inline fun LongArray.firstOrNull(predicate: (Long) -> Boolean): Long? {\r\n    for (element in this) if (predicate(element)) return element\r\n    return null\r\n}\r\n\r\n/**\r\n * Returns the first element matching the given [predicate], or `null` if element was not found.\r\n */\r\npublic inline fun FloatArray.firstOrNull(predicate: (Float) -> Boolean): Float? {\r\n    for (element in this) if (predicate(element)) return element\r\n    return null\r\n}\r\n\r\n/**\r\n * Returns the first element matching the given [predicate], or `null` if element was not found.\r\n */\r\npublic inline fun DoubleArray.firstOrNull(predicate: (Double) -> Boolean): Double? {\r\n    for (element in this) if (predicate(element)) return element\r\n    return null\r\n}\r\n\r\n/**\r\n * Returns the first element matching the given [predicate], or `null` if element was not found.\r\n */\r\npublic inline fun BooleanArray.firstOrNull(predicate: (Boolean) -> Boolean): Boolean? {\r\n    for (element in this) if (predicate(element)) return element\r\n    return null\r\n}\r\n\r\n/**\r\n * Returns the first element matching the given [predicate], or `null` if element was not found.\r\n */\r\npublic inline fun CharArray.firstOrNull(predicate: (Char) -> Boolean): Char? {\r\n    for (element in this) if (predicate(element)) return element\r\n    return null\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun <T> Array<out T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\r\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun ByteArray.getOrElse(index: Int, defaultValue: (Int) -> Byte): Byte {\r\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun ShortArray.getOrElse(index: Int, defaultValue: (Int) -> Short): Short {\r\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun IntArray.getOrElse(index: Int, defaultValue: (Int) -> Int): Int {\r\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun LongArray.getOrElse(index: Int, defaultValue: (Int) -> Long): Long {\r\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun FloatArray.getOrElse(index: Int, defaultValue: (Int) -> Float): Float {\r\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun DoubleArray.getOrElse(index: Int, defaultValue: (Int) -> Double): Double {\r\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun BooleanArray.getOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean {\r\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun CharArray.getOrElse(index: Int, defaultValue: (Int) -> Char): Char {\r\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\r\n */\r\npublic fun <T> Array<out T>.getOrNull(index: Int): T? {\r\n    return if (index >= 0 && index <= lastIndex) get(index) else null\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\r\n */\r\npublic fun ByteArray.getOrNull(index: Int): Byte? {\r\n    return if (index >= 0 && index <= lastIndex) get(index) else null\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\r\n */\r\npublic fun ShortArray.getOrNull(index: Int): Short? {\r\n    return if (index >= 0 && index <= lastIndex) get(index) else null\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\r\n */\r\npublic fun IntArray.getOrNull(index: Int): Int? {\r\n    return if (index >= 0 && index <= lastIndex) get(index) else null\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\r\n */\r\npublic fun LongArray.getOrNull(index: Int): Long? {\r\n    return if (index >= 0 && index <= lastIndex) get(index) else null\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\r\n */\r\npublic fun FloatArray.getOrNull(index: Int): Float? {\r\n    return if (index >= 0 && index <= lastIndex) get(index) else null\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\r\n */\r\npublic fun DoubleArray.getOrNull(index: Int): Double? {\r\n    return if (index >= 0 && index <= lastIndex) get(index) else null\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\r\n */\r\npublic fun BooleanArray.getOrNull(index: Int): Boolean? {\r\n    return if (index >= 0 && index <= lastIndex) get(index) else null\r\n}\r\n\r\n/**\r\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\r\n */\r\npublic fun CharArray.getOrNull(index: Int): Char? {\r\n    return if (index >= 0 && index <= lastIndex) get(index) else null\r\n}\r\n\r\n/**\r\n * Returns first index of [element], or -1 if the array does not contain element.\r\n */\r\npublic fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.indexOf(element: T): Int {\r\n    if (element == null) {\r\n        for (index in indices) {\r\n            if (this[index] == null) {\r\n                return index\r\n            }\r\n        }\r\n    } else {\r\n        for (index in indices) {\r\n            if (element == this[index]) {\r\n                return index\r\n            }\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns first index of [element], or -1 if the array does not contain element.\r\n */\r\npublic fun ByteArray.indexOf(element: Byte): Int {\r\n    for (index in indices) {\r\n        if (element == this[index]) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns first index of [element], or -1 if the array does not contain element.\r\n */\r\npublic fun ShortArray.indexOf(element: Short): Int {\r\n    for (index in indices) {\r\n        if (element == this[index]) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns first index of [element], or -1 if the array does not contain element.\r\n */\r\npublic fun IntArray.indexOf(element: Int): Int {\r\n    for (index in indices) {\r\n        if (element == this[index]) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns first index of [element], or -1 if the array does not contain element.\r\n */\r\npublic fun LongArray.indexOf(element: Long): Int {\r\n    for (index in indices) {\r\n        if (element == this[index]) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns first index of [element], or -1 if the array does not contain element.\r\n */\r\npublic fun FloatArray.indexOf(element: Float): Int {\r\n    for (index in indices) {\r\n        if (element == this[index]) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns first index of [element], or -1 if the array does not contain element.\r\n */\r\npublic fun DoubleArray.indexOf(element: Double): Int {\r\n    for (index in indices) {\r\n        if (element == this[index]) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns first index of [element], or -1 if the array does not contain element.\r\n */\r\npublic fun BooleanArray.indexOf(element: Boolean): Int {\r\n    for (index in indices) {\r\n        if (element == this[index]) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns first index of [element], or -1 if the array does not contain element.\r\n */\r\npublic fun CharArray.indexOf(element: Char): Int {\r\n    for (index in indices) {\r\n        if (element == this[index]) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\r\n */\r\npublic inline fun <T> Array<out T>.indexOfFirst(predicate: (T) -> Boolean): Int {\r\n    for (index in indices) {\r\n        if (predicate(this[index])) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\r\n */\r\npublic inline fun ByteArray.indexOfFirst(predicate: (Byte) -> Boolean): Int {\r\n    for (index in indices) {\r\n        if (predicate(this[index])) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\r\n */\r\npublic inline fun ShortArray.indexOfFirst(predicate: (Short) -> Boolean): Int {\r\n    for (index in indices) {\r\n        if (predicate(this[index])) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\r\n */\r\npublic inline fun IntArray.indexOfFirst(predicate: (Int) -> Boolean): Int {\r\n    for (index in indices) {\r\n        if (predicate(this[index])) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\r\n */\r\npublic inline fun LongArray.indexOfFirst(predicate: (Long) -> Boolean): Int {\r\n    for (index in indices) {\r\n        if (predicate(this[index])) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\r\n */\r\npublic inline fun FloatArray.indexOfFirst(predicate: (Float) -> Boolean): Int {\r\n    for (index in indices) {\r\n        if (predicate(this[index])) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\r\n */\r\npublic inline fun DoubleArray.indexOfFirst(predicate: (Double) -> Boolean): Int {\r\n    for (index in indices) {\r\n        if (predicate(this[index])) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\r\n */\r\npublic inline fun BooleanArray.indexOfFirst(predicate: (Boolean) -> Boolean): Int {\r\n    for (index in indices) {\r\n        if (predicate(this[index])) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\r\n */\r\npublic inline fun CharArray.indexOfFirst(predicate: (Char) -> Boolean): Int {\r\n    for (index in indices) {\r\n        if (predicate(this[index])) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\r\n */\r\npublic inline fun <T> Array<out T>.indexOfLast(predicate: (T) -> Boolean): Int {\r\n    for (index in indices.reversed()) {\r\n        if (predicate(this[index])) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\r\n */\r\npublic inline fun ByteArray.indexOfLast(predicate: (Byte) -> Boolean): Int {\r\n    for (index in indices.reversed()) {\r\n        if (predicate(this[index])) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\r\n */\r\npublic inline fun ShortArray.indexOfLast(predicate: (Short) -> Boolean): Int {\r\n    for (index in indices.reversed()) {\r\n        if (predicate(this[index])) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\r\n */\r\npublic inline fun IntArray.indexOfLast(predicate: (Int) -> Boolean): Int {\r\n    for (index in indices.reversed()) {\r\n        if (predicate(this[index])) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\r\n */\r\npublic inline fun LongArray.indexOfLast(predicate: (Long) -> Boolean): Int {\r\n    for (index in indices.reversed()) {\r\n        if (predicate(this[index])) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\r\n */\r\npublic inline fun FloatArray.indexOfLast(predicate: (Float) -> Boolean): Int {\r\n    for (index in indices.reversed()) {\r\n        if (predicate(this[index])) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\r\n */\r\npublic inline fun DoubleArray.indexOfLast(predicate: (Double) -> Boolean): Int {\r\n    for (index in indices.reversed()) {\r\n        if (predicate(this[index])) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\r\n */\r\npublic inline fun BooleanArray.indexOfLast(predicate: (Boolean) -> Boolean): Int {\r\n    for (index in indices.reversed()) {\r\n        if (predicate(this[index])) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\r\n */\r\npublic inline fun CharArray.indexOfLast(predicate: (Char) -> Boolean): Int {\r\n    for (index in indices.reversed()) {\r\n        if (predicate(this[index])) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns the last element.\r\n * @throws [NoSuchElementException] if the array is empty.\r\n */\r\npublic fun <T> Array<out T>.last(): T {\r\n    if (isEmpty())\r\n        throw NoSuchElementException(\"Array is empty.\")\r\n    return this[lastIndex]\r\n}\r\n\r\n/**\r\n * Returns the last element.\r\n * @throws [NoSuchElementException] if the array is empty.\r\n */\r\npublic fun ByteArray.last(): Byte {\r\n    if (isEmpty())\r\n        throw NoSuchElementException(\"Array is empty.\")\r\n    return this[lastIndex]\r\n}\r\n\r\n/**\r\n * Returns the last element.\r\n * @throws [NoSuchElementException] if the array is empty.\r\n */\r\npublic fun ShortArray.last(): Short {\r\n    if (isEmpty())\r\n        throw NoSuchElementException(\"Array is empty.\")\r\n    return this[lastIndex]\r\n}\r\n\r\n/**\r\n * Returns the last element.\r\n * @throws [NoSuchElementException] if the array is empty.\r\n */\r\npublic fun IntArray.last(): Int {\r\n    if (isEmpty())\r\n        throw NoSuchElementException(\"Array is empty.\")\r\n    return this[lastIndex]\r\n}\r\n\r\n/**\r\n * Returns the last element.\r\n * @throws [NoSuchElementException] if the array is empty.\r\n */\r\npublic fun LongArray.last(): Long {\r\n    if (isEmpty())\r\n        throw NoSuchElementException(\"Array is empty.\")\r\n    return this[lastIndex]\r\n}\r\n\r\n/**\r\n * Returns the last element.\r\n * @throws [NoSuchElementException] if the array is empty.\r\n */\r\npublic fun FloatArray.last(): Float {\r\n    if (isEmpty())\r\n        throw NoSuchElementException(\"Array is empty.\")\r\n    return this[lastIndex]\r\n}\r\n\r\n/**\r\n * Returns the last element.\r\n * @throws [NoSuchElementException] if the array is empty.\r\n */\r\npublic fun DoubleArray.last(): Double {\r\n    if (isEmpty())\r\n        throw NoSuchElementException(\"Array is empty.\")\r\n    return this[lastIndex]\r\n}\r\n\r\n/**\r\n * Returns the last element.\r\n * @throws [NoSuchElementException] if the array is empty.\r\n */\r\npublic fun BooleanArray.last(): Boolean {\r\n    if (isEmpty())\r\n        throw NoSuchElementException(\"Array is empty.\")\r\n    return this[lastIndex]\r\n}\r\n\r\n/**\r\n * Returns the last element.\r\n * @throws [NoSuchElementException] if the array is empty.\r\n */\r\npublic fun CharArray.last(): Char {\r\n    if (isEmpty())\r\n        throw NoSuchElementException(\"Array is empty.\")\r\n    return this[lastIndex]\r\n}\r\n\r\n/**\r\n * Returns the last element matching the given [predicate].\r\n * @throws [NoSuchElementException] if no such element is found.\r\n */\r\npublic inline fun <T> Array<out T>.last(predicate: (T) -> Boolean): T {\r\n    for (index in this.indices.reversed()) {\r\n        val element = this[index]\r\n        if (predicate(element)) return element\r\n    }\r\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\r\n}\r\n\r\n/**\r\n * Returns the last element matching the given [predicate].\r\n * @throws [NoSuchElementException] if no such element is found.\r\n */\r\npublic inline fun ByteArray.last(predicate: (Byte) -> Boolean): Byte {\r\n    for (index in this.indices.reversed()) {\r\n        val element = this[index]\r\n        if (predicate(element)) return element\r\n    }\r\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\r\n}\r\n\r\n/**\r\n * Returns the last element matching the given [predicate].\r\n * @throws [NoSuchElementException] if no such element is found.\r\n */\r\npublic inline fun ShortArray.last(predicate: (Short) -> Boolean): Short {\r\n    for (index in this.indices.reversed()) {\r\n        val element = this[index]\r\n        if (predicate(element)) return element\r\n    }\r\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\r\n}\r\n\r\n/**\r\n * Returns the last element matching the given [predicate].\r\n * @throws [NoSuchElementException] if no such element is found.\r\n */\r\npublic inline fun IntArray.last(predicate: (Int) -> Boolean): Int {\r\n    for (index in this.indices.reversed()) {\r\n        val element = this[index]\r\n        if (predicate(element)) return element\r\n    }\r\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\r\n}\r\n\r\n/**\r\n * Returns the last element matching the given [predicate].\r\n * @throws [NoSuchElementException] if no such element is found.\r\n */\r\npublic inline fun LongArray.last(predicate: (Long) -> Boolean): Long {\r\n    for (index in this.indices.reversed()) {\r\n        val element = this[index]\r\n        if (predicate(element)) return element\r\n    }\r\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\r\n}\r\n\r\n/**\r\n * Returns the last element matching the given [predicate].\r\n * @throws [NoSuchElementException] if no such element is found.\r\n */\r\npublic inline fun FloatArray.last(predicate: (Float) -> Boolean): Float {\r\n    for (index in this.indices.reversed()) {\r\n        val element = this[index]\r\n        if (predicate(element)) return element\r\n    }\r\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\r\n}\r\n\r\n/**\r\n * Returns the last element matching the given [predicate].\r\n * @throws [NoSuchElementException] if no such element is found.\r\n */\r\npublic inline fun DoubleArray.last(predicate: (Double) -> Boolean): Double {\r\n    for (index in this.indices.reversed()) {\r\n        val element = this[index]\r\n        if (predicate(element)) return element\r\n    }\r\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\r\n}\r\n\r\n/**\r\n * Returns the last element matching the given [predicate].\r\n * @throws [NoSuchElementException] if no such element is found.\r\n */\r\npublic inline fun BooleanArray.last(predicate: (Boolean) -> Boolean): Boolean {\r\n    for (index in this.indices.reversed()) {\r\n        val element = this[index]\r\n        if (predicate(element)) return element\r\n    }\r\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\r\n}\r\n\r\n/**\r\n * Returns the last element matching the given [predicate].\r\n * @throws [NoSuchElementException] if no such element is found.\r\n */\r\npublic inline fun CharArray.last(predicate: (Char) -> Boolean): Char {\r\n    for (index in this.indices.reversed()) {\r\n        val element = this[index]\r\n        if (predicate(element)) return element\r\n    }\r\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\r\n}\r\n\r\n/**\r\n * Returns last index of [element], or -1 if the array does not contain element.\r\n */\r\npublic fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.lastIndexOf(element: T): Int {\r\n    if (element == null) {\r\n        for (index in indices.reversed()) {\r\n            if (this[index] == null) {\r\n                return index\r\n            }\r\n        }\r\n    } else {\r\n        for (index in indices.reversed()) {\r\n            if (element == this[index]) {\r\n                return index\r\n            }\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns last index of [element], or -1 if the array does not contain element.\r\n */\r\npublic fun ByteArray.lastIndexOf(element: Byte): Int {\r\n    for (index in indices.reversed()) {\r\n        if (element == this[index]) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns last index of [element], or -1 if the array does not contain element.\r\n */\r\npublic fun ShortArray.lastIndexOf(element: Short): Int {\r\n    for (index in indices.reversed()) {\r\n        if (element == this[index]) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns last index of [element], or -1 if the array does not contain element.\r\n */\r\npublic fun IntArray.lastIndexOf(element: Int): Int {\r\n    for (index in indices.reversed()) {\r\n        if (element == this[index]) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns last index of [element], or -1 if the array does not contain element.\r\n */\r\npublic fun LongArray.lastIndexOf(element: Long): Int {\r\n    for (index in indices.reversed()) {\r\n        if (element == this[index]) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns last index of [element], or -1 if the array does not contain element.\r\n */\r\npublic fun FloatArray.lastIndexOf(element: Float): Int {\r\n    for (index in indices.reversed()) {\r\n        if (element == this[index]) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns last index of [element], or -1 if the array does not contain element.\r\n */\r\npublic fun DoubleArray.lastIndexOf(element: Double): Int {\r\n    for (index in indices.reversed()) {\r\n        if (element == this[index]) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns last index of [element], or -1 if the array does not contain element.\r\n */\r\npublic fun BooleanArray.lastIndexOf(element: Boolean): Int {\r\n    for (index in indices.reversed()) {\r\n        if (element == this[index]) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns last index of [element], or -1 if the array does not contain element.\r\n */\r\npublic fun CharArray.lastIndexOf(element: Char): Int {\r\n    for (index in indices.reversed()) {\r\n        if (element == this[index]) {\r\n            return index\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/**\r\n * Returns the last element, or `null` if the array is empty.\r\n */\r\npublic fun <T> Array<out T>.lastOrNull(): T? {\r\n    return if (isEmpty()) null else this[size - 1]\r\n}\r\n\r\n/**\r\n * Returns the last element, or `null` if the array is empty.\r\n */\r\npublic fun ByteArray.lastOrNull(): Byte? {\r\n    return if (isEmpty()) null else this[size - 1]\r\n}\r\n\r\n/**\r\n * Returns the last element, or `null` if the array is empty.\r\n */\r\npublic fun ShortArray.lastOrNull(): Short? {\r\n    return if (isEmpty()) null else this[size - 1]\r\n}\r\n\r\n/**\r\n * Returns the last element, or `null` if the array is empty.\r\n */\r\npublic fun IntArray.lastOrNull(): Int? {\r\n    return if (isEmpty()) null else this[size - 1]\r\n}\r\n\r\n/**\r\n * Returns the last element, or `null` if the array is empty.\r\n */\r\npublic fun LongArray.lastOrNull(): Long? {\r\n    return if (isEmpty()) null else this[size - 1]\r\n}\r\n\r\n/**\r\n * Returns the last element, or `null` if the array is empty.\r\n */\r\npublic fun FloatArray.lastOrNull(): Float? {\r\n    return if (isEmpty()) null else this[size - 1]\r\n}\r\n\r\n/**\r\n * Returns the last element, or `null` if the array is empty.\r\n */\r\npublic fun DoubleArray.lastOrNull(): Double? {\r\n    return if (isEmpty()) null else this[size - 1]\r\n}\r\n\r\n/**\r\n * Returns the last element, or `null` if the array is empty.\r\n */\r\npublic fun BooleanArray.lastOrNull(): Boolean? {\r\n    return if (isEmpty()) null else this[size - 1]\r\n}\r\n\r\n/**\r\n * Returns the last element, or `null` if the array is empty.\r\n */\r\npublic fun CharArray.lastOrNull(): Char? {\r\n    return if (isEmpty()) null else this[size - 1]\r\n}\r\n\r\n/**\r\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\r\n */\r\npublic inline fun <T> Array<out T>.lastOrNull(predicate: (T) -> Boolean): T? {\r\n    for (index in this.indices.reversed()) {\r\n        val element = this[index]\r\n        if (predicate(element)) return element\r\n    }\r\n    return null\r\n}\r\n\r\n/**\r\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\r\n */\r\npublic inline fun ByteArray.lastOrNull(predicate: (Byte) -> Boolean): Byte? {\r\n    for (index in this.indices.reversed()) {\r\n        val element = this[index]\r\n        if (predicate(element)) return element\r\n    }\r\n    return null\r\n}\r\n\r\n/**\r\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\r\n */\r\npublic inline fun ShortArray.lastOrNull(predicate: (Short) -> Boolean): Short? {\r\n    for (index in this.indices.reversed()) {\r\n        val element = this[index]\r\n        if (predicate(element)) return element\r\n    }\r\n    return null\r\n}\r\n\r\n/**\r\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\r\n */\r\npublic inline fun IntArray.lastOrNull(predicate: (Int) -> Boolean): Int? {\r\n    for (index in this.indices.reversed()) {\r\n        val element = this[index]\r\n        if (predicate(element)) return element\r\n    }\r\n    return null\r\n}\r\n\r\n/**\r\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\r\n */\r\npublic inline fun LongArray.lastOrNull(predicate: (Long) -> Boolean): Long? {\r\n    for (index in this.indices.reversed()) {\r\n        val element = this[index]\r\n        if (predicate(element)) return element\r\n    }\r\n    return null\r\n}\r\n\r\n/**\r\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\r\n */\r\npublic inline fun FloatArray.lastOrNull(predicate: (Float) -> Boolean): Float? {\r\n    for (index in this.indices.reversed()) {\r\n        val element = this[index]\r\n        if (predicate(element)) return element\r\n    }\r\n    return null\r\n}\r\n\r\n/**\r\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\r\n */\r\npublic inline fun DoubleArray.lastOrNull(predicate: (Double) -> Boolean): Double? {\r\n    for (index in this.indices.reversed()) {\r\n        val element = this[index]\r\n        if (predicate(element)) return element\r\n    }\r\n    return null\r\n}\r\n\r\n/**\r\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\r\n */\r\npublic inline fun BooleanArray.lastOrNull(predicate: (Boolean) -> Boolean): Boolean? {\r\n    for (index in this.indices.reversed()) {\r\n        val element = this[index]\r\n        if (predicate(element)) return element\r\n    }\r\n    return null\r\n}\r\n\r\n/**\r\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\r\n */\r\npublic inline fun CharArray.lastOrNull(predicate: (Char) -> Boolean): Char? {\r\n    for (index in this.indices.reversed()) {\r\n        val element = this[index]\r\n        if (predicate(element)) return element\r\n    }\r\n    return null\r\n}\r\n\r\n/**\r\n * Returns a random element from this array.\r\n * \r\n * @throws NoSuchElementException if this array is empty.\r\n */\r\n@SinceKotlin(\"1.3\")\r\n@kotlin.internal.InlineOnly\r\npublic inline fun <T> Array<out T>.random(): T {\r\n    return random(Random)\r\n}\r\n\r\n/**\r\n * Returns a random element from this array.\r\n * \r\n * @throws NoSuchElementException if this array is empty.\r\n */\r\n@SinceKotlin(\"1.3\")\r\n@kotlin.internal.InlineOnly\r\npublic inline fun ByteArray.random(): Byte {\r\n    return random(Random)\r\n}\r\n\r\n/**\r\n * Returns a random element from this array.\r\n * \r\n * @throws NoSuchElementException if this array is empty.\r\n */\r\n@SinceKotlin(\"1.3\")\r\n@kotlin.internal.InlineOnly\r\npublic inline fun ShortArray.random(): Short {\r\n    return random(Random)\r\n}\r\n\r\n/**\r\n * Returns a random element from this array.\r\n * \r\n * @throws NoSuchElementException if this array is empty.\r\n */\r\n@SinceKotlin(\"1.3\")\r\n@kotlin.internal.InlineOnly\r\npublic inline fun IntArray.random(): Int {\r\n    return random(Random)\r\n}\r\n\r\n/**\r\n * Returns a random element from this array.\r\n * \r\n * @throws NoSuchElementException if this array is empty.\r\n */\r\n@SinceKotlin(\"1.3\")\r\n@kotlin.internal.InlineOnly\r\npublic inline fun LongArray.random(): Long {\r\n    return random(Random)\r\n}\r\n\r\n/**\r\n * Returns a random element from this array.\r\n * \r\n * @throws NoSuchElementException if this array is empty.\r\n */\r\n@SinceKotlin(\"1.3\")\r\n@kotlin.internal.InlineOnly\r\npublic inline fun FloatArray.random(): Float {\r\n    return random(Random)\r\n}\r\n\r\n/**\r\n * Returns a random element from this array.\r\n * \r\n * @throws NoSuchElementException if this array is empty.\r\n */\r\n@SinceKotlin(\"1.3\")\r\n@kotlin.internal.InlineOnly\r\npublic inline fun DoubleArray.random(): Double {\r\n    return random(Random)\r\n}\r\n\r\n/**\r\n * Returns a random element from this array.\r\n * \r\n * @throws NoSuchElementException if this array is empty.\r\n */\r\n@SinceKotlin(\"1.3\")\r\n@kotlin.internal.InlineOnly\r\npublic inline fun BooleanArray.random(): Boolean {\r\n    return random(Random)\r\n}\r\n\r\n/**\r\n * Returns a random element from this array.\r\n * \r\n * @throws NoSuchElementException if this array is empty.\r\n */\r\n@SinceKotlin(\"1.3\")\r\n@kotlin.internal.InlineOnly\r\npublic inline fun CharArray.random(): Char {\r\n    return random(Random)\r\n}\r\n\r\n/**\r\n * Returns a random element from this array using the specified source of randomness.\r\n * \r\n * @throws NoSuchElementException if this array is empty.\r\n */\r\n@SinceKotlin(\"1.3\")\r\npublic fun <T> Array<out T>.random(random: Random): T {\r\n    if (isEmpty())\r\n        throw NoSuchElementException(\"Array is empty.\")\r\n    return get(random.nextInt(size))\r\n}\r\n\r\n/**\r\n * Returns a random element from this array using the specified source of randomness.\r\n * \r\n * @throws NoSuchElementException if this array is empty.\r\n */\r\n@SinceKotlin(\"1.3\")\r\npublic fun ByteArray.random(random: Random): Byte {\r\n    if (isEmpty())\r\n        throw NoSuchElementException(\"Array is empty.\")\r\n    return get(random.nextInt(size))\r\n}\r\n\r\n/**\r\n * Returns a random element from this array using the specified source of randomness.\r\n * \r\n * @throws NoSuchElementException if this array is empty.\r\n */\r\n@SinceKotlin(\"1.3\")\r\npublic fun ShortArray.random(random: Random): Short {\r\n    if (isEmpty())\r\n        throw NoSuchElementException(\"Array is empty.\")\r\n    return get(random.nextInt(size))\r\n}\r\n\r\n/**\r\n * Returns a random element from this array using the specified source of randomness.\r\n * \r\n * @throws NoSuchElementException if this array is empty.\r\n */\r\n@SinceKotlin(\"1.3\")\r\npublic fun IntArray.random(random: Random): Int {\r\n    if (isEmpty())\r\n        throw NoSuchElementException(\"Array is empty.\")\r\n    return get(random.nextInt(size))\r\n}\r\n\r\n/**\r\n * Returns a random element from this array using the specified source of randomness.\r\n * \r\n * @throws NoSuchElementException if this array is empty.\r\n */\r\n@SinceKotlin(\"1.3\")\r\npublic fun LongArray.random(random: Random): Long {\r\n    if (isEmpty())\r\n        throw NoSuchElementException(\"Array is empty.\")\r\n    return get(random.nextInt(size))\r\n}\r\n\r\n/**\r\n * Returns a random element from this array using the specified source of randomness.\r\n * \r\n * @throws NoSuchElementException if this array is empty.\r\n */\r\n@SinceKotlin(\"1.3\")\r\npublic fun FloatArray.random(random: Random): Float {\r\n    if (isEmpty())\r\n        throw NoSuchElementException(\"Array is empty.\")\r\n    return get(random.nextInt(size))\r\n}\r\n\r\n/**\r\n * Returns a random element from this array using the specified source of randomness.\r\n * \r\n * @throws NoSuchElementException if this array is empty.\r\n */\r\n@SinceKotlin(\"1.3\")\r\npublic fun DoubleArray.random(random: Random): Double {\r\n    if (isEmpty())\r\n        throw NoSuchElementException(\"Array is empty.\")\r\n    return get(random.nextInt(size))\r\n}\r\n\r\n/**\r\n * Returns a random element from this array using the specified source of randomness.\r\n * \r\n * @throws NoSuchElementException if this array is empty.\r\n */\r\n@SinceKotlin(\"1.3\")\r\npublic fun BooleanArray.random(random: Random): Boolean {\r\n    if (isEmpty())\r\n        throw NoSuchElementException(\"Array is empty.\")\r\n    return get(random.nextInt(size))\r\n}\r\n\r\n/**\r\n * Returns a random element from this array using the specified source of randomness.\r\n * \r\n * @throws NoSuchElementException if this array is empty.\r\n */\r\n@SinceKotlin(\"1.3\")\r\npublic fun CharArray.random(random: Random): Char {\r\n    if (isEmpty())\r\n        throw NoSuchElementException(\"Array is empty.\")\r\n    return get(random.nextInt(size))\r\n}\r\n\r\n/**\r\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\r\n */\r\npublic fun <T> Array<out T>.single(): T {\r\n    return when (size) {\r\n        0 -> throw NoSuchElementException(\"Array is empty.\")\r\n        1 -> this[0]\r\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\r\n    }\r\n}\r\n\r\n/**\r\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\r\n */\r\npublic fun ByteArray.single(): Byte {\r\n    return when (size) {\r\n        0 -> throw NoSuchElementException(\"Array is empty.\")\r\n        1 -> this[0]\r\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\r\n    }\r\n}\r\n\r\n/**\r\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\r\n */\r\npublic fun ShortArray.single(): Short {\r\n    return when (size) {\r\n        0 -> throw NoSuchElementException(\"Array is empty.\")\r\n        1 -> this[0]\r\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\r\n    }\r\n}\r\n\r\n/**\r\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\r\n */\r\npublic fun IntArray.single(): Int {\r\n    return when (size) {\r\n        0 -> throw NoSuchElementException(\"Array is empty.\")\r\n        1 -> this[0]\r\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\r\n    }\r\n}\r\n\r\n/**\r\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\r\n */\r\npublic fun LongArray.single(): Long {\r\n    return when (size) {\r\n        0 -> throw NoSuchElementException(\"Array is empty.\")\r\n        1 -> this[0]\r\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\r\n    }\r\n}\r\n\r\n/**\r\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\r\n */\r\npublic fun FloatArray.single(): Float {\r\n    return when (size) {\r\n        0 -> throw NoSuchElementException(\"Array is empty.\")\r\n        1 -> this[0]\r\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\r\n    }\r\n}\r\n\r\n/**\r\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\r\n */\r\npublic fun DoubleArray.single(): Double {\r\n    return when (size) {\r\n        0 -> throw NoSuchElementException(\"Array is empty.\")\r\n        1 -> this[0]\r\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\r\n    }\r\n}\r\n\r\n/**\r\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\r\n */\r\npublic fun BooleanArray.single(): Boolean {\r\n    return when (size) {\r\n        0 -> throw NoSuchElementException(\"Array is empty.\")\r\n        1 -> this[0]\r\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\r\n    }\r\n}\r\n\r\n/**\r\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\r\n */\r\npublic fun CharArray.single(): Char {\r\n    return when (size) {\r\n        0 -> throw NoSuchElementException(\"Array is empty.\")\r\n        1 -> this[0]\r\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\r\n    }\r\n}\r\n\r\n/**\r\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\r\n */\r\npublic inline fun <T> Array<out T>.single(predicate: (T) -> Boolean): T {\r\n    var single: T? = null\r\n    var found = false\r\n    for (element in this) {\r\n        if (predicate(element)) {\r\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\r\n            single = element\r\n            found = true\r\n        }\r\n    }\r\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\r\n    @Suppress(\"UNCHECKED_CAST\")\r\n    return single as T\r\n}\r\n\r\n/**\r\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\r\n */\r\npublic inline fun ByteArray.single(predicate: (Byte) -> Boolean): Byte {\r\n    var single: Byte? = null\r\n    var found = false\r\n    for (element in this) {\r\n        if (predicate(element)) {\r\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\r\n            single = element\r\n            found = true\r\n        }\r\n    }\r\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\r\n    @Suppress(\"UNCHECKED_CAST\")\r\n    return single as Byte\r\n}\r\n\r\n/**\r\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\r\n */\r\npublic inline fun ShortArray.single(predicate: (Short) -> Boolean): Short {\r\n    var single: Short? = null\r\n    var found = false\r\n    for (element in this) {\r\n        if (predicate(element)) {\r\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\r\n            single = element\r\n            found = true\r\n        }\r\n    }\r\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\r\n    @Suppress(\"UNCHECKED_CAST\")\r\n    return single as Short\r\n}\r\n\r\n/**\r\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\r\n */\r\npublic inline fun IntArray.single(predicate: (Int) -> Boolean): Int {\r\n    var single: Int? = null\r\n    var found = false\r\n    for (element in this) {\r\n        if (predicate(element)) {\r\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\r\n            single = element\r\n            found = true\r\n        }\r\n    }\r\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\r\n    @Suppress(\"UNCHECKED_CAST\")\r\n    return single as Int\r\n}\r\n\r\n/**\r\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\r\n */\r\npublic inline fun LongArray.single(predicate: (Long) -> Boolean): Long {\r\n    var single: Long? = null\r\n    var found = false\r\n    for (element in this) {\r\n        if (predicate(element)) {\r\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\r\n            single = element\r\n            found = true\r\n        }\r\n    }\r\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\r\n    @Suppress(\"UNCHECKED_CAST\")\r\n    return single as Long\r\n}\r\n\r\n/**\r\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\r\n */\r\npublic inline fun FloatArray.single(predicate: (Float) -> Boolean): Float {\r\n    var single: Float? = null\r\n    var found = false\r\n    for (element in this) {\r\n        if (predicate(element)) {\r\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\r\n            single = element\r\n            found = true\r\n        }\r\n    }\r\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\r\n    @Suppress(\"UNCHECKED_CAST\")\r\n    return single as Float\r\n}\r\n\r\n/**\r\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\r\n */\r\npublic inline fun DoubleArray.single(predicate: (Double) -> Boolean): Double {\r\n    var single: Double? = null\r\n    var found = false\r\n    for (element in this) {\r\n        if (predicate(element)) {\r\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\r\n            single = element\r\n            found = true\r\n        }\r\n    }\r\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\r\n    @Suppress(\"UNCHECKED_CAST\")\r\n    return single as Double\r\n}\r\n\r\n/**\r\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\r\n */\r\npublic inline fun BooleanArray.single(predicate: (Boolean) -> Boolean): Boolean {\r\n    var single: Boolean? = null\r\n    var found = false\r\n    for (element in this) {\r\n        if (predicate(element)) {\r\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\r\n            single = element\r\n            found = true\r\n        }\r\n    }\r\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\r\n    @Suppress(\"UNCHECKED_CAST\")\r\n    return single as Boolean\r\n}\r\n\r\n/**\r\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\r\n */\r\npublic inline fun CharArray.single(predicate: (Char) -> Boolean): Char {\r\n    var single: Char? = null\r\n    var found = false\r\n    for (element in this) {\r\n        if (predicate(element)) {\r\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\r\n            single = element\r\n            found = true\r\n        }\r\n    }\r\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\r\n    @Suppress(\"UNCHECKED_CAST\")\r\n    return single as Char\r\n}\r\n\r\n/**\r\n * Returns single element, or `null` if the array is empty or has more than one element.\r\n */\r\npublic fun <T> Array<out T>.singleOrNull(): T? {\r\n    return if (size == 1) this[0] else null\r\n}\r\n\r\n/**\r\n * Returns single element, or `null` if the array is empty or has more than one element.\r\n */\r\npublic fun ByteArray.singleOrNull(): Byte? {\r\n    return if (size == 1) this[0] else null\r\n}\r\n\r\n/**\r\n * Returns single element, or `null` if the array is empty or has more than one element.\r\n */\r\npublic fun ShortArray.singleOrNull(): Short? {\r\n    return if (size == 1) this[0] else null\r\n}\r\n\r\n/**\r\n * Returns single element, or `null` if the array is empty or has more than one element.\r\n */\r\npublic fun IntArray.singleOrNull(): Int? {\r\n    return if (size == 1) this[0] else null\r\n}\r\n\r\n/**\r\n * Returns single element, or `null` if the array is empty or has more than one element.\r\n */\r\npublic fun LongArray.singleOrNull(): Long? {\r\n    return if (size == 1) this[0] else null\r\n}\r\n\r\n/**\r\n * Returns single element, or `null` if the array is empty or has more than one element.\r\n */\r\npublic fun FloatArray.singleOrNull(): Float? {\r\n    return if (size == 1) this[0] else null\r\n}\r\n\r\n/**\r\n * Returns single element, or `null` if the array is empty or has more than one element.\r\n */\r\npublic fun DoubleArray.singleOrNull(): Double? {\r\n    return if (size == 1) this[0] else null\r\n}\r\n\r\n/**\r\n * Returns single element, or `null` if the array is empty or has more than one element.\r\n */\r\npublic fun BooleanArray.singleOrNull(): Boolean? {\r\n    return if (size == 1) this[0] else null\r\n}\r\n\r\n/**\r\n * Returns single element, or `null` if the array is empty or has more than one element.\r\n */\r\npublic fun CharArray.singleOrNull(): Char? {\r\n    return if (size == 1) this[0] else null\r\n}\r\n\r\n/**\r\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\r\n */\r\npublic inline fun <T> Array<out T>.singleOrNull(predicate: (T) -> Boolean): T? {\r\n    var single: T? = null\r\n    var found = false\r\n    for (element in this) {\r\n        if (predicate(element)) {\r\n            if (found) return null\r\n            single = element\r\n            found = true\r\n        }\r\n    }\r\n    if (!found) return null\r\n    return single\r\n}\r\n\r\n/**\r\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\r\n */\r\npublic inline fun ByteArray.singleOrNull(predicate: (Byte) -> Boolean): Byte? {\r\n    var single: Byte? = null\r\n    var found = false\r\n    for (element in this) {\r\n        if (predicate(element)) {\r\n            if (found) return null\r\n            single = element\r\n            found = true\r\n        }\r\n    }\r\n    if (!found) return null\r\n    return single\r\n}\r\n\r\n/**\r\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\r\n */\r\npublic inline fun ShortArray.singleOrNull(predicate: (Short) -> Boolean): Short? {\r\n    var single: Short? = null\r\n    var found = false\r\n    for (element in this) {\r\n        if (predicate(element)) {\r\n            if (found) return null\r\n            single = element\r\n            found = true\r\n        }\r\n    }\r\n    if (!found) return null\r\n    return single\r\n}\r\n\r\n/**\r\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\r\n */\r\npublic inline fun IntArray.singleOrNull(predicate: (Int) -> Boolean): Int? {\r\n    var single: Int? = null\r\n    var found = false\r\n    for (element in this) {\r\n        if (predicate(element)) {\r\n            if (found) return null\r\n            single = element\r\n            found = true\r\n        }\r\n    }\r\n    if (!found) return null\r\n    return single\r\n}\r\n\r\n/**\r\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\r\n */\r\npublic inline fun LongArray.singleOrNull(predicate: (Long) -> Boolean): Long? {\r\n    var single: Long? = null\r\n    var found = false\r\n    for (element in this) {\r\n        if (predicate(element)) {\r\n            if (found) return null\r\n            single = element\r\n            found = true\r\n        }\r\n    }\r\n    if (!found) return null\r\n    return single\r\n}\r\n\r\n/**\r\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\r\n */\r\npublic inline fun FloatArray.singleOrNull(predicate: (Float) -> Boolean): Float? {\r\n    var single: Float? = null\r\n    var found = false\r\n    for (element in this) {\r\n        if (predicate(element)) {\r\n            if (found) return null\r\n            single = element\r\n            found = true\r\n        }\r\n    }\r\n    if (!found) return null\r\n    return single\r\n}\r\n\r\n/**\r\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\r\n */\r\npublic inline fun DoubleArray.singleOrNull(predicate: (Double) -> Boolean): Double? {\r\n    var single: Double? = null\r\n    var found = false\r\n    for (element in this) {\r\n        if (predicate(element)) {\r\n            if (found) return null\r\n            single = element\r\n            found = true\r\n        }\r\n    }\r\n    if (!found) return null\r\n    return single\r\n}\r\n\r\n/**\r\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\r\n */\r\npublic inline fun BooleanArray.singleOrNull(predicate: (Boolean) -> Boolean): Boolean? {\r\n    var single: Boolean? = null\r\n    var found = false\r\n    for (element in this) {\r\n        if (predicate(element)) {\r\n            if (found) return null\r\n            single = element\r\n            found = true\r\n        }\r\n    }\r\n    if (!found) return null\r\n    return single\r\n}\r\n\r\n/**\r\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\r\n */\r\npublic inline fun CharArray.singleOrNull(predicate: (Char) -> Boolean): Char? {\r\n    var single: Char? = null\r\n    var found = false\r\n    for (element in this) {\r\n        if (predicate(element)) {\r\n            if (found) return null\r\n            single = element\r\n            found = true\r\n        }\r\n    }\r\n    if (!found) return null\r\n    return single\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except first [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic fun <T> Array<out T>.drop(n: Int): List<T> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    return takeLast((size - n).coerceAtLeast(0))\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except first [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic fun ByteArray.drop(n: Int): List<Byte> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    return takeLast((size - n).coerceAtLeast(0))\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except first [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic fun ShortArray.drop(n: Int): List<Short> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    return takeLast((size - n).coerceAtLeast(0))\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except first [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic fun IntArray.drop(n: Int): List<Int> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    return takeLast((size - n).coerceAtLeast(0))\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except first [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic fun LongArray.drop(n: Int): List<Long> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    return takeLast((size - n).coerceAtLeast(0))\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except first [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic fun FloatArray.drop(n: Int): List<Float> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    return takeLast((size - n).coerceAtLeast(0))\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except first [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic fun DoubleArray.drop(n: Int): List<Double> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    return takeLast((size - n).coerceAtLeast(0))\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except first [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic fun BooleanArray.drop(n: Int): List<Boolean> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    return takeLast((size - n).coerceAtLeast(0))\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except first [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic fun CharArray.drop(n: Int): List<Char> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    return takeLast((size - n).coerceAtLeast(0))\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except last [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic fun <T> Array<out T>.dropLast(n: Int): List<T> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    return take((size - n).coerceAtLeast(0))\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except last [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic fun ByteArray.dropLast(n: Int): List<Byte> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    return take((size - n).coerceAtLeast(0))\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except last [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic fun ShortArray.dropLast(n: Int): List<Short> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    return take((size - n).coerceAtLeast(0))\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except last [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic fun IntArray.dropLast(n: Int): List<Int> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    return take((size - n).coerceAtLeast(0))\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except last [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic fun LongArray.dropLast(n: Int): List<Long> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    return take((size - n).coerceAtLeast(0))\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except last [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic fun FloatArray.dropLast(n: Int): List<Float> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    return take((size - n).coerceAtLeast(0))\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except last [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic fun DoubleArray.dropLast(n: Int): List<Double> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    return take((size - n).coerceAtLeast(0))\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except last [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic fun BooleanArray.dropLast(n: Int): List<Boolean> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    return take((size - n).coerceAtLeast(0))\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except last [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic fun CharArray.dropLast(n: Int): List<Char> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    return take((size - n).coerceAtLeast(0))\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic inline fun <T> Array<out T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\r\n    for (index in lastIndex downTo 0) {\r\n        if (!predicate(this[index])) {\r\n            return take(index + 1)\r\n        }\r\n    }\r\n    return emptyList()\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic inline fun ByteArray.dropLastWhile(predicate: (Byte) -> Boolean): List<Byte> {\r\n    for (index in lastIndex downTo 0) {\r\n        if (!predicate(this[index])) {\r\n            return take(index + 1)\r\n        }\r\n    }\r\n    return emptyList()\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic inline fun ShortArray.dropLastWhile(predicate: (Short) -> Boolean): List<Short> {\r\n    for (index in lastIndex downTo 0) {\r\n        if (!predicate(this[index])) {\r\n            return take(index + 1)\r\n        }\r\n    }\r\n    return emptyList()\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic inline fun IntArray.dropLastWhile(predicate: (Int) -> Boolean): List<Int> {\r\n    for (index in lastIndex downTo 0) {\r\n        if (!predicate(this[index])) {\r\n            return take(index + 1)\r\n        }\r\n    }\r\n    return emptyList()\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic inline fun LongArray.dropLastWhile(predicate: (Long) -> Boolean): List<Long> {\r\n    for (index in lastIndex downTo 0) {\r\n        if (!predicate(this[index])) {\r\n            return take(index + 1)\r\n        }\r\n    }\r\n    return emptyList()\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic inline fun FloatArray.dropLastWhile(predicate: (Float) -> Boolean): List<Float> {\r\n    for (index in lastIndex downTo 0) {\r\n        if (!predicate(this[index])) {\r\n            return take(index + 1)\r\n        }\r\n    }\r\n    return emptyList()\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic inline fun DoubleArray.dropLastWhile(predicate: (Double) -> Boolean): List<Double> {\r\n    for (index in lastIndex downTo 0) {\r\n        if (!predicate(this[index])) {\r\n            return take(index + 1)\r\n        }\r\n    }\r\n    return emptyList()\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic inline fun BooleanArray.dropLastWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\r\n    for (index in lastIndex downTo 0) {\r\n        if (!predicate(this[index])) {\r\n            return take(index + 1)\r\n        }\r\n    }\r\n    return emptyList()\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic inline fun CharArray.dropLastWhile(predicate: (Char) -> Boolean): List<Char> {\r\n    for (index in lastIndex downTo 0) {\r\n        if (!predicate(this[index])) {\r\n            return take(index + 1)\r\n        }\r\n    }\r\n    return emptyList()\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic inline fun <T> Array<out T>.dropWhile(predicate: (T) -> Boolean): List<T> {\r\n    var yielding = false\r\n    val list = ArrayList<T>()\r\n    for (item in this)\r\n        if (yielding)\r\n            list.add(item)\r\n        else if (!predicate(item)) {\r\n            list.add(item)\r\n            yielding = true\r\n        }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic inline fun ByteArray.dropWhile(predicate: (Byte) -> Boolean): List<Byte> {\r\n    var yielding = false\r\n    val list = ArrayList<Byte>()\r\n    for (item in this)\r\n        if (yielding)\r\n            list.add(item)\r\n        else if (!predicate(item)) {\r\n            list.add(item)\r\n            yielding = true\r\n        }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic inline fun ShortArray.dropWhile(predicate: (Short) -> Boolean): List<Short> {\r\n    var yielding = false\r\n    val list = ArrayList<Short>()\r\n    for (item in this)\r\n        if (yielding)\r\n            list.add(item)\r\n        else if (!predicate(item)) {\r\n            list.add(item)\r\n            yielding = true\r\n        }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic inline fun IntArray.dropWhile(predicate: (Int) -> Boolean): List<Int> {\r\n    var yielding = false\r\n    val list = ArrayList<Int>()\r\n    for (item in this)\r\n        if (yielding)\r\n            list.add(item)\r\n        else if (!predicate(item)) {\r\n            list.add(item)\r\n            yielding = true\r\n        }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic inline fun LongArray.dropWhile(predicate: (Long) -> Boolean): List<Long> {\r\n    var yielding = false\r\n    val list = ArrayList<Long>()\r\n    for (item in this)\r\n        if (yielding)\r\n            list.add(item)\r\n        else if (!predicate(item)) {\r\n            list.add(item)\r\n            yielding = true\r\n        }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic inline fun FloatArray.dropWhile(predicate: (Float) -> Boolean): List<Float> {\r\n    var yielding = false\r\n    val list = ArrayList<Float>()\r\n    for (item in this)\r\n        if (yielding)\r\n            list.add(item)\r\n        else if (!predicate(item)) {\r\n            list.add(item)\r\n            yielding = true\r\n        }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic inline fun DoubleArray.dropWhile(predicate: (Double) -> Boolean): List<Double> {\r\n    var yielding = false\r\n    val list = ArrayList<Double>()\r\n    for (item in this)\r\n        if (yielding)\r\n            list.add(item)\r\n        else if (!predicate(item)) {\r\n            list.add(item)\r\n            yielding = true\r\n        }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic inline fun BooleanArray.dropWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\r\n    var yielding = false\r\n    val list = ArrayList<Boolean>()\r\n    for (item in this)\r\n        if (yielding)\r\n            list.add(item)\r\n        else if (!predicate(item)) {\r\n            list.add(item)\r\n            yielding = true\r\n        }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.drop\r\n */\r\npublic inline fun CharArray.dropWhile(predicate: (Char) -> Boolean): List<Char> {\r\n    var yielding = false\r\n    val list = ArrayList<Char>()\r\n    for (item in this)\r\n        if (yielding)\r\n            list.add(item)\r\n        else if (!predicate(item)) {\r\n            list.add(item)\r\n            yielding = true\r\n        }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing only elements matching the given [predicate].\r\n */\r\npublic inline fun <T> Array<out T>.filter(predicate: (T) -> Boolean): List<T> {\r\n    return filterTo(ArrayList<T>(), predicate)\r\n}\r\n\r\n/**\r\n * Returns a list containing only elements matching the given [predicate].\r\n */\r\npublic inline fun ByteArray.filter(predicate: (Byte) -> Boolean): List<Byte> {\r\n    return filterTo(ArrayList<Byte>(), predicate)\r\n}\r\n\r\n/**\r\n * Returns a list containing only elements matching the given [predicate].\r\n */\r\npublic inline fun ShortArray.filter(predicate: (Short) -> Boolean): List<Short> {\r\n    return filterTo(ArrayList<Short>(), predicate)\r\n}\r\n\r\n/**\r\n * Returns a list containing only elements matching the given [predicate].\r\n */\r\npublic inline fun IntArray.filter(predicate: (Int) -> Boolean): List<Int> {\r\n    return filterTo(ArrayList<Int>(), predicate)\r\n}\r\n\r\n/**\r\n * Returns a list containing only elements matching the given [predicate].\r\n */\r\npublic inline fun LongArray.filter(predicate: (Long) -> Boolean): List<Long> {\r\n    return filterTo(ArrayList<Long>(), predicate)\r\n}\r\n\r\n/**\r\n * Returns a list containing only elements matching the given [predicate].\r\n */\r\npublic inline fun FloatArray.filter(predicate: (Float) -> Boolean): List<Float> {\r\n    return filterTo(ArrayList<Float>(), predicate)\r\n}\r\n\r\n/**\r\n * Returns a list containing only elements matching the given [predicate].\r\n */\r\npublic inline fun DoubleArray.filter(predicate: (Double) -> Boolean): List<Double> {\r\n    return filterTo(ArrayList<Double>(), predicate)\r\n}\r\n\r\n/**\r\n * Returns a list containing only elements matching the given [predicate].\r\n */\r\npublic inline fun BooleanArray.filter(predicate: (Boolean) -> Boolean): List<Boolean> {\r\n    return filterTo(ArrayList<Boolean>(), predicate)\r\n}\r\n\r\n/**\r\n * Returns a list containing only elements matching the given [predicate].\r\n */\r\npublic inline fun CharArray.filter(predicate: (Char) -> Boolean): List<Char> {\r\n    return filterTo(ArrayList<Char>(), predicate)\r\n}\r\n\r\n/**\r\n * Returns a list containing only elements matching the given [predicate].\r\n * @param [predicate] function that takes the index of an element and the element itself\r\n * and returns the result of predicate evaluation on the element.\r\n */\r\npublic inline fun <T> Array<out T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\r\n    return filterIndexedTo(ArrayList<T>(), predicate)\r\n}\r\n\r\n/**\r\n * Returns a list containing only elements matching the given [predicate].\r\n * @param [predicate] function that takes the index of an element and the element itself\r\n * and returns the result of predicate evaluation on the element.\r\n */\r\npublic inline fun ByteArray.filterIndexed(predicate: (index: Int, Byte) -> Boolean): List<Byte> {\r\n    return filterIndexedTo(ArrayList<Byte>(), predicate)\r\n}\r\n\r\n/**\r\n * Returns a list containing only elements matching the given [predicate].\r\n * @param [predicate] function that takes the index of an element and the element itself\r\n * and returns the result of predicate evaluation on the element.\r\n */\r\npublic inline fun ShortArray.filterIndexed(predicate: (index: Int, Short) -> Boolean): List<Short> {\r\n    return filterIndexedTo(ArrayList<Short>(), predicate)\r\n}\r\n\r\n/**\r\n * Returns a list containing only elements matching the given [predicate].\r\n * @param [predicate] function that takes the index of an element and the element itself\r\n * and returns the result of predicate evaluation on the element.\r\n */\r\npublic inline fun IntArray.filterIndexed(predicate: (index: Int, Int) -> Boolean): List<Int> {\r\n    return filterIndexedTo(ArrayList<Int>(), predicate)\r\n}\r\n\r\n/**\r\n * Returns a list containing only elements matching the given [predicate].\r\n * @param [predicate] function that takes the index of an element and the element itself\r\n * and returns the result of predicate evaluation on the element.\r\n */\r\npublic inline fun LongArray.filterIndexed(predicate: (index: Int, Long) -> Boolean): List<Long> {\r\n    return filterIndexedTo(ArrayList<Long>(), predicate)\r\n}\r\n\r\n/**\r\n * Returns a list containing only elements matching the given [predicate].\r\n * @param [predicate] function that takes the index of an element and the element itself\r\n * and returns the result of predicate evaluation on the element.\r\n */\r\npublic inline fun FloatArray.filterIndexed(predicate: (index: Int, Float) -> Boolean): List<Float> {\r\n    return filterIndexedTo(ArrayList<Float>(), predicate)\r\n}\r\n\r\n/**\r\n * Returns a list containing only elements matching the given [predicate].\r\n * @param [predicate] function that takes the index of an element and the element itself\r\n * and returns the result of predicate evaluation on the element.\r\n */\r\npublic inline fun DoubleArray.filterIndexed(predicate: (index: Int, Double) -> Boolean): List<Double> {\r\n    return filterIndexedTo(ArrayList<Double>(), predicate)\r\n}\r\n\r\n/**\r\n * Returns a list containing only elements matching the given [predicate].\r\n * @param [predicate] function that takes the index of an element and the element itself\r\n * and returns the result of predicate evaluation on the element.\r\n */\r\npublic inline fun BooleanArray.filterIndexed(predicate: (index: Int, Boolean) -> Boolean): List<Boolean> {\r\n    return filterIndexedTo(ArrayList<Boolean>(), predicate)\r\n}\r\n\r\n/**\r\n * Returns a list containing only elements matching the given [predicate].\r\n * @param [predicate] function that takes the index of an element and the element itself\r\n * and returns the result of predicate evaluation on the element.\r\n */\r\npublic inline fun CharArray.filterIndexed(predicate: (index: Int, Char) -> Boolean): List<Char> {\r\n    return filterIndexedTo(ArrayList<Char>(), predicate)\r\n}\r\n\r\n/**\r\n * Appends all elements matching the given [predicate] to the given [destination].\r\n * @param [predicate] function that takes the index of an element and the element itself\r\n * and returns the result of predicate evaluation on the element.\r\n */\r\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\r\n    forEachIndexed { index, element ->\r\n        if (predicate(index, element)) destination.add(element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements matching the given [predicate] to the given [destination].\r\n * @param [predicate] function that takes the index of an element and the element itself\r\n * and returns the result of predicate evaluation on the element.\r\n */\r\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterIndexedTo(destination: C, predicate: (index: Int, Byte) -> Boolean): C {\r\n    forEachIndexed { index, element ->\r\n        if (predicate(index, element)) destination.add(element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements matching the given [predicate] to the given [destination].\r\n * @param [predicate] function that takes the index of an element and the element itself\r\n * and returns the result of predicate evaluation on the element.\r\n */\r\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterIndexedTo(destination: C, predicate: (index: Int, Short) -> Boolean): C {\r\n    forEachIndexed { index, element ->\r\n        if (predicate(index, element)) destination.add(element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements matching the given [predicate] to the given [destination].\r\n * @param [predicate] function that takes the index of an element and the element itself\r\n * and returns the result of predicate evaluation on the element.\r\n */\r\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterIndexedTo(destination: C, predicate: (index: Int, Int) -> Boolean): C {\r\n    forEachIndexed { index, element ->\r\n        if (predicate(index, element)) destination.add(element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements matching the given [predicate] to the given [destination].\r\n * @param [predicate] function that takes the index of an element and the element itself\r\n * and returns the result of predicate evaluation on the element.\r\n */\r\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterIndexedTo(destination: C, predicate: (index: Int, Long) -> Boolean): C {\r\n    forEachIndexed { index, element ->\r\n        if (predicate(index, element)) destination.add(element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements matching the given [predicate] to the given [destination].\r\n * @param [predicate] function that takes the index of an element and the element itself\r\n * and returns the result of predicate evaluation on the element.\r\n */\r\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterIndexedTo(destination: C, predicate: (index: Int, Float) -> Boolean): C {\r\n    forEachIndexed { index, element ->\r\n        if (predicate(index, element)) destination.add(element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements matching the given [predicate] to the given [destination].\r\n * @param [predicate] function that takes the index of an element and the element itself\r\n * and returns the result of predicate evaluation on the element.\r\n */\r\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterIndexedTo(destination: C, predicate: (index: Int, Double) -> Boolean): C {\r\n    forEachIndexed { index, element ->\r\n        if (predicate(index, element)) destination.add(element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements matching the given [predicate] to the given [destination].\r\n * @param [predicate] function that takes the index of an element and the element itself\r\n * and returns the result of predicate evaluation on the element.\r\n */\r\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterIndexedTo(destination: C, predicate: (index: Int, Boolean) -> Boolean): C {\r\n    forEachIndexed { index, element ->\r\n        if (predicate(index, element)) destination.add(element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements matching the given [predicate] to the given [destination].\r\n * @param [predicate] function that takes the index of an element and the element itself\r\n * and returns the result of predicate evaluation on the element.\r\n */\r\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterIndexedTo(destination: C, predicate: (index: Int, Char) -> Boolean): C {\r\n    forEachIndexed { index, element ->\r\n        if (predicate(index, element)) destination.add(element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements that are instances of specified type parameter R.\r\n */\r\npublic inline fun <reified R> Array<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\r\n    return filterIsInstanceTo(ArrayList<R>())\r\n}\r\n\r\n/**\r\n * Appends all elements that are instances of specified type parameter R to the given [destination].\r\n */\r\npublic inline fun <reified R, C : MutableCollection<in R>> Array<*>.filterIsInstanceTo(destination: C): C {\r\n    for (element in this) if (element is R) destination.add(element)\r\n    return destination\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements not matching the given [predicate].\r\n */\r\npublic inline fun <T> Array<out T>.filterNot(predicate: (T) -> Boolean): List<T> {\r\n    return filterNotTo(ArrayList<T>(), predicate)\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements not matching the given [predicate].\r\n */\r\npublic inline fun ByteArray.filterNot(predicate: (Byte) -> Boolean): List<Byte> {\r\n    return filterNotTo(ArrayList<Byte>(), predicate)\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements not matching the given [predicate].\r\n */\r\npublic inline fun ShortArray.filterNot(predicate: (Short) -> Boolean): List<Short> {\r\n    return filterNotTo(ArrayList<Short>(), predicate)\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements not matching the given [predicate].\r\n */\r\npublic inline fun IntArray.filterNot(predicate: (Int) -> Boolean): List<Int> {\r\n    return filterNotTo(ArrayList<Int>(), predicate)\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements not matching the given [predicate].\r\n */\r\npublic inline fun LongArray.filterNot(predicate: (Long) -> Boolean): List<Long> {\r\n    return filterNotTo(ArrayList<Long>(), predicate)\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements not matching the given [predicate].\r\n */\r\npublic inline fun FloatArray.filterNot(predicate: (Float) -> Boolean): List<Float> {\r\n    return filterNotTo(ArrayList<Float>(), predicate)\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements not matching the given [predicate].\r\n */\r\npublic inline fun DoubleArray.filterNot(predicate: (Double) -> Boolean): List<Double> {\r\n    return filterNotTo(ArrayList<Double>(), predicate)\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements not matching the given [predicate].\r\n */\r\npublic inline fun BooleanArray.filterNot(predicate: (Boolean) -> Boolean): List<Boolean> {\r\n    return filterNotTo(ArrayList<Boolean>(), predicate)\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements not matching the given [predicate].\r\n */\r\npublic inline fun CharArray.filterNot(predicate: (Char) -> Boolean): List<Char> {\r\n    return filterNotTo(ArrayList<Char>(), predicate)\r\n}\r\n\r\n/**\r\n * Returns a list containing all elements that are not `null`.\r\n */\r\npublic fun <T : Any> Array<out T?>.filterNotNull(): List<T> {\r\n    return filterNotNullTo(ArrayList<T>())\r\n}\r\n\r\n/**\r\n * Appends all elements that are not `null` to the given [destination].\r\n */\r\npublic fun <C : MutableCollection<in T>, T : Any> Array<out T?>.filterNotNullTo(destination: C): C {\r\n    for (element in this) if (element != null) destination.add(element)\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements not matching the given [predicate] to the given [destination].\r\n */\r\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\r\n    for (element in this) if (!predicate(element)) destination.add(element)\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements not matching the given [predicate] to the given [destination].\r\n */\r\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterNotTo(destination: C, predicate: (Byte) -> Boolean): C {\r\n    for (element in this) if (!predicate(element)) destination.add(element)\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements not matching the given [predicate] to the given [destination].\r\n */\r\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterNotTo(destination: C, predicate: (Short) -> Boolean): C {\r\n    for (element in this) if (!predicate(element)) destination.add(element)\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements not matching the given [predicate] to the given [destination].\r\n */\r\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterNotTo(destination: C, predicate: (Int) -> Boolean): C {\r\n    for (element in this) if (!predicate(element)) destination.add(element)\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements not matching the given [predicate] to the given [destination].\r\n */\r\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterNotTo(destination: C, predicate: (Long) -> Boolean): C {\r\n    for (element in this) if (!predicate(element)) destination.add(element)\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements not matching the given [predicate] to the given [destination].\r\n */\r\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterNotTo(destination: C, predicate: (Float) -> Boolean): C {\r\n    for (element in this) if (!predicate(element)) destination.add(element)\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements not matching the given [predicate] to the given [destination].\r\n */\r\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterNotTo(destination: C, predicate: (Double) -> Boolean): C {\r\n    for (element in this) if (!predicate(element)) destination.add(element)\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements not matching the given [predicate] to the given [destination].\r\n */\r\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterNotTo(destination: C, predicate: (Boolean) -> Boolean): C {\r\n    for (element in this) if (!predicate(element)) destination.add(element)\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements not matching the given [predicate] to the given [destination].\r\n */\r\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterNotTo(destination: C, predicate: (Char) -> Boolean): C {\r\n    for (element in this) if (!predicate(element)) destination.add(element)\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements matching the given [predicate] to the given [destination].\r\n */\r\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\r\n    for (element in this) if (predicate(element)) destination.add(element)\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements matching the given [predicate] to the given [destination].\r\n */\r\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterTo(destination: C, predicate: (Byte) -> Boolean): C {\r\n    for (element in this) if (predicate(element)) destination.add(element)\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements matching the given [predicate] to the given [destination].\r\n */\r\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterTo(destination: C, predicate: (Short) -> Boolean): C {\r\n    for (element in this) if (predicate(element)) destination.add(element)\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements matching the given [predicate] to the given [destination].\r\n */\r\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterTo(destination: C, predicate: (Int) -> Boolean): C {\r\n    for (element in this) if (predicate(element)) destination.add(element)\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements matching the given [predicate] to the given [destination].\r\n */\r\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterTo(destination: C, predicate: (Long) -> Boolean): C {\r\n    for (element in this) if (predicate(element)) destination.add(element)\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements matching the given [predicate] to the given [destination].\r\n */\r\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterTo(destination: C, predicate: (Float) -> Boolean): C {\r\n    for (element in this) if (predicate(element)) destination.add(element)\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements matching the given [predicate] to the given [destination].\r\n */\r\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterTo(destination: C, predicate: (Double) -> Boolean): C {\r\n    for (element in this) if (predicate(element)) destination.add(element)\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements matching the given [predicate] to the given [destination].\r\n */\r\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterTo(destination: C, predicate: (Boolean) -> Boolean): C {\r\n    for (element in this) if (predicate(element)) destination.add(element)\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements matching the given [predicate] to the given [destination].\r\n */\r\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterTo(destination: C, predicate: (Char) -> Boolean): C {\r\n    for (element in this) if (predicate(element)) destination.add(element)\r\n    return destination\r\n}\r\n\r\n/**\r\n * Returns a list containing elements at indices in the specified [indices] range.\r\n */\r\npublic fun <T> Array<out T>.slice(indices: IntRange): List<T> {\r\n    if (indices.isEmpty()) return listOf()\r\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\r\n}\r\n\r\n/**\r\n * Returns a list containing elements at indices in the specified [indices] range.\r\n */\r\npublic fun ByteArray.slice(indices: IntRange): List<Byte> {\r\n    if (indices.isEmpty()) return listOf()\r\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\r\n}\r\n\r\n/**\r\n * Returns a list containing elements at indices in the specified [indices] range.\r\n */\r\npublic fun ShortArray.slice(indices: IntRange): List<Short> {\r\n    if (indices.isEmpty()) return listOf()\r\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\r\n}\r\n\r\n/**\r\n * Returns a list containing elements at indices in the specified [indices] range.\r\n */\r\npublic fun IntArray.slice(indices: IntRange): List<Int> {\r\n    if (indices.isEmpty()) return listOf()\r\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\r\n}\r\n\r\n/**\r\n * Returns a list containing elements at indices in the specified [indices] range.\r\n */\r\npublic fun LongArray.slice(indices: IntRange): List<Long> {\r\n    if (indices.isEmpty()) return listOf()\r\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\r\n}\r\n\r\n/**\r\n * Returns a list containing elements at indices in the specified [indices] range.\r\n */\r\npublic fun FloatArray.slice(indices: IntRange): List<Float> {\r\n    if (indices.isEmpty()) return listOf()\r\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\r\n}\r\n\r\n/**\r\n * Returns a list containing elements at indices in the specified [indices] range.\r\n */\r\npublic fun DoubleArray.slice(indices: IntRange): List<Double> {\r\n    if (indices.isEmpty()) return listOf()\r\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\r\n}\r\n\r\n/**\r\n * Returns a list containing elements at indices in the specified [indices] range.\r\n */\r\npublic fun BooleanArray.slice(indices: IntRange): List<Boolean> {\r\n    if (indices.isEmpty()) return listOf()\r\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\r\n}\r\n\r\n/**\r\n * Returns a list containing elements at indices in the specified [indices] range.\r\n */\r\npublic fun CharArray.slice(indices: IntRange): List<Char> {\r\n    if (indices.isEmpty()) return listOf()\r\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\r\n}\r\n\r\n/**\r\n * Returns a list containing elements at specified [indices].\r\n */\r\npublic fun <T> Array<out T>.slice(indices: Iterable<Int>): List<T> {\r\n    val size = indices.collectionSizeOrDefault(10)\r\n    if (size == 0) return emptyList()\r\n    val list = ArrayList<T>(size)\r\n    for (index in indices) {\r\n        list.add(get(index))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing elements at specified [indices].\r\n */\r\npublic fun ByteArray.slice(indices: Iterable<Int>): List<Byte> {\r\n    val size = indices.collectionSizeOrDefault(10)\r\n    if (size == 0) return emptyList()\r\n    val list = ArrayList<Byte>(size)\r\n    for (index in indices) {\r\n        list.add(get(index))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing elements at specified [indices].\r\n */\r\npublic fun ShortArray.slice(indices: Iterable<Int>): List<Short> {\r\n    val size = indices.collectionSizeOrDefault(10)\r\n    if (size == 0) return emptyList()\r\n    val list = ArrayList<Short>(size)\r\n    for (index in indices) {\r\n        list.add(get(index))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing elements at specified [indices].\r\n */\r\npublic fun IntArray.slice(indices: Iterable<Int>): List<Int> {\r\n    val size = indices.collectionSizeOrDefault(10)\r\n    if (size == 0) return emptyList()\r\n    val list = ArrayList<Int>(size)\r\n    for (index in indices) {\r\n        list.add(get(index))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing elements at specified [indices].\r\n */\r\npublic fun LongArray.slice(indices: Iterable<Int>): List<Long> {\r\n    val size = indices.collectionSizeOrDefault(10)\r\n    if (size == 0) return emptyList()\r\n    val list = ArrayList<Long>(size)\r\n    for (index in indices) {\r\n        list.add(get(index))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing elements at specified [indices].\r\n */\r\npublic fun FloatArray.slice(indices: Iterable<Int>): List<Float> {\r\n    val size = indices.collectionSizeOrDefault(10)\r\n    if (size == 0) return emptyList()\r\n    val list = ArrayList<Float>(size)\r\n    for (index in indices) {\r\n        list.add(get(index))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing elements at specified [indices].\r\n */\r\npublic fun DoubleArray.slice(indices: Iterable<Int>): List<Double> {\r\n    val size = indices.collectionSizeOrDefault(10)\r\n    if (size == 0) return emptyList()\r\n    val list = ArrayList<Double>(size)\r\n    for (index in indices) {\r\n        list.add(get(index))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing elements at specified [indices].\r\n */\r\npublic fun BooleanArray.slice(indices: Iterable<Int>): List<Boolean> {\r\n    val size = indices.collectionSizeOrDefault(10)\r\n    if (size == 0) return emptyList()\r\n    val list = ArrayList<Boolean>(size)\r\n    for (index in indices) {\r\n        list.add(get(index))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing elements at specified [indices].\r\n */\r\npublic fun CharArray.slice(indices: Iterable<Int>): List<Char> {\r\n    val size = indices.collectionSizeOrDefault(10)\r\n    if (size == 0) return emptyList()\r\n    val list = ArrayList<Char>(size)\r\n    for (index in indices) {\r\n        list.add(get(index))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns an array containing elements of this array at specified [indices].\r\n */\r\npublic fun <T> Array<T>.sliceArray(indices: Collection<Int>): Array<T> {\r\n    val result = arrayOfNulls(this, indices.size)\r\n    var targetIndex = 0\r\n    for (sourceIndex in indices) {\r\n        result[targetIndex++] = this[sourceIndex]\r\n    }\r\n    return result\r\n}\r\n\r\n/**\r\n * Returns an array containing elements of this array at specified [indices].\r\n */\r\npublic fun ByteArray.sliceArray(indices: Collection<Int>): ByteArray {\r\n    val result = ByteArray(indices.size)\r\n    var targetIndex = 0\r\n    for (sourceIndex in indices) {\r\n        result[targetIndex++] = this[sourceIndex]\r\n    }\r\n    return result\r\n}\r\n\r\n/**\r\n * Returns an array containing elements of this array at specified [indices].\r\n */\r\npublic fun ShortArray.sliceArray(indices: Collection<Int>): ShortArray {\r\n    val result = ShortArray(indices.size)\r\n    var targetIndex = 0\r\n    for (sourceIndex in indices) {\r\n        result[targetIndex++] = this[sourceIndex]\r\n    }\r\n    return result\r\n}\r\n\r\n/**\r\n * Returns an array containing elements of this array at specified [indices].\r\n */\r\npublic fun IntArray.sliceArray(indices: Collection<Int>): IntArray {\r\n    val result = IntArray(indices.size)\r\n    var targetIndex = 0\r\n    for (sourceIndex in indices) {\r\n        result[targetIndex++] = this[sourceIndex]\r\n    }\r\n    return result\r\n}\r\n\r\n/**\r\n * Returns an array containing elements of this array at specified [indices].\r\n */\r\npublic fun LongArray.sliceArray(indices: Collection<Int>): LongArray {\r\n    val result = LongArray(indices.size)\r\n    var targetIndex = 0\r\n    for (sourceIndex in indices) {\r\n        result[targetIndex++] = this[sourceIndex]\r\n    }\r\n    return result\r\n}\r\n\r\n/**\r\n * Returns an array containing elements of this array at specified [indices].\r\n */\r\npublic fun FloatArray.sliceArray(indices: Collection<Int>): FloatArray {\r\n    val result = FloatArray(indices.size)\r\n    var targetIndex = 0\r\n    for (sourceIndex in indices) {\r\n        result[targetIndex++] = this[sourceIndex]\r\n    }\r\n    return result\r\n}\r\n\r\n/**\r\n * Returns an array containing elements of this array at specified [indices].\r\n */\r\npublic fun DoubleArray.sliceArray(indices: Collection<Int>): DoubleArray {\r\n    val result = DoubleArray(indices.size)\r\n    var targetIndex = 0\r\n    for (sourceIndex in indices) {\r\n        result[targetIndex++] = this[sourceIndex]\r\n    }\r\n    return result\r\n}\r\n\r\n/**\r\n * Returns an array containing elements of this array at specified [indices].\r\n */\r\npublic fun BooleanArray.sliceArray(indices: Collection<Int>): BooleanArray {\r\n    val result = BooleanArray(indices.size)\r\n    var targetIndex = 0\r\n    for (sourceIndex in indices) {\r\n        result[targetIndex++] = this[sourceIndex]\r\n    }\r\n    return result\r\n}\r\n\r\n/**\r\n * Returns an array containing elements of this array at specified [indices].\r\n */\r\npublic fun CharArray.sliceArray(indices: Collection<Int>): CharArray {\r\n    val result = CharArray(indices.size)\r\n    var targetIndex = 0\r\n    for (sourceIndex in indices) {\r\n        result[targetIndex++] = this[sourceIndex]\r\n    }\r\n    return result\r\n}\r\n\r\n/**\r\n * Returns a list containing elements at indices in the specified [indices] range.\r\n */\r\npublic fun <T> Array<T>.sliceArray(indices: IntRange): Array<T> {\r\n    if (indices.isEmpty()) return copyOfRange(0, 0)\r\n    return copyOfRange(indices.start, indices.endInclusive + 1)\r\n}\r\n\r\n/**\r\n * Returns a list containing elements at indices in the specified [indices] range.\r\n */\r\npublic fun ByteArray.sliceArray(indices: IntRange): ByteArray {\r\n    if (indices.isEmpty()) return ByteArray(0)\r\n    return copyOfRange(indices.start, indices.endInclusive + 1)\r\n}\r\n\r\n/**\r\n * Returns a list containing elements at indices in the specified [indices] range.\r\n */\r\npublic fun ShortArray.sliceArray(indices: IntRange): ShortArray {\r\n    if (indices.isEmpty()) return ShortArray(0)\r\n    return copyOfRange(indices.start, indices.endInclusive + 1)\r\n}\r\n\r\n/**\r\n * Returns a list containing elements at indices in the specified [indices] range.\r\n */\r\npublic fun IntArray.sliceArray(indices: IntRange): IntArray {\r\n    if (indices.isEmpty()) return IntArray(0)\r\n    return copyOfRange(indices.start, indices.endInclusive + 1)\r\n}\r\n\r\n/**\r\n * Returns a list containing elements at indices in the specified [indices] range.\r\n */\r\npublic fun LongArray.sliceArray(indices: IntRange): LongArray {\r\n    if (indices.isEmpty()) return LongArray(0)\r\n    return copyOfRange(indices.start, indices.endInclusive + 1)\r\n}\r\n\r\n/**\r\n * Returns a list containing elements at indices in the specified [indices] range.\r\n */\r\npublic fun FloatArray.sliceArray(indices: IntRange): FloatArray {\r\n    if (indices.isEmpty()) return FloatArray(0)\r\n    return copyOfRange(indices.start, indices.endInclusive + 1)\r\n}\r\n\r\n/**\r\n * Returns a list containing elements at indices in the specified [indices] range.\r\n */\r\npublic fun DoubleArray.sliceArray(indices: IntRange): DoubleArray {\r\n    if (indices.isEmpty()) return DoubleArray(0)\r\n    return copyOfRange(indices.start, indices.endInclusive + 1)\r\n}\r\n\r\n/**\r\n * Returns a list containing elements at indices in the specified [indices] range.\r\n */\r\npublic fun BooleanArray.sliceArray(indices: IntRange): BooleanArray {\r\n    if (indices.isEmpty()) return BooleanArray(0)\r\n    return copyOfRange(indices.start, indices.endInclusive + 1)\r\n}\r\n\r\n/**\r\n * Returns a list containing elements at indices in the specified [indices] range.\r\n */\r\npublic fun CharArray.sliceArray(indices: IntRange): CharArray {\r\n    if (indices.isEmpty()) return CharArray(0)\r\n    return copyOfRange(indices.start, indices.endInclusive + 1)\r\n}\r\n\r\n/**\r\n * Returns a list containing first [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic fun <T> Array<out T>.take(n: Int): List<T> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    if (n == 0) return emptyList()\r\n    if (n >= size) return toList()\r\n    if (n == 1) return listOf(this[0])\r\n    var count = 0\r\n    val list = ArrayList<T>(n)\r\n    for (item in this) {\r\n        if (count++ == n)\r\n            break\r\n        list.add(item)\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing first [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic fun ByteArray.take(n: Int): List<Byte> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    if (n == 0) return emptyList()\r\n    if (n >= size) return toList()\r\n    if (n == 1) return listOf(this[0])\r\n    var count = 0\r\n    val list = ArrayList<Byte>(n)\r\n    for (item in this) {\r\n        if (count++ == n)\r\n            break\r\n        list.add(item)\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing first [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic fun ShortArray.take(n: Int): List<Short> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    if (n == 0) return emptyList()\r\n    if (n >= size) return toList()\r\n    if (n == 1) return listOf(this[0])\r\n    var count = 0\r\n    val list = ArrayList<Short>(n)\r\n    for (item in this) {\r\n        if (count++ == n)\r\n            break\r\n        list.add(item)\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing first [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic fun IntArray.take(n: Int): List<Int> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    if (n == 0) return emptyList()\r\n    if (n >= size) return toList()\r\n    if (n == 1) return listOf(this[0])\r\n    var count = 0\r\n    val list = ArrayList<Int>(n)\r\n    for (item in this) {\r\n        if (count++ == n)\r\n            break\r\n        list.add(item)\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing first [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic fun LongArray.take(n: Int): List<Long> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    if (n == 0) return emptyList()\r\n    if (n >= size) return toList()\r\n    if (n == 1) return listOf(this[0])\r\n    var count = 0\r\n    val list = ArrayList<Long>(n)\r\n    for (item in this) {\r\n        if (count++ == n)\r\n            break\r\n        list.add(item)\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing first [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic fun FloatArray.take(n: Int): List<Float> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    if (n == 0) return emptyList()\r\n    if (n >= size) return toList()\r\n    if (n == 1) return listOf(this[0])\r\n    var count = 0\r\n    val list = ArrayList<Float>(n)\r\n    for (item in this) {\r\n        if (count++ == n)\r\n            break\r\n        list.add(item)\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing first [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic fun DoubleArray.take(n: Int): List<Double> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    if (n == 0) return emptyList()\r\n    if (n >= size) return toList()\r\n    if (n == 1) return listOf(this[0])\r\n    var count = 0\r\n    val list = ArrayList<Double>(n)\r\n    for (item in this) {\r\n        if (count++ == n)\r\n            break\r\n        list.add(item)\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing first [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic fun BooleanArray.take(n: Int): List<Boolean> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    if (n == 0) return emptyList()\r\n    if (n >= size) return toList()\r\n    if (n == 1) return listOf(this[0])\r\n    var count = 0\r\n    val list = ArrayList<Boolean>(n)\r\n    for (item in this) {\r\n        if (count++ == n)\r\n            break\r\n        list.add(item)\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing first [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic fun CharArray.take(n: Int): List<Char> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    if (n == 0) return emptyList()\r\n    if (n >= size) return toList()\r\n    if (n == 1) return listOf(this[0])\r\n    var count = 0\r\n    val list = ArrayList<Char>(n)\r\n    for (item in this) {\r\n        if (count++ == n)\r\n            break\r\n        list.add(item)\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing last [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic fun <T> Array<out T>.takeLast(n: Int): List<T> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    if (n == 0) return emptyList()\r\n    val size = size\r\n    if (n >= size) return toList()\r\n    if (n == 1) return listOf(this[size - 1])\r\n    val list = ArrayList<T>(n)\r\n    for (index in size - n until size)\r\n        list.add(this[index])\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing last [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic fun ByteArray.takeLast(n: Int): List<Byte> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    if (n == 0) return emptyList()\r\n    val size = size\r\n    if (n >= size) return toList()\r\n    if (n == 1) return listOf(this[size - 1])\r\n    val list = ArrayList<Byte>(n)\r\n    for (index in size - n until size)\r\n        list.add(this[index])\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing last [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic fun ShortArray.takeLast(n: Int): List<Short> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    if (n == 0) return emptyList()\r\n    val size = size\r\n    if (n >= size) return toList()\r\n    if (n == 1) return listOf(this[size - 1])\r\n    val list = ArrayList<Short>(n)\r\n    for (index in size - n until size)\r\n        list.add(this[index])\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing last [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic fun IntArray.takeLast(n: Int): List<Int> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    if (n == 0) return emptyList()\r\n    val size = size\r\n    if (n >= size) return toList()\r\n    if (n == 1) return listOf(this[size - 1])\r\n    val list = ArrayList<Int>(n)\r\n    for (index in size - n until size)\r\n        list.add(this[index])\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing last [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic fun LongArray.takeLast(n: Int): List<Long> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    if (n == 0) return emptyList()\r\n    val size = size\r\n    if (n >= size) return toList()\r\n    if (n == 1) return listOf(this[size - 1])\r\n    val list = ArrayList<Long>(n)\r\n    for (index in size - n until size)\r\n        list.add(this[index])\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing last [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic fun FloatArray.takeLast(n: Int): List<Float> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    if (n == 0) return emptyList()\r\n    val size = size\r\n    if (n >= size) return toList()\r\n    if (n == 1) return listOf(this[size - 1])\r\n    val list = ArrayList<Float>(n)\r\n    for (index in size - n until size)\r\n        list.add(this[index])\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing last [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic fun DoubleArray.takeLast(n: Int): List<Double> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    if (n == 0) return emptyList()\r\n    val size = size\r\n    if (n >= size) return toList()\r\n    if (n == 1) return listOf(this[size - 1])\r\n    val list = ArrayList<Double>(n)\r\n    for (index in size - n until size)\r\n        list.add(this[index])\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing last [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic fun BooleanArray.takeLast(n: Int): List<Boolean> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    if (n == 0) return emptyList()\r\n    val size = size\r\n    if (n >= size) return toList()\r\n    if (n == 1) return listOf(this[size - 1])\r\n    val list = ArrayList<Boolean>(n)\r\n    for (index in size - n until size)\r\n        list.add(this[index])\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing last [n] elements.\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic fun CharArray.takeLast(n: Int): List<Char> {\r\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\r\n    if (n == 0) return emptyList()\r\n    val size = size\r\n    if (n >= size) return toList()\r\n    if (n == 1) return listOf(this[size - 1])\r\n    val list = ArrayList<Char>(n)\r\n    for (index in size - n until size)\r\n        list.add(this[index])\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing last elements satisfying the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic inline fun <T> Array<out T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\r\n    for (index in lastIndex downTo 0) {\r\n        if (!predicate(this[index])) {\r\n            return drop(index + 1)\r\n        }\r\n    }\r\n    return toList()\r\n}\r\n\r\n/**\r\n * Returns a list containing last elements satisfying the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic inline fun ByteArray.takeLastWhile(predicate: (Byte) -> Boolean): List<Byte> {\r\n    for (index in lastIndex downTo 0) {\r\n        if (!predicate(this[index])) {\r\n            return drop(index + 1)\r\n        }\r\n    }\r\n    return toList()\r\n}\r\n\r\n/**\r\n * Returns a list containing last elements satisfying the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic inline fun ShortArray.takeLastWhile(predicate: (Short) -> Boolean): List<Short> {\r\n    for (index in lastIndex downTo 0) {\r\n        if (!predicate(this[index])) {\r\n            return drop(index + 1)\r\n        }\r\n    }\r\n    return toList()\r\n}\r\n\r\n/**\r\n * Returns a list containing last elements satisfying the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic inline fun IntArray.takeLastWhile(predicate: (Int) -> Boolean): List<Int> {\r\n    for (index in lastIndex downTo 0) {\r\n        if (!predicate(this[index])) {\r\n            return drop(index + 1)\r\n        }\r\n    }\r\n    return toList()\r\n}\r\n\r\n/**\r\n * Returns a list containing last elements satisfying the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic inline fun LongArray.takeLastWhile(predicate: (Long) -> Boolean): List<Long> {\r\n    for (index in lastIndex downTo 0) {\r\n        if (!predicate(this[index])) {\r\n            return drop(index + 1)\r\n        }\r\n    }\r\n    return toList()\r\n}\r\n\r\n/**\r\n * Returns a list containing last elements satisfying the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic inline fun FloatArray.takeLastWhile(predicate: (Float) -> Boolean): List<Float> {\r\n    for (index in lastIndex downTo 0) {\r\n        if (!predicate(this[index])) {\r\n            return drop(index + 1)\r\n        }\r\n    }\r\n    return toList()\r\n}\r\n\r\n/**\r\n * Returns a list containing last elements satisfying the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic inline fun DoubleArray.takeLastWhile(predicate: (Double) -> Boolean): List<Double> {\r\n    for (index in lastIndex downTo 0) {\r\n        if (!predicate(this[index])) {\r\n            return drop(index + 1)\r\n        }\r\n    }\r\n    return toList()\r\n}\r\n\r\n/**\r\n * Returns a list containing last elements satisfying the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic inline fun BooleanArray.takeLastWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\r\n    for (index in lastIndex downTo 0) {\r\n        if (!predicate(this[index])) {\r\n            return drop(index + 1)\r\n        }\r\n    }\r\n    return toList()\r\n}\r\n\r\n/**\r\n * Returns a list containing last elements satisfying the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic inline fun CharArray.takeLastWhile(predicate: (Char) -> Boolean): List<Char> {\r\n    for (index in lastIndex downTo 0) {\r\n        if (!predicate(this[index])) {\r\n            return drop(index + 1)\r\n        }\r\n    }\r\n    return toList()\r\n}\r\n\r\n/**\r\n * Returns a list containing first elements satisfying the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic inline fun <T> Array<out T>.takeWhile(predicate: (T) -> Boolean): List<T> {\r\n    val list = ArrayList<T>()\r\n    for (item in this) {\r\n        if (!predicate(item))\r\n            break\r\n        list.add(item)\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing first elements satisfying the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic inline fun ByteArray.takeWhile(predicate: (Byte) -> Boolean): List<Byte> {\r\n    val list = ArrayList<Byte>()\r\n    for (item in this) {\r\n        if (!predicate(item))\r\n            break\r\n        list.add(item)\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing first elements satisfying the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic inline fun ShortArray.takeWhile(predicate: (Short) -> Boolean): List<Short> {\r\n    val list = ArrayList<Short>()\r\n    for (item in this) {\r\n        if (!predicate(item))\r\n            break\r\n        list.add(item)\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing first elements satisfying the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic inline fun IntArray.takeWhile(predicate: (Int) -> Boolean): List<Int> {\r\n    val list = ArrayList<Int>()\r\n    for (item in this) {\r\n        if (!predicate(item))\r\n            break\r\n        list.add(item)\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing first elements satisfying the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic inline fun LongArray.takeWhile(predicate: (Long) -> Boolean): List<Long> {\r\n    val list = ArrayList<Long>()\r\n    for (item in this) {\r\n        if (!predicate(item))\r\n            break\r\n        list.add(item)\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing first elements satisfying the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic inline fun FloatArray.takeWhile(predicate: (Float) -> Boolean): List<Float> {\r\n    val list = ArrayList<Float>()\r\n    for (item in this) {\r\n        if (!predicate(item))\r\n            break\r\n        list.add(item)\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing first elements satisfying the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic inline fun DoubleArray.takeWhile(predicate: (Double) -> Boolean): List<Double> {\r\n    val list = ArrayList<Double>()\r\n    for (item in this) {\r\n        if (!predicate(item))\r\n            break\r\n        list.add(item)\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing first elements satisfying the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic inline fun BooleanArray.takeWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\r\n    val list = ArrayList<Boolean>()\r\n    for (item in this) {\r\n        if (!predicate(item))\r\n            break\r\n        list.add(item)\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing first elements satisfying the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Transformations.take\r\n */\r\npublic inline fun CharArray.takeWhile(predicate: (Char) -> Boolean): List<Char> {\r\n    val list = ArrayList<Char>()\r\n    for (item in this) {\r\n        if (!predicate(item))\r\n            break\r\n        list.add(item)\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Reverses elements in the array in-place.\r\n */\r\npublic fun <T> Array<T>.reverse(): Unit {\r\n    val midPoint = (size / 2) - 1\r\n    if (midPoint < 0) return\r\n    var reverseIndex = lastIndex\r\n    for (index in 0..midPoint) {\r\n        val tmp = this[index]\r\n        this[index] = this[reverseIndex]\r\n        this[reverseIndex] = tmp\r\n        reverseIndex--\r\n    }\r\n}\r\n\r\n/**\r\n * Reverses elements in the array in-place.\r\n */\r\npublic fun ByteArray.reverse(): Unit {\r\n    val midPoint = (size / 2) - 1\r\n    if (midPoint < 0) return\r\n    var reverseIndex = lastIndex\r\n    for (index in 0..midPoint) {\r\n        val tmp = this[index]\r\n        this[index] = this[reverseIndex]\r\n        this[reverseIndex] = tmp\r\n        reverseIndex--\r\n    }\r\n}\r\n\r\n/**\r\n * Reverses elements in the array in-place.\r\n */\r\npublic fun ShortArray.reverse(): Unit {\r\n    val midPoint = (size / 2) - 1\r\n    if (midPoint < 0) return\r\n    var reverseIndex = lastIndex\r\n    for (index in 0..midPoint) {\r\n        val tmp = this[index]\r\n        this[index] = this[reverseIndex]\r\n        this[reverseIndex] = tmp\r\n        reverseIndex--\r\n    }\r\n}\r\n\r\n/**\r\n * Reverses elements in the array in-place.\r\n */\r\npublic fun IntArray.reverse(): Unit {\r\n    val midPoint = (size / 2) - 1\r\n    if (midPoint < 0) return\r\n    var reverseIndex = lastIndex\r\n    for (index in 0..midPoint) {\r\n        val tmp = this[index]\r\n        this[index] = this[reverseIndex]\r\n        this[reverseIndex] = tmp\r\n        reverseIndex--\r\n    }\r\n}\r\n\r\n/**\r\n * Reverses elements in the array in-place.\r\n */\r\npublic fun LongArray.reverse(): Unit {\r\n    val midPoint = (size / 2) - 1\r\n    if (midPoint < 0) return\r\n    var reverseIndex = lastIndex\r\n    for (index in 0..midPoint) {\r\n        val tmp = this[index]\r\n        this[index] = this[reverseIndex]\r\n        this[reverseIndex] = tmp\r\n        reverseIndex--\r\n    }\r\n}\r\n\r\n/**\r\n * Reverses elements in the array in-place.\r\n */\r\npublic fun FloatArray.reverse(): Unit {\r\n    val midPoint = (size / 2) - 1\r\n    if (midPoint < 0) return\r\n    var reverseIndex = lastIndex\r\n    for (index in 0..midPoint) {\r\n        val tmp = this[index]\r\n        this[index] = this[reverseIndex]\r\n        this[reverseIndex] = tmp\r\n        reverseIndex--\r\n    }\r\n}\r\n\r\n/**\r\n * Reverses elements in the array in-place.\r\n */\r\npublic fun DoubleArray.reverse(): Unit {\r\n    val midPoint = (size / 2) - 1\r\n    if (midPoint < 0) return\r\n    var reverseIndex = lastIndex\r\n    for (index in 0..midPoint) {\r\n        val tmp = this[index]\r\n        this[index] = this[reverseIndex]\r\n        this[reverseIndex] = tmp\r\n        reverseIndex--\r\n    }\r\n}\r\n\r\n/**\r\n * Reverses elements in the array in-place.\r\n */\r\npublic fun BooleanArray.reverse(): Unit {\r\n    val midPoint = (size / 2) - 1\r\n    if (midPoint < 0) return\r\n    var reverseIndex = lastIndex\r\n    for (index in 0..midPoint) {\r\n        val tmp = this[index]\r\n        this[index] = this[reverseIndex]\r\n        this[reverseIndex] = tmp\r\n        reverseIndex--\r\n    }\r\n}\r\n\r\n/**\r\n * Reverses elements in the array in-place.\r\n */\r\npublic fun CharArray.reverse(): Unit {\r\n    val midPoint = (size / 2) - 1\r\n    if (midPoint < 0) return\r\n    var reverseIndex = lastIndex\r\n    for (index in 0..midPoint) {\r\n        val tmp = this[index]\r\n        this[index] = this[reverseIndex]\r\n        this[reverseIndex] = tmp\r\n        reverseIndex--\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a list with elements in reversed order.\r\n */\r\npublic fun <T> Array<out T>.reversed(): List<T> {\r\n    if (isEmpty()) return emptyList()\r\n    val list = toMutableList()\r\n    list.reverse()\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list with elements in reversed order.\r\n */\r\npublic fun ByteArray.reversed(): List<Byte> {\r\n    if (isEmpty()) return emptyList()\r\n    val list = toMutableList()\r\n    list.reverse()\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list with elements in reversed order.\r\n */\r\npublic fun ShortArray.reversed(): List<Short> {\r\n    if (isEmpty()) return emptyList()\r\n    val list = toMutableList()\r\n    list.reverse()\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list with elements in reversed order.\r\n */\r\npublic fun IntArray.reversed(): List<Int> {\r\n    if (isEmpty()) return emptyList()\r\n    val list = toMutableList()\r\n    list.reverse()\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list with elements in reversed order.\r\n */\r\npublic fun LongArray.reversed(): List<Long> {\r\n    if (isEmpty()) return emptyList()\r\n    val list = toMutableList()\r\n    list.reverse()\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list with elements in reversed order.\r\n */\r\npublic fun FloatArray.reversed(): List<Float> {\r\n    if (isEmpty()) return emptyList()\r\n    val list = toMutableList()\r\n    list.reverse()\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list with elements in reversed order.\r\n */\r\npublic fun DoubleArray.reversed(): List<Double> {\r\n    if (isEmpty()) return emptyList()\r\n    val list = toMutableList()\r\n    list.reverse()\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list with elements in reversed order.\r\n */\r\npublic fun BooleanArray.reversed(): List<Boolean> {\r\n    if (isEmpty()) return emptyList()\r\n    val list = toMutableList()\r\n    list.reverse()\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list with elements in reversed order.\r\n */\r\npublic fun CharArray.reversed(): List<Char> {\r\n    if (isEmpty()) return emptyList()\r\n    val list = toMutableList()\r\n    list.reverse()\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns an array with elements of this array in reversed order.\r\n */\r\npublic fun <T> Array<T>.reversedArray(): Array<T> {\r\n    if (isEmpty()) return this\r\n    val result = arrayOfNulls(this, size)\r\n    val lastIndex = lastIndex\r\n    for (i in 0..lastIndex)\r\n        result[lastIndex - i] = this[i]\r\n    return result\r\n}\r\n\r\n/**\r\n * Returns an array with elements of this array in reversed order.\r\n */\r\npublic fun ByteArray.reversedArray(): ByteArray {\r\n    if (isEmpty()) return this\r\n    val result = ByteArray(size)\r\n    val lastIndex = lastIndex\r\n    for (i in 0..lastIndex)\r\n        result[lastIndex - i] = this[i]\r\n    return result\r\n}\r\n\r\n/**\r\n * Returns an array with elements of this array in reversed order.\r\n */\r\npublic fun ShortArray.reversedArray(): ShortArray {\r\n    if (isEmpty()) return this\r\n    val result = ShortArray(size)\r\n    val lastIndex = lastIndex\r\n    for (i in 0..lastIndex)\r\n        result[lastIndex - i] = this[i]\r\n    return result\r\n}\r\n\r\n/**\r\n * Returns an array with elements of this array in reversed order.\r\n */\r\npublic fun IntArray.reversedArray(): IntArray {\r\n    if (isEmpty()) return this\r\n    val result = IntArray(size)\r\n    val lastIndex = lastIndex\r\n    for (i in 0..lastIndex)\r\n        result[lastIndex - i] = this[i]\r\n    return result\r\n}\r\n\r\n/**\r\n * Returns an array with elements of this array in reversed order.\r\n */\r\npublic fun LongArray.reversedArray(): LongArray {\r\n    if (isEmpty()) return this\r\n    val result = LongArray(size)\r\n    val lastIndex = lastIndex\r\n    for (i in 0..lastIndex)\r\n        result[lastIndex - i] = this[i]\r\n    return result\r\n}\r\n\r\n/**\r\n * Returns an array with elements of this array in reversed order.\r\n */\r\npublic fun FloatArray.reversedArray(): FloatArray {\r\n    if (isEmpty()) return this\r\n    val result = FloatArray(size)\r\n    val lastIndex = lastIndex\r\n    for (i in 0..lastIndex)\r\n        result[lastIndex - i] = this[i]\r\n    return result\r\n}\r\n\r\n/**\r\n * Returns an array with elements of this array in reversed order.\r\n */\r\npublic fun DoubleArray.reversedArray(): DoubleArray {\r\n    if (isEmpty()) return this\r\n    val result = DoubleArray(size)\r\n    val lastIndex = lastIndex\r\n    for (i in 0..lastIndex)\r\n        result[lastIndex - i] = this[i]\r\n    return result\r\n}\r\n\r\n/**\r\n * Returns an array with elements of this array in reversed order.\r\n */\r\npublic fun BooleanArray.reversedArray(): BooleanArray {\r\n    if (isEmpty()) return this\r\n    val result = BooleanArray(size)\r\n    val lastIndex = lastIndex\r\n    for (i in 0..lastIndex)\r\n        result[lastIndex - i] = this[i]\r\n    return result\r\n}\r\n\r\n/**\r\n * Returns an array with elements of this array in reversed order.\r\n */\r\npublic fun CharArray.reversedArray(): CharArray {\r\n    if (isEmpty()) return this\r\n    val result = CharArray(size)\r\n    val lastIndex = lastIndex\r\n    for (i in 0..lastIndex)\r\n        result[lastIndex - i] = this[i]\r\n    return result\r\n}\r\n\r\n/**\r\n * Sorts elements in the array in-place according to natural sort order of the value returned by specified [selector] function.\r\n * \r\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\r\n */\r\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortBy(crossinline selector: (T) -> R?): Unit {\r\n    if (size > 1) sortWith(compareBy(selector))\r\n}\r\n\r\n/**\r\n * Sorts elements in the array in-place descending according to natural sort order of the value returned by specified [selector] function.\r\n * \r\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\r\n */\r\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\r\n    if (size > 1) sortWith(compareByDescending(selector))\r\n}\r\n\r\n/**\r\n * Sorts elements in the array in-place descending according to their natural sort order.\r\n * \r\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\r\n */\r\npublic fun <T : Comparable<T>> Array<out T>.sortDescending(): Unit {\r\n    sortWith(reverseOrder())\r\n}\r\n\r\n/**\r\n * Sorts elements in the array in-place descending according to their natural sort order.\r\n */\r\npublic fun ByteArray.sortDescending(): Unit {\r\n    if (size > 1) {\r\n        sort()\r\n        reverse()\r\n    }\r\n}\r\n\r\n/**\r\n * Sorts elements in the array in-place descending according to their natural sort order.\r\n */\r\npublic fun ShortArray.sortDescending(): Unit {\r\n    if (size > 1) {\r\n        sort()\r\n        reverse()\r\n    }\r\n}\r\n\r\n/**\r\n * Sorts elements in the array in-place descending according to their natural sort order.\r\n */\r\npublic fun IntArray.sortDescending(): Unit {\r\n    if (size > 1) {\r\n        sort()\r\n        reverse()\r\n    }\r\n}\r\n\r\n/**\r\n * Sorts elements in the array in-place descending according to their natural sort order.\r\n */\r\npublic fun LongArray.sortDescending(): Unit {\r\n    if (size > 1) {\r\n        sort()\r\n        reverse()\r\n    }\r\n}\r\n\r\n/**\r\n * Sorts elements in the array in-place descending according to their natural sort order.\r\n */\r\npublic fun FloatArray.sortDescending(): Unit {\r\n    if (size > 1) {\r\n        sort()\r\n        reverse()\r\n    }\r\n}\r\n\r\n/**\r\n * Sorts elements in the array in-place descending according to their natural sort order.\r\n */\r\npublic fun DoubleArray.sortDescending(): Unit {\r\n    if (size > 1) {\r\n        sort()\r\n        reverse()\r\n    }\r\n}\r\n\r\n/**\r\n * Sorts elements in the array in-place descending according to their natural sort order.\r\n */\r\npublic fun CharArray.sortDescending(): Unit {\r\n    if (size > 1) {\r\n        sort()\r\n        reverse()\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted according to their natural sort order.\r\n * \r\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\r\n */\r\npublic fun <T : Comparable<T>> Array<out T>.sorted(): List<T> {\r\n    return sortedArray().asList()\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted according to their natural sort order.\r\n */\r\npublic fun ByteArray.sorted(): List<Byte> {\r\n    return toTypedArray().apply { sort() }.asList()\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted according to their natural sort order.\r\n */\r\npublic fun ShortArray.sorted(): List<Short> {\r\n    return toTypedArray().apply { sort() }.asList()\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted according to their natural sort order.\r\n */\r\npublic fun IntArray.sorted(): List<Int> {\r\n    return toTypedArray().apply { sort() }.asList()\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted according to their natural sort order.\r\n */\r\npublic fun LongArray.sorted(): List<Long> {\r\n    return toTypedArray().apply { sort() }.asList()\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted according to their natural sort order.\r\n */\r\npublic fun FloatArray.sorted(): List<Float> {\r\n    return toTypedArray().apply { sort() }.asList()\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted according to their natural sort order.\r\n */\r\npublic fun DoubleArray.sorted(): List<Double> {\r\n    return toTypedArray().apply { sort() }.asList()\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted according to their natural sort order.\r\n */\r\npublic fun CharArray.sorted(): List<Char> {\r\n    return toTypedArray().apply { sort() }.asList()\r\n}\r\n\r\n/**\r\n * Returns an array with all elements of this array sorted according to their natural sort order.\r\n * \r\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\r\n */\r\npublic fun <T : Comparable<T>> Array<T>.sortedArray(): Array<T> {\r\n    if (isEmpty()) return this\r\n    return this.copyOf().apply { sort() }\r\n}\r\n\r\n/**\r\n * Returns an array with all elements of this array sorted according to their natural sort order.\r\n */\r\npublic fun ByteArray.sortedArray(): ByteArray {\r\n    if (isEmpty()) return this\r\n    return this.copyOf().apply { sort() }\r\n}\r\n\r\n/**\r\n * Returns an array with all elements of this array sorted according to their natural sort order.\r\n */\r\npublic fun ShortArray.sortedArray(): ShortArray {\r\n    if (isEmpty()) return this\r\n    return this.copyOf().apply { sort() }\r\n}\r\n\r\n/**\r\n * Returns an array with all elements of this array sorted according to their natural sort order.\r\n */\r\npublic fun IntArray.sortedArray(): IntArray {\r\n    if (isEmpty()) return this\r\n    return this.copyOf().apply { sort() }\r\n}\r\n\r\n/**\r\n * Returns an array with all elements of this array sorted according to their natural sort order.\r\n */\r\npublic fun LongArray.sortedArray(): LongArray {\r\n    if (isEmpty()) return this\r\n    return this.copyOf().apply { sort() }\r\n}\r\n\r\n/**\r\n * Returns an array with all elements of this array sorted according to their natural sort order.\r\n */\r\npublic fun FloatArray.sortedArray(): FloatArray {\r\n    if (isEmpty()) return this\r\n    return this.copyOf().apply { sort() }\r\n}\r\n\r\n/**\r\n * Returns an array with all elements of this array sorted according to their natural sort order.\r\n */\r\npublic fun DoubleArray.sortedArray(): DoubleArray {\r\n    if (isEmpty()) return this\r\n    return this.copyOf().apply { sort() }\r\n}\r\n\r\n/**\r\n * Returns an array with all elements of this array sorted according to their natural sort order.\r\n */\r\npublic fun CharArray.sortedArray(): CharArray {\r\n    if (isEmpty()) return this\r\n    return this.copyOf().apply { sort() }\r\n}\r\n\r\n/**\r\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\r\n * \r\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\r\n */\r\npublic fun <T : Comparable<T>> Array<T>.sortedArrayDescending(): Array<T> {\r\n    if (isEmpty()) return this\r\n    return this.copyOf().apply { sortWith(reverseOrder()) }\r\n}\r\n\r\n/**\r\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\r\n */\r\npublic fun ByteArray.sortedArrayDescending(): ByteArray {\r\n    if (isEmpty()) return this\r\n    return this.copyOf().apply { sortDescending() }\r\n}\r\n\r\n/**\r\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\r\n */\r\npublic fun ShortArray.sortedArrayDescending(): ShortArray {\r\n    if (isEmpty()) return this\r\n    return this.copyOf().apply { sortDescending() }\r\n}\r\n\r\n/**\r\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\r\n */\r\npublic fun IntArray.sortedArrayDescending(): IntArray {\r\n    if (isEmpty()) return this\r\n    return this.copyOf().apply { sortDescending() }\r\n}\r\n\r\n/**\r\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\r\n */\r\npublic fun LongArray.sortedArrayDescending(): LongArray {\r\n    if (isEmpty()) return this\r\n    return this.copyOf().apply { sortDescending() }\r\n}\r\n\r\n/**\r\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\r\n */\r\npublic fun FloatArray.sortedArrayDescending(): FloatArray {\r\n    if (isEmpty()) return this\r\n    return this.copyOf().apply { sortDescending() }\r\n}\r\n\r\n/**\r\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\r\n */\r\npublic fun DoubleArray.sortedArrayDescending(): DoubleArray {\r\n    if (isEmpty()) return this\r\n    return this.copyOf().apply { sortDescending() }\r\n}\r\n\r\n/**\r\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\r\n */\r\npublic fun CharArray.sortedArrayDescending(): CharArray {\r\n    if (isEmpty()) return this\r\n    return this.copyOf().apply { sortDescending() }\r\n}\r\n\r\n/**\r\n * Returns an array with all elements of this array sorted according the specified [comparator].\r\n * \r\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\r\n */\r\npublic fun <T> Array<out T>.sortedArrayWith(comparator: Comparator<in T>): Array<out T> {\r\n    if (isEmpty()) return this\r\n    return this.copyOf().apply { sortWith(comparator) }\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\r\n * \r\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\r\n */\r\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\r\n    return sortedWith(compareBy(selector))\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\r\n */\r\npublic inline fun <R : Comparable<R>> ByteArray.sortedBy(crossinline selector: (Byte) -> R?): List<Byte> {\r\n    return sortedWith(compareBy(selector))\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\r\n */\r\npublic inline fun <R : Comparable<R>> ShortArray.sortedBy(crossinline selector: (Short) -> R?): List<Short> {\r\n    return sortedWith(compareBy(selector))\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\r\n */\r\npublic inline fun <R : Comparable<R>> IntArray.sortedBy(crossinline selector: (Int) -> R?): List<Int> {\r\n    return sortedWith(compareBy(selector))\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\r\n */\r\npublic inline fun <R : Comparable<R>> LongArray.sortedBy(crossinline selector: (Long) -> R?): List<Long> {\r\n    return sortedWith(compareBy(selector))\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\r\n */\r\npublic inline fun <R : Comparable<R>> FloatArray.sortedBy(crossinline selector: (Float) -> R?): List<Float> {\r\n    return sortedWith(compareBy(selector))\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\r\n */\r\npublic inline fun <R : Comparable<R>> DoubleArray.sortedBy(crossinline selector: (Double) -> R?): List<Double> {\r\n    return sortedWith(compareBy(selector))\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\r\n */\r\npublic inline fun <R : Comparable<R>> BooleanArray.sortedBy(crossinline selector: (Boolean) -> R?): List<Boolean> {\r\n    return sortedWith(compareBy(selector))\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\r\n */\r\npublic inline fun <R : Comparable<R>> CharArray.sortedBy(crossinline selector: (Char) -> R?): List<Char> {\r\n    return sortedWith(compareBy(selector))\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\r\n * \r\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\r\n */\r\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\r\n    return sortedWith(compareByDescending(selector))\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\r\n */\r\npublic inline fun <R : Comparable<R>> ByteArray.sortedByDescending(crossinline selector: (Byte) -> R?): List<Byte> {\r\n    return sortedWith(compareByDescending(selector))\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\r\n */\r\npublic inline fun <R : Comparable<R>> ShortArray.sortedByDescending(crossinline selector: (Short) -> R?): List<Short> {\r\n    return sortedWith(compareByDescending(selector))\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\r\n */\r\npublic inline fun <R : Comparable<R>> IntArray.sortedByDescending(crossinline selector: (Int) -> R?): List<Int> {\r\n    return sortedWith(compareByDescending(selector))\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\r\n */\r\npublic inline fun <R : Comparable<R>> LongArray.sortedByDescending(crossinline selector: (Long) -> R?): List<Long> {\r\n    return sortedWith(compareByDescending(selector))\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\r\n */\r\npublic inline fun <R : Comparable<R>> FloatArray.sortedByDescending(crossinline selector: (Float) -> R?): List<Float> {\r\n    return sortedWith(compareByDescending(selector))\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\r\n */\r\npublic inline fun <R : Comparable<R>> DoubleArray.sortedByDescending(crossinline selector: (Double) -> R?): List<Double> {\r\n    return sortedWith(compareByDescending(selector))\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\r\n */\r\npublic inline fun <R : Comparable<R>> BooleanArray.sortedByDescending(crossinline selector: (Boolean) -> R?): List<Boolean> {\r\n    return sortedWith(compareByDescending(selector))\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\r\n */\r\npublic inline fun <R : Comparable<R>> CharArray.sortedByDescending(crossinline selector: (Char) -> R?): List<Char> {\r\n    return sortedWith(compareByDescending(selector))\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted descending according to their natural sort order.\r\n * \r\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\r\n */\r\npublic fun <T : Comparable<T>> Array<out T>.sortedDescending(): List<T> {\r\n    return sortedWith(reverseOrder())\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted descending according to their natural sort order.\r\n */\r\npublic fun ByteArray.sortedDescending(): List<Byte> {\r\n    return copyOf().apply { sort() }.reversed()\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted descending according to their natural sort order.\r\n */\r\npublic fun ShortArray.sortedDescending(): List<Short> {\r\n    return copyOf().apply { sort() }.reversed()\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted descending according to their natural sort order.\r\n */\r\npublic fun IntArray.sortedDescending(): List<Int> {\r\n    return copyOf().apply { sort() }.reversed()\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted descending according to their natural sort order.\r\n */\r\npublic fun LongArray.sortedDescending(): List<Long> {\r\n    return copyOf().apply { sort() }.reversed()\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted descending according to their natural sort order.\r\n */\r\npublic fun FloatArray.sortedDescending(): List<Float> {\r\n    return copyOf().apply { sort() }.reversed()\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted descending according to their natural sort order.\r\n */\r\npublic fun DoubleArray.sortedDescending(): List<Double> {\r\n    return copyOf().apply { sort() }.reversed()\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted descending according to their natural sort order.\r\n */\r\npublic fun CharArray.sortedDescending(): List<Char> {\r\n    return copyOf().apply { sort() }.reversed()\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted according to the specified [comparator].\r\n * \r\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\r\n */\r\npublic fun <T> Array<out T>.sortedWith(comparator: Comparator<in T>): List<T> {\r\n    return sortedArrayWith(comparator).asList()\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted according to the specified [comparator].\r\n */\r\npublic fun ByteArray.sortedWith(comparator: Comparator<in Byte>): List<Byte> {\r\n    return toTypedArray().apply { sortWith(comparator) }.asList()\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted according to the specified [comparator].\r\n */\r\npublic fun ShortArray.sortedWith(comparator: Comparator<in Short>): List<Short> {\r\n    return toTypedArray().apply { sortWith(comparator) }.asList()\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted according to the specified [comparator].\r\n */\r\npublic fun IntArray.sortedWith(comparator: Comparator<in Int>): List<Int> {\r\n    return toTypedArray().apply { sortWith(comparator) }.asList()\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted according to the specified [comparator].\r\n */\r\npublic fun LongArray.sortedWith(comparator: Comparator<in Long>): List<Long> {\r\n    return toTypedArray().apply { sortWith(comparator) }.asList()\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted according to the specified [comparator].\r\n */\r\npublic fun FloatArray.sortedWith(comparator: Comparator<in Float>): List<Float> {\r\n    return toTypedArray().apply { sortWith(comparator) }.asList()\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted according to the specified [comparator].\r\n */\r\npublic fun DoubleArray.sortedWith(comparator: Comparator<in Double>): List<Double> {\r\n    return toTypedArray().apply { sortWith(comparator) }.asList()\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted according to the specified [comparator].\r\n */\r\npublic fun BooleanArray.sortedWith(comparator: Comparator<in Boolean>): List<Boolean> {\r\n    return toTypedArray().apply { sortWith(comparator) }.asList()\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted according to the specified [comparator].\r\n */\r\npublic fun CharArray.sortedWith(comparator: Comparator<in Char>): List<Char> {\r\n    return toTypedArray().apply { sortWith(comparator) }.asList()\r\n}\r\n\r\n/**\r\n * Returns a [List] that wraps the original array.\r\n */\r\npublic expect fun <T> Array<out T>.asList(): List<T>\r\n\r\n/**\r\n * Returns a [List] that wraps the original array.\r\n */\r\npublic expect fun ByteArray.asList(): List<Byte>\r\n\r\n/**\r\n * Returns a [List] that wraps the original array.\r\n */\r\npublic expect fun ShortArray.asList(): List<Short>\r\n\r\n/**\r\n * Returns a [List] that wraps the original array.\r\n */\r\npublic expect fun IntArray.asList(): List<Int>\r\n\r\n/**\r\n * Returns a [List] that wraps the original array.\r\n */\r\npublic expect fun LongArray.asList(): List<Long>\r\n\r\n/**\r\n * Returns a [List] that wraps the original array.\r\n */\r\npublic expect fun FloatArray.asList(): List<Float>\r\n\r\n/**\r\n * Returns a [List] that wraps the original array.\r\n */\r\npublic expect fun DoubleArray.asList(): List<Double>\r\n\r\n/**\r\n * Returns a [List] that wraps the original array.\r\n */\r\npublic expect fun BooleanArray.asList(): List<Boolean>\r\n\r\n/**\r\n * Returns a [List] that wraps the original array.\r\n */\r\npublic expect fun CharArray.asList(): List<Char>\r\n\r\n/**\r\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\r\n * i.e. contain the same number of the same elements in the same order.\r\n * \r\n * If two corresponding elements are nested arrays, they are also compared deeply.\r\n * If any of arrays contains itself on any nesting level the behavior is undefined.\r\n * \r\n * The elements of other types are compared for equality with the [equals][Any.equals] function.\r\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic expect infix fun <T> Array<out T>.contentDeepEquals(other: Array<out T>): Boolean\r\n\r\n/**\r\n * Returns a hash code based on the contents of this array as if it is [List].\r\n * Nested arrays are treated as lists too.\r\n * \r\n * If any of arrays contains itself on any nesting level the behavior is undefined.\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic expect fun <T> Array<out T>.contentDeepHashCode(): Int\r\n\r\n/**\r\n * Returns a string representation of the contents of this array as if it is a [List].\r\n * Nested arrays are treated as lists too.\r\n * \r\n * If any of arrays contains itself on any nesting level that reference\r\n * is rendered as `\"[...]\"` to prevent recursion.\r\n * \r\n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic expect fun <T> Array<out T>.contentDeepToString(): String\r\n\r\n/**\r\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\r\n * i.e. contain the same number of the same elements in the same order.\r\n * \r\n * The elements are compared for equality with the [equals][Any.equals] function.\r\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic expect infix fun <T> Array<out T>.contentEquals(other: Array<out T>): Boolean\r\n\r\n/**\r\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\r\n * i.e. contain the same number of the same elements in the same order.\r\n * \r\n * The elements are compared for equality with the [equals][Any.equals] function.\r\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic expect infix fun ByteArray.contentEquals(other: ByteArray): Boolean\r\n\r\n/**\r\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\r\n * i.e. contain the same number of the same elements in the same order.\r\n * \r\n * The elements are compared for equality with the [equals][Any.equals] function.\r\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic expect infix fun ShortArray.contentEquals(other: ShortArray): Boolean\r\n\r\n/**\r\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\r\n * i.e. contain the same number of the same elements in the same order.\r\n * \r\n * The elements are compared for equality with the [equals][Any.equals] function.\r\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic expect infix fun IntArray.contentEquals(other: IntArray): Boolean\r\n\r\n/**\r\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\r\n * i.e. contain the same number of the same elements in the same order.\r\n * \r\n * The elements are compared for equality with the [equals][Any.equals] function.\r\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic expect infix fun LongArray.contentEquals(other: LongArray): Boolean\r\n\r\n/**\r\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\r\n * i.e. contain the same number of the same elements in the same order.\r\n * \r\n * The elements are compared for equality with the [equals][Any.equals] function.\r\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic expect infix fun FloatArray.contentEquals(other: FloatArray): Boolean\r\n\r\n/**\r\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\r\n * i.e. contain the same number of the same elements in the same order.\r\n * \r\n * The elements are compared for equality with the [equals][Any.equals] function.\r\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic expect infix fun DoubleArray.contentEquals(other: DoubleArray): Boolean\r\n\r\n/**\r\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\r\n * i.e. contain the same number of the same elements in the same order.\r\n * \r\n * The elements are compared for equality with the [equals][Any.equals] function.\r\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic expect infix fun BooleanArray.contentEquals(other: BooleanArray): Boolean\r\n\r\n/**\r\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\r\n * i.e. contain the same number of the same elements in the same order.\r\n * \r\n * The elements are compared for equality with the [equals][Any.equals] function.\r\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic expect infix fun CharArray.contentEquals(other: CharArray): Boolean\r\n\r\n/**\r\n * Returns a hash code based on the contents of this array as if it is [List].\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic expect fun <T> Array<out T>.contentHashCode(): Int\r\n\r\n/**\r\n * Returns a hash code based on the contents of this array as if it is [List].\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic expect fun ByteArray.contentHashCode(): Int\r\n\r\n/**\r\n * Returns a hash code based on the contents of this array as if it is [List].\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic expect fun ShortArray.contentHashCode(): Int\r\n\r\n/**\r\n * Returns a hash code based on the contents of this array as if it is [List].\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic expect fun IntArray.contentHashCode(): Int\r\n\r\n/**\r\n * Returns a hash code based on the contents of this array as if it is [List].\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic expect fun LongArray.contentHashCode(): Int\r\n\r\n/**\r\n * Returns a hash code based on the contents of this array as if it is [List].\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic expect fun FloatArray.contentHashCode(): Int\r\n\r\n/**\r\n * Returns a hash code based on the contents of this array as if it is [List].\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic expect fun DoubleArray.contentHashCode(): Int\r\n\r\n/**\r\n * Returns a hash code based on the contents of this array as if it is [List].\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic expect fun BooleanArray.contentHashCode(): Int\r\n\r\n/**\r\n * Returns a hash code based on the contents of this array as if it is [List].\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic expect fun CharArray.contentHashCode(): Int\r\n\r\n/**\r\n * Returns a string representation of the contents of the specified array as if it is [List].\r\n * \r\n * @sample samples.collections.Arrays.ContentOperations.contentToString\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic expect fun <T> Array<out T>.contentToString(): String\r\n\r\n/**\r\n * Returns a string representation of the contents of the specified array as if it is [List].\r\n * \r\n * @sample samples.collections.Arrays.ContentOperations.contentToString\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic expect fun ByteArray.contentToString(): String\r\n\r\n/**\r\n * Returns a string representation of the contents of the specified array as if it is [List].\r\n * \r\n * @sample samples.collections.Arrays.ContentOperations.contentToString\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic expect fun ShortArray.contentToString(): String\r\n\r\n/**\r\n * Returns a string representation of the contents of the specified array as if it is [List].\r\n * \r\n * @sample samples.collections.Arrays.ContentOperations.contentToString\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic expect fun IntArray.contentToString(): String\r\n\r\n/**\r\n * Returns a string representation of the contents of the specified array as if it is [List].\r\n * \r\n * @sample samples.collections.Arrays.ContentOperations.contentToString\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic expect fun LongArray.contentToString(): String\r\n\r\n/**\r\n * Returns a string representation of the contents of the specified array as if it is [List].\r\n * \r\n * @sample samples.collections.Arrays.ContentOperations.contentToString\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic expect fun FloatArray.contentToString(): String\r\n\r\n/**\r\n * Returns a string representation of the contents of the specified array as if it is [List].\r\n * \r\n * @sample samples.collections.Arrays.ContentOperations.contentToString\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic expect fun DoubleArray.contentToString(): String\r\n\r\n/**\r\n * Returns a string representation of the contents of the specified array as if it is [List].\r\n * \r\n * @sample samples.collections.Arrays.ContentOperations.contentToString\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic expect fun BooleanArray.contentToString(): String\r\n\r\n/**\r\n * Returns a string representation of the contents of the specified array as if it is [List].\r\n * \r\n * @sample samples.collections.Arrays.ContentOperations.contentToString\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic expect fun CharArray.contentToString(): String\r\n\r\n/**\r\n * Copies this array or its subrange into the [destination] array and returns that array.\r\n * \r\n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\r\n * \r\n * @param destination the array to copy to.\r\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\r\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\r\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\r\n * \r\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\r\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\r\n * or when that index is out of the [destination] array indices range.\r\n * \r\n * @return the [destination] array.\r\n */\r\n@SinceKotlin(\"1.3\")\r\npublic expect fun <T> Array<out T>.copyInto(destination: Array<T>, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): Array<T>\r\n\r\n/**\r\n * Copies this array or its subrange into the [destination] array and returns that array.\r\n * \r\n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\r\n * \r\n * @param destination the array to copy to.\r\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\r\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\r\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\r\n * \r\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\r\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\r\n * or when that index is out of the [destination] array indices range.\r\n * \r\n * @return the [destination] array.\r\n */\r\n@SinceKotlin(\"1.3\")\r\npublic expect fun ByteArray.copyInto(destination: ByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ByteArray\r\n\r\n/**\r\n * Copies this array or its subrange into the [destination] array and returns that array.\r\n * \r\n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\r\n * \r\n * @param destination the array to copy to.\r\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\r\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\r\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\r\n * \r\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\r\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\r\n * or when that index is out of the [destination] array indices range.\r\n * \r\n * @return the [destination] array.\r\n */\r\n@SinceKotlin(\"1.3\")\r\npublic expect fun ShortArray.copyInto(destination: ShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ShortArray\r\n\r\n/**\r\n * Copies this array or its subrange into the [destination] array and returns that array.\r\n * \r\n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\r\n * \r\n * @param destination the array to copy to.\r\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\r\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\r\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\r\n * \r\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\r\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\r\n * or when that index is out of the [destination] array indices range.\r\n * \r\n * @return the [destination] array.\r\n */\r\n@SinceKotlin(\"1.3\")\r\npublic expect fun IntArray.copyInto(destination: IntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): IntArray\r\n\r\n/**\r\n * Copies this array or its subrange into the [destination] array and returns that array.\r\n * \r\n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\r\n * \r\n * @param destination the array to copy to.\r\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\r\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\r\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\r\n * \r\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\r\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\r\n * or when that index is out of the [destination] array indices range.\r\n * \r\n * @return the [destination] array.\r\n */\r\n@SinceKotlin(\"1.3\")\r\npublic expect fun LongArray.copyInto(destination: LongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): LongArray\r\n\r\n/**\r\n * Copies this array or its subrange into the [destination] array and returns that array.\r\n * \r\n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\r\n * \r\n * @param destination the array to copy to.\r\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\r\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\r\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\r\n * \r\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\r\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\r\n * or when that index is out of the [destination] array indices range.\r\n * \r\n * @return the [destination] array.\r\n */\r\n@SinceKotlin(\"1.3\")\r\npublic expect fun FloatArray.copyInto(destination: FloatArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): FloatArray\r\n\r\n/**\r\n * Copies this array or its subrange into the [destination] array and returns that array.\r\n * \r\n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\r\n * \r\n * @param destination the array to copy to.\r\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\r\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\r\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\r\n * \r\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\r\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\r\n * or when that index is out of the [destination] array indices range.\r\n * \r\n * @return the [destination] array.\r\n */\r\n@SinceKotlin(\"1.3\")\r\npublic expect fun DoubleArray.copyInto(destination: DoubleArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): DoubleArray\r\n\r\n/**\r\n * Copies this array or its subrange into the [destination] array and returns that array.\r\n * \r\n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\r\n * \r\n * @param destination the array to copy to.\r\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\r\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\r\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\r\n * \r\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\r\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\r\n * or when that index is out of the [destination] array indices range.\r\n * \r\n * @return the [destination] array.\r\n */\r\n@SinceKotlin(\"1.3\")\r\npublic expect fun BooleanArray.copyInto(destination: BooleanArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): BooleanArray\r\n\r\n/**\r\n * Copies this array or its subrange into the [destination] array and returns that array.\r\n * \r\n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\r\n * \r\n * @param destination the array to copy to.\r\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\r\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\r\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\r\n * \r\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\r\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\r\n * or when that index is out of the [destination] array indices range.\r\n * \r\n * @return the [destination] array.\r\n */\r\n@SinceKotlin(\"1.3\")\r\npublic expect fun CharArray.copyInto(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): CharArray\r\n\r\n/**\r\n * Returns new array which is a copy of the original array.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\r\n */\r\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\r\npublic expect fun <T> Array<T>.copyOf(): Array<T>\r\n\r\n/**\r\n * Returns new array which is a copy of the original array.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\r\n */\r\npublic expect fun ByteArray.copyOf(): ByteArray\r\n\r\n/**\r\n * Returns new array which is a copy of the original array.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\r\n */\r\npublic expect fun ShortArray.copyOf(): ShortArray\r\n\r\n/**\r\n * Returns new array which is a copy of the original array.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\r\n */\r\npublic expect fun IntArray.copyOf(): IntArray\r\n\r\n/**\r\n * Returns new array which is a copy of the original array.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\r\n */\r\npublic expect fun LongArray.copyOf(): LongArray\r\n\r\n/**\r\n * Returns new array which is a copy of the original array.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\r\n */\r\npublic expect fun FloatArray.copyOf(): FloatArray\r\n\r\n/**\r\n * Returns new array which is a copy of the original array.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\r\n */\r\npublic expect fun DoubleArray.copyOf(): DoubleArray\r\n\r\n/**\r\n * Returns new array which is a copy of the original array.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\r\n */\r\npublic expect fun BooleanArray.copyOf(): BooleanArray\r\n\r\n/**\r\n * Returns new array which is a copy of the original array.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\r\n */\r\npublic expect fun CharArray.copyOf(): CharArray\r\n\r\n/**\r\n * Returns new array which is a copy of the original array, resized to the given [newSize].\r\n * The copy is either truncated or padded at the end with zero values if necessary.\r\n * \r\n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\r\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\r\n */\r\npublic expect fun ByteArray.copyOf(newSize: Int): ByteArray\r\n\r\n/**\r\n * Returns new array which is a copy of the original array, resized to the given [newSize].\r\n * The copy is either truncated or padded at the end with zero values if necessary.\r\n * \r\n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\r\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\r\n */\r\npublic expect fun ShortArray.copyOf(newSize: Int): ShortArray\r\n\r\n/**\r\n * Returns new array which is a copy of the original array, resized to the given [newSize].\r\n * The copy is either truncated or padded at the end with zero values if necessary.\r\n * \r\n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\r\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\r\n */\r\npublic expect fun IntArray.copyOf(newSize: Int): IntArray\r\n\r\n/**\r\n * Returns new array which is a copy of the original array, resized to the given [newSize].\r\n * The copy is either truncated or padded at the end with zero values if necessary.\r\n * \r\n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\r\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\r\n */\r\npublic expect fun LongArray.copyOf(newSize: Int): LongArray\r\n\r\n/**\r\n * Returns new array which is a copy of the original array, resized to the given [newSize].\r\n * The copy is either truncated or padded at the end with zero values if necessary.\r\n * \r\n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\r\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\r\n */\r\npublic expect fun FloatArray.copyOf(newSize: Int): FloatArray\r\n\r\n/**\r\n * Returns new array which is a copy of the original array, resized to the given [newSize].\r\n * The copy is either truncated or padded at the end with zero values if necessary.\r\n * \r\n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\r\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\r\n */\r\npublic expect fun DoubleArray.copyOf(newSize: Int): DoubleArray\r\n\r\n/**\r\n * Returns new array which is a copy of the original array, resized to the given [newSize].\r\n * The copy is either truncated or padded at the end with `false` values if necessary.\r\n * \r\n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\r\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `false` values.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\r\n */\r\npublic expect fun BooleanArray.copyOf(newSize: Int): BooleanArray\r\n\r\n/**\r\n * Returns new array which is a copy of the original array, resized to the given [newSize].\r\n * The copy is either truncated or padded at the end with null char (`\\u0000`) values if necessary.\r\n * \r\n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\r\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with null char (`\\u0000`) values.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\r\n */\r\npublic expect fun CharArray.copyOf(newSize: Int): CharArray\r\n\r\n/**\r\n * Returns new array which is a copy of the original array, resized to the given [newSize].\r\n * The copy is either truncated or padded at the end with `null` values if necessary.\r\n * \r\n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\r\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `null` values.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.resizingCopyOf\r\n */\r\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\r\npublic expect fun <T> Array<T>.copyOf(newSize: Int): Array<T?>\r\n\r\n/**\r\n * Returns a new array which is a copy of the specified range of the original array.\r\n * \r\n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\r\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\r\n */\r\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\r\npublic expect fun <T> Array<T>.copyOfRange(fromIndex: Int, toIndex: Int): Array<T>\r\n\r\n/**\r\n * Returns a new array which is a copy of the specified range of the original array.\r\n * \r\n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\r\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\r\n */\r\npublic expect fun ByteArray.copyOfRange(fromIndex: Int, toIndex: Int): ByteArray\r\n\r\n/**\r\n * Returns a new array which is a copy of the specified range of the original array.\r\n * \r\n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\r\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\r\n */\r\npublic expect fun ShortArray.copyOfRange(fromIndex: Int, toIndex: Int): ShortArray\r\n\r\n/**\r\n * Returns a new array which is a copy of the specified range of the original array.\r\n * \r\n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\r\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\r\n */\r\npublic expect fun IntArray.copyOfRange(fromIndex: Int, toIndex: Int): IntArray\r\n\r\n/**\r\n * Returns a new array which is a copy of the specified range of the original array.\r\n * \r\n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\r\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\r\n */\r\npublic expect fun LongArray.copyOfRange(fromIndex: Int, toIndex: Int): LongArray\r\n\r\n/**\r\n * Returns a new array which is a copy of the specified range of the original array.\r\n * \r\n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\r\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\r\n */\r\npublic expect fun FloatArray.copyOfRange(fromIndex: Int, toIndex: Int): FloatArray\r\n\r\n/**\r\n * Returns a new array which is a copy of the specified range of the original array.\r\n * \r\n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\r\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\r\n */\r\npublic expect fun DoubleArray.copyOfRange(fromIndex: Int, toIndex: Int): DoubleArray\r\n\r\n/**\r\n * Returns a new array which is a copy of the specified range of the original array.\r\n * \r\n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\r\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\r\n */\r\npublic expect fun BooleanArray.copyOfRange(fromIndex: Int, toIndex: Int): BooleanArray\r\n\r\n/**\r\n * Returns a new array which is a copy of the specified range of the original array.\r\n * \r\n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\r\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\r\n */\r\npublic expect fun CharArray.copyOfRange(fromIndex: Int, toIndex: Int): CharArray\r\n\r\n/**\r\n * Returns the range of valid indices for the array.\r\n */\r\npublic val <T> Array<out T>.indices: IntRange\r\n    get() = IntRange(0, lastIndex)\r\n\r\n/**\r\n * Returns the range of valid indices for the array.\r\n */\r\npublic val ByteArray.indices: IntRange\r\n    get() = IntRange(0, lastIndex)\r\n\r\n/**\r\n * Returns the range of valid indices for the array.\r\n */\r\npublic val ShortArray.indices: IntRange\r\n    get() = IntRange(0, lastIndex)\r\n\r\n/**\r\n * Returns the range of valid indices for the array.\r\n */\r\npublic val IntArray.indices: IntRange\r\n    get() = IntRange(0, lastIndex)\r\n\r\n/**\r\n * Returns the range of valid indices for the array.\r\n */\r\npublic val LongArray.indices: IntRange\r\n    get() = IntRange(0, lastIndex)\r\n\r\n/**\r\n * Returns the range of valid indices for the array.\r\n */\r\npublic val FloatArray.indices: IntRange\r\n    get() = IntRange(0, lastIndex)\r\n\r\n/**\r\n * Returns the range of valid indices for the array.\r\n */\r\npublic val DoubleArray.indices: IntRange\r\n    get() = IntRange(0, lastIndex)\r\n\r\n/**\r\n * Returns the range of valid indices for the array.\r\n */\r\npublic val BooleanArray.indices: IntRange\r\n    get() = IntRange(0, lastIndex)\r\n\r\n/**\r\n * Returns the range of valid indices for the array.\r\n */\r\npublic val CharArray.indices: IntRange\r\n    get() = IntRange(0, lastIndex)\r\n\r\n/**\r\n * Returns `true` if the array is empty.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun <T> Array<out T>.isEmpty(): Boolean {\r\n    return size == 0\r\n}\r\n\r\n/**\r\n * Returns `true` if the array is empty.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun ByteArray.isEmpty(): Boolean {\r\n    return size == 0\r\n}\r\n\r\n/**\r\n * Returns `true` if the array is empty.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun ShortArray.isEmpty(): Boolean {\r\n    return size == 0\r\n}\r\n\r\n/**\r\n * Returns `true` if the array is empty.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun IntArray.isEmpty(): Boolean {\r\n    return size == 0\r\n}\r\n\r\n/**\r\n * Returns `true` if the array is empty.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun LongArray.isEmpty(): Boolean {\r\n    return size == 0\r\n}\r\n\r\n/**\r\n * Returns `true` if the array is empty.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun FloatArray.isEmpty(): Boolean {\r\n    return size == 0\r\n}\r\n\r\n/**\r\n * Returns `true` if the array is empty.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun DoubleArray.isEmpty(): Boolean {\r\n    return size == 0\r\n}\r\n\r\n/**\r\n * Returns `true` if the array is empty.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun BooleanArray.isEmpty(): Boolean {\r\n    return size == 0\r\n}\r\n\r\n/**\r\n * Returns `true` if the array is empty.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun CharArray.isEmpty(): Boolean {\r\n    return size == 0\r\n}\r\n\r\n/**\r\n * Returns `true` if the array is not empty.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun <T> Array<out T>.isNotEmpty(): Boolean {\r\n    return !isEmpty()\r\n}\r\n\r\n/**\r\n * Returns `true` if the array is not empty.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun ByteArray.isNotEmpty(): Boolean {\r\n    return !isEmpty()\r\n}\r\n\r\n/**\r\n * Returns `true` if the array is not empty.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun ShortArray.isNotEmpty(): Boolean {\r\n    return !isEmpty()\r\n}\r\n\r\n/**\r\n * Returns `true` if the array is not empty.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun IntArray.isNotEmpty(): Boolean {\r\n    return !isEmpty()\r\n}\r\n\r\n/**\r\n * Returns `true` if the array is not empty.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun LongArray.isNotEmpty(): Boolean {\r\n    return !isEmpty()\r\n}\r\n\r\n/**\r\n * Returns `true` if the array is not empty.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun FloatArray.isNotEmpty(): Boolean {\r\n    return !isEmpty()\r\n}\r\n\r\n/**\r\n * Returns `true` if the array is not empty.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun DoubleArray.isNotEmpty(): Boolean {\r\n    return !isEmpty()\r\n}\r\n\r\n/**\r\n * Returns `true` if the array is not empty.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun BooleanArray.isNotEmpty(): Boolean {\r\n    return !isEmpty()\r\n}\r\n\r\n/**\r\n * Returns `true` if the array is not empty.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun CharArray.isNotEmpty(): Boolean {\r\n    return !isEmpty()\r\n}\r\n\r\n/**\r\n * Returns the last valid index for the array.\r\n */\r\npublic val <T> Array<out T>.lastIndex: Int\r\n    get() = size - 1\r\n\r\n/**\r\n * Returns the last valid index for the array.\r\n */\r\npublic val ByteArray.lastIndex: Int\r\n    get() = size - 1\r\n\r\n/**\r\n * Returns the last valid index for the array.\r\n */\r\npublic val ShortArray.lastIndex: Int\r\n    get() = size - 1\r\n\r\n/**\r\n * Returns the last valid index for the array.\r\n */\r\npublic val IntArray.lastIndex: Int\r\n    get() = size - 1\r\n\r\n/**\r\n * Returns the last valid index for the array.\r\n */\r\npublic val LongArray.lastIndex: Int\r\n    get() = size - 1\r\n\r\n/**\r\n * Returns the last valid index for the array.\r\n */\r\npublic val FloatArray.lastIndex: Int\r\n    get() = size - 1\r\n\r\n/**\r\n * Returns the last valid index for the array.\r\n */\r\npublic val DoubleArray.lastIndex: Int\r\n    get() = size - 1\r\n\r\n/**\r\n * Returns the last valid index for the array.\r\n */\r\npublic val BooleanArray.lastIndex: Int\r\n    get() = size - 1\r\n\r\n/**\r\n * Returns the last valid index for the array.\r\n */\r\npublic val CharArray.lastIndex: Int\r\n    get() = size - 1\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then the given [element].\r\n */\r\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\r\npublic expect operator fun <T> Array<T>.plus(element: T): Array<T>\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then the given [element].\r\n */\r\npublic expect operator fun ByteArray.plus(element: Byte): ByteArray\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then the given [element].\r\n */\r\npublic expect operator fun ShortArray.plus(element: Short): ShortArray\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then the given [element].\r\n */\r\npublic expect operator fun IntArray.plus(element: Int): IntArray\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then the given [element].\r\n */\r\npublic expect operator fun LongArray.plus(element: Long): LongArray\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then the given [element].\r\n */\r\npublic expect operator fun FloatArray.plus(element: Float): FloatArray\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then the given [element].\r\n */\r\npublic expect operator fun DoubleArray.plus(element: Double): DoubleArray\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then the given [element].\r\n */\r\npublic expect operator fun BooleanArray.plus(element: Boolean): BooleanArray\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then the given [element].\r\n */\r\npublic expect operator fun CharArray.plus(element: Char): CharArray\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\r\n */\r\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\r\npublic expect operator fun <T> Array<T>.plus(elements: Collection<T>): Array<T>\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\r\n */\r\npublic expect operator fun ByteArray.plus(elements: Collection<Byte>): ByteArray\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\r\n */\r\npublic expect operator fun ShortArray.plus(elements: Collection<Short>): ShortArray\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\r\n */\r\npublic expect operator fun IntArray.plus(elements: Collection<Int>): IntArray\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\r\n */\r\npublic expect operator fun LongArray.plus(elements: Collection<Long>): LongArray\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\r\n */\r\npublic expect operator fun FloatArray.plus(elements: Collection<Float>): FloatArray\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\r\n */\r\npublic expect operator fun DoubleArray.plus(elements: Collection<Double>): DoubleArray\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\r\n */\r\npublic expect operator fun BooleanArray.plus(elements: Collection<Boolean>): BooleanArray\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\r\n */\r\npublic expect operator fun CharArray.plus(elements: Collection<Char>): CharArray\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\r\n */\r\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\r\npublic expect operator fun <T> Array<T>.plus(elements: Array<out T>): Array<T>\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\r\n */\r\npublic expect operator fun ByteArray.plus(elements: ByteArray): ByteArray\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\r\n */\r\npublic expect operator fun ShortArray.plus(elements: ShortArray): ShortArray\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\r\n */\r\npublic expect operator fun IntArray.plus(elements: IntArray): IntArray\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\r\n */\r\npublic expect operator fun LongArray.plus(elements: LongArray): LongArray\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\r\n */\r\npublic expect operator fun FloatArray.plus(elements: FloatArray): FloatArray\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\r\n */\r\npublic expect operator fun DoubleArray.plus(elements: DoubleArray): DoubleArray\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\r\n */\r\npublic expect operator fun BooleanArray.plus(elements: BooleanArray): BooleanArray\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\r\n */\r\npublic expect operator fun CharArray.plus(elements: CharArray): CharArray\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then the given [element].\r\n */\r\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\r\npublic expect fun <T> Array<T>.plusElement(element: T): Array<T>\r\n\r\n/**\r\n * Sorts the array in-place.\r\n */\r\npublic expect fun IntArray.sort(): Unit\r\n\r\n/**\r\n * Sorts the array in-place.\r\n */\r\npublic expect fun LongArray.sort(): Unit\r\n\r\n/**\r\n * Sorts the array in-place.\r\n */\r\npublic expect fun ByteArray.sort(): Unit\r\n\r\n/**\r\n * Sorts the array in-place.\r\n */\r\npublic expect fun ShortArray.sort(): Unit\r\n\r\n/**\r\n * Sorts the array in-place.\r\n */\r\npublic expect fun DoubleArray.sort(): Unit\r\n\r\n/**\r\n * Sorts the array in-place.\r\n */\r\npublic expect fun FloatArray.sort(): Unit\r\n\r\n/**\r\n * Sorts the array in-place.\r\n */\r\npublic expect fun CharArray.sort(): Unit\r\n\r\n/**\r\n * Sorts the array in-place according to the natural order of its elements.\r\n * \r\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\r\n */\r\npublic expect fun <T : Comparable<T>> Array<out T>.sort(): Unit\r\n\r\n/**\r\n * Sorts the array in-place according to the order specified by the given [comparator].\r\n * \r\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\r\n */\r\npublic expect fun <T> Array<out T>.sortWith(comparator: Comparator<in T>): Unit\r\n\r\n/**\r\n * Returns an array of Boolean containing all of the elements of this generic array.\r\n */\r\npublic fun Array<out Boolean>.toBooleanArray(): BooleanArray {\r\n    val result = BooleanArray(size)\r\n    for (index in indices)\r\n        result[index] = this[index]\r\n    return result\r\n}\r\n\r\n/**\r\n * Returns an array of Byte containing all of the elements of this generic array.\r\n */\r\npublic fun Array<out Byte>.toByteArray(): ByteArray {\r\n    val result = ByteArray(size)\r\n    for (index in indices)\r\n        result[index] = this[index]\r\n    return result\r\n}\r\n\r\n/**\r\n * Returns an array of Char containing all of the elements of this generic array.\r\n */\r\npublic fun Array<out Char>.toCharArray(): CharArray {\r\n    val result = CharArray(size)\r\n    for (index in indices)\r\n        result[index] = this[index]\r\n    return result\r\n}\r\n\r\n/**\r\n * Returns an array of Double containing all of the elements of this generic array.\r\n */\r\npublic fun Array<out Double>.toDoubleArray(): DoubleArray {\r\n    val result = DoubleArray(size)\r\n    for (index in indices)\r\n        result[index] = this[index]\r\n    return result\r\n}\r\n\r\n/**\r\n * Returns an array of Float containing all of the elements of this generic array.\r\n */\r\npublic fun Array<out Float>.toFloatArray(): FloatArray {\r\n    val result = FloatArray(size)\r\n    for (index in indices)\r\n        result[index] = this[index]\r\n    return result\r\n}\r\n\r\n/**\r\n * Returns an array of Int containing all of the elements of this generic array.\r\n */\r\npublic fun Array<out Int>.toIntArray(): IntArray {\r\n    val result = IntArray(size)\r\n    for (index in indices)\r\n        result[index] = this[index]\r\n    return result\r\n}\r\n\r\n/**\r\n * Returns an array of Long containing all of the elements of this generic array.\r\n */\r\npublic fun Array<out Long>.toLongArray(): LongArray {\r\n    val result = LongArray(size)\r\n    for (index in indices)\r\n        result[index] = this[index]\r\n    return result\r\n}\r\n\r\n/**\r\n * Returns an array of Short containing all of the elements of this generic array.\r\n */\r\npublic fun Array<out Short>.toShortArray(): ShortArray {\r\n    val result = ShortArray(size)\r\n    for (index in indices)\r\n        result[index] = this[index]\r\n    return result\r\n}\r\n\r\n/**\r\n * Returns a *typed* object array containing all of the elements of this primitive array.\r\n */\r\npublic expect fun ByteArray.toTypedArray(): Array<Byte>\r\n\r\n/**\r\n * Returns a *typed* object array containing all of the elements of this primitive array.\r\n */\r\npublic expect fun ShortArray.toTypedArray(): Array<Short>\r\n\r\n/**\r\n * Returns a *typed* object array containing all of the elements of this primitive array.\r\n */\r\npublic expect fun IntArray.toTypedArray(): Array<Int>\r\n\r\n/**\r\n * Returns a *typed* object array containing all of the elements of this primitive array.\r\n */\r\npublic expect fun LongArray.toTypedArray(): Array<Long>\r\n\r\n/**\r\n * Returns a *typed* object array containing all of the elements of this primitive array.\r\n */\r\npublic expect fun FloatArray.toTypedArray(): Array<Float>\r\n\r\n/**\r\n * Returns a *typed* object array containing all of the elements of this primitive array.\r\n */\r\npublic expect fun DoubleArray.toTypedArray(): Array<Double>\r\n\r\n/**\r\n * Returns a *typed* object array containing all of the elements of this primitive array.\r\n */\r\npublic expect fun BooleanArray.toTypedArray(): Array<Boolean>\r\n\r\n/**\r\n * Returns a *typed* object array containing all of the elements of this primitive array.\r\n */\r\npublic expect fun CharArray.toTypedArray(): Array<Char>\r\n\r\n/**\r\n * Returns a [Map] containing key-value pairs provided by [transform] function\r\n * applied to elements of the given array.\r\n * \r\n * If any of two pairs would have the same key the last one gets added to the map.\r\n * \r\n * The returned map preserves the entry iteration order of the original array.\r\n */\r\npublic inline fun <T, K, V> Array<out T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\r\n    val capacity = mapCapacity(size).coerceAtLeast(16)\r\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\r\n}\r\n\r\n/**\r\n * Returns a [Map] containing key-value pairs provided by [transform] function\r\n * applied to elements of the given array.\r\n * \r\n * If any of two pairs would have the same key the last one gets added to the map.\r\n * \r\n * The returned map preserves the entry iteration order of the original array.\r\n */\r\npublic inline fun <K, V> ByteArray.associate(transform: (Byte) -> Pair<K, V>): Map<K, V> {\r\n    val capacity = mapCapacity(size).coerceAtLeast(16)\r\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\r\n}\r\n\r\n/**\r\n * Returns a [Map] containing key-value pairs provided by [transform] function\r\n * applied to elements of the given array.\r\n * \r\n * If any of two pairs would have the same key the last one gets added to the map.\r\n * \r\n * The returned map preserves the entry iteration order of the original array.\r\n */\r\npublic inline fun <K, V> ShortArray.associate(transform: (Short) -> Pair<K, V>): Map<K, V> {\r\n    val capacity = mapCapacity(size).coerceAtLeast(16)\r\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\r\n}\r\n\r\n/**\r\n * Returns a [Map] containing key-value pairs provided by [transform] function\r\n * applied to elements of the given array.\r\n * \r\n * If any of two pairs would have the same key the last one gets added to the map.\r\n * \r\n * The returned map preserves the entry iteration order of the original array.\r\n */\r\npublic inline fun <K, V> IntArray.associate(transform: (Int) -> Pair<K, V>): Map<K, V> {\r\n    val capacity = mapCapacity(size).coerceAtLeast(16)\r\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\r\n}\r\n\r\n/**\r\n * Returns a [Map] containing key-value pairs provided by [transform] function\r\n * applied to elements of the given array.\r\n * \r\n * If any of two pairs would have the same key the last one gets added to the map.\r\n * \r\n * The returned map preserves the entry iteration order of the original array.\r\n */\r\npublic inline fun <K, V> LongArray.associate(transform: (Long) -> Pair<K, V>): Map<K, V> {\r\n    val capacity = mapCapacity(size).coerceAtLeast(16)\r\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\r\n}\r\n\r\n/**\r\n * Returns a [Map] containing key-value pairs provided by [transform] function\r\n * applied to elements of the given array.\r\n * \r\n * If any of two pairs would have the same key the last one gets added to the map.\r\n * \r\n * The returned map preserves the entry iteration order of the original array.\r\n */\r\npublic inline fun <K, V> FloatArray.associate(transform: (Float) -> Pair<K, V>): Map<K, V> {\r\n    val capacity = mapCapacity(size).coerceAtLeast(16)\r\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\r\n}\r\n\r\n/**\r\n * Returns a [Map] containing key-value pairs provided by [transform] function\r\n * applied to elements of the given array.\r\n * \r\n * If any of two pairs would have the same key the last one gets added to the map.\r\n * \r\n * The returned map preserves the entry iteration order of the original array.\r\n */\r\npublic inline fun <K, V> DoubleArray.associate(transform: (Double) -> Pair<K, V>): Map<K, V> {\r\n    val capacity = mapCapacity(size).coerceAtLeast(16)\r\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\r\n}\r\n\r\n/**\r\n * Returns a [Map] containing key-value pairs provided by [transform] function\r\n * applied to elements of the given array.\r\n * \r\n * If any of two pairs would have the same key the last one gets added to the map.\r\n * \r\n * The returned map preserves the entry iteration order of the original array.\r\n */\r\npublic inline fun <K, V> BooleanArray.associate(transform: (Boolean) -> Pair<K, V>): Map<K, V> {\r\n    val capacity = mapCapacity(size).coerceAtLeast(16)\r\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\r\n}\r\n\r\n/**\r\n * Returns a [Map] containing key-value pairs provided by [transform] function\r\n * applied to elements of the given array.\r\n * \r\n * If any of two pairs would have the same key the last one gets added to the map.\r\n * \r\n * The returned map preserves the entry iteration order of the original array.\r\n */\r\npublic inline fun <K, V> CharArray.associate(transform: (Char) -> Pair<K, V>): Map<K, V> {\r\n    val capacity = mapCapacity(size).coerceAtLeast(16)\r\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\r\n}\r\n\r\n/**\r\n * Returns a [Map] containing the elements from the given array indexed by the key\r\n * returned from [keySelector] function applied to each element.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n * \r\n * The returned map preserves the entry iteration order of the original array.\r\n */\r\npublic inline fun <T, K> Array<out T>.associateBy(keySelector: (T) -> K): Map<K, T> {\r\n    val capacity = mapCapacity(size).coerceAtLeast(16)\r\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\r\n}\r\n\r\n/**\r\n * Returns a [Map] containing the elements from the given array indexed by the key\r\n * returned from [keySelector] function applied to each element.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n * \r\n * The returned map preserves the entry iteration order of the original array.\r\n */\r\npublic inline fun <K> ByteArray.associateBy(keySelector: (Byte) -> K): Map<K, Byte> {\r\n    val capacity = mapCapacity(size).coerceAtLeast(16)\r\n    return associateByTo(LinkedHashMap<K, Byte>(capacity), keySelector)\r\n}\r\n\r\n/**\r\n * Returns a [Map] containing the elements from the given array indexed by the key\r\n * returned from [keySelector] function applied to each element.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n * \r\n * The returned map preserves the entry iteration order of the original array.\r\n */\r\npublic inline fun <K> ShortArray.associateBy(keySelector: (Short) -> K): Map<K, Short> {\r\n    val capacity = mapCapacity(size).coerceAtLeast(16)\r\n    return associateByTo(LinkedHashMap<K, Short>(capacity), keySelector)\r\n}\r\n\r\n/**\r\n * Returns a [Map] containing the elements from the given array indexed by the key\r\n * returned from [keySelector] function applied to each element.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n * \r\n * The returned map preserves the entry iteration order of the original array.\r\n */\r\npublic inline fun <K> IntArray.associateBy(keySelector: (Int) -> K): Map<K, Int> {\r\n    val capacity = mapCapacity(size).coerceAtLeast(16)\r\n    return associateByTo(LinkedHashMap<K, Int>(capacity), keySelector)\r\n}\r\n\r\n/**\r\n * Returns a [Map] containing the elements from the given array indexed by the key\r\n * returned from [keySelector] function applied to each element.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n * \r\n * The returned map preserves the entry iteration order of the original array.\r\n */\r\npublic inline fun <K> LongArray.associateBy(keySelector: (Long) -> K): Map<K, Long> {\r\n    val capacity = mapCapacity(size).coerceAtLeast(16)\r\n    return associateByTo(LinkedHashMap<K, Long>(capacity), keySelector)\r\n}\r\n\r\n/**\r\n * Returns a [Map] containing the elements from the given array indexed by the key\r\n * returned from [keySelector] function applied to each element.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n * \r\n * The returned map preserves the entry iteration order of the original array.\r\n */\r\npublic inline fun <K> FloatArray.associateBy(keySelector: (Float) -> K): Map<K, Float> {\r\n    val capacity = mapCapacity(size).coerceAtLeast(16)\r\n    return associateByTo(LinkedHashMap<K, Float>(capacity), keySelector)\r\n}\r\n\r\n/**\r\n * Returns a [Map] containing the elements from the given array indexed by the key\r\n * returned from [keySelector] function applied to each element.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n * \r\n * The returned map preserves the entry iteration order of the original array.\r\n */\r\npublic inline fun <K> DoubleArray.associateBy(keySelector: (Double) -> K): Map<K, Double> {\r\n    val capacity = mapCapacity(size).coerceAtLeast(16)\r\n    return associateByTo(LinkedHashMap<K, Double>(capacity), keySelector)\r\n}\r\n\r\n/**\r\n * Returns a [Map] containing the elements from the given array indexed by the key\r\n * returned from [keySelector] function applied to each element.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n * \r\n * The returned map preserves the entry iteration order of the original array.\r\n */\r\npublic inline fun <K> BooleanArray.associateBy(keySelector: (Boolean) -> K): Map<K, Boolean> {\r\n    val capacity = mapCapacity(size).coerceAtLeast(16)\r\n    return associateByTo(LinkedHashMap<K, Boolean>(capacity), keySelector)\r\n}\r\n\r\n/**\r\n * Returns a [Map] containing the elements from the given array indexed by the key\r\n * returned from [keySelector] function applied to each element.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n * \r\n * The returned map preserves the entry iteration order of the original array.\r\n */\r\npublic inline fun <K> CharArray.associateBy(keySelector: (Char) -> K): Map<K, Char> {\r\n    val capacity = mapCapacity(size).coerceAtLeast(16)\r\n    return associateByTo(LinkedHashMap<K, Char>(capacity), keySelector)\r\n}\r\n\r\n/**\r\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n * \r\n * The returned map preserves the entry iteration order of the original array.\r\n */\r\npublic inline fun <T, K, V> Array<out T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\r\n    val capacity = mapCapacity(size).coerceAtLeast(16)\r\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\r\n}\r\n\r\n/**\r\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n * \r\n * The returned map preserves the entry iteration order of the original array.\r\n */\r\npublic inline fun <K, V> ByteArray.associateBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, V> {\r\n    val capacity = mapCapacity(size).coerceAtLeast(16)\r\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\r\n}\r\n\r\n/**\r\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n * \r\n * The returned map preserves the entry iteration order of the original array.\r\n */\r\npublic inline fun <K, V> ShortArray.associateBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, V> {\r\n    val capacity = mapCapacity(size).coerceAtLeast(16)\r\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\r\n}\r\n\r\n/**\r\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n * \r\n * The returned map preserves the entry iteration order of the original array.\r\n */\r\npublic inline fun <K, V> IntArray.associateBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, V> {\r\n    val capacity = mapCapacity(size).coerceAtLeast(16)\r\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\r\n}\r\n\r\n/**\r\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n * \r\n * The returned map preserves the entry iteration order of the original array.\r\n */\r\npublic inline fun <K, V> LongArray.associateBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, V> {\r\n    val capacity = mapCapacity(size).coerceAtLeast(16)\r\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\r\n}\r\n\r\n/**\r\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n * \r\n * The returned map preserves the entry iteration order of the original array.\r\n */\r\npublic inline fun <K, V> FloatArray.associateBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, V> {\r\n    val capacity = mapCapacity(size).coerceAtLeast(16)\r\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\r\n}\r\n\r\n/**\r\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n * \r\n * The returned map preserves the entry iteration order of the original array.\r\n */\r\npublic inline fun <K, V> DoubleArray.associateBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, V> {\r\n    val capacity = mapCapacity(size).coerceAtLeast(16)\r\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\r\n}\r\n\r\n/**\r\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n * \r\n * The returned map preserves the entry iteration order of the original array.\r\n */\r\npublic inline fun <K, V> BooleanArray.associateBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, V> {\r\n    val capacity = mapCapacity(size).coerceAtLeast(16)\r\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\r\n}\r\n\r\n/**\r\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n * \r\n * The returned map preserves the entry iteration order of the original array.\r\n */\r\npublic inline fun <K, V> CharArray.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V> {\r\n    val capacity = mapCapacity(size).coerceAtLeast(16)\r\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\r\n}\r\n\r\n/**\r\n * Populates and returns the [destination] mutable map with key-value pairs,\r\n * where key is provided by the [keySelector] function applied to each element of the given array\r\n * and value is the element itself.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n */\r\npublic inline fun <T, K, M : MutableMap<in K, in T>> Array<out T>.associateByTo(destination: M, keySelector: (T) -> K): M {\r\n    for (element in this) {\r\n        destination.put(keySelector(element), element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Populates and returns the [destination] mutable map with key-value pairs,\r\n * where key is provided by the [keySelector] function applied to each element of the given array\r\n * and value is the element itself.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n */\r\npublic inline fun <K, M : MutableMap<in K, in Byte>> ByteArray.associateByTo(destination: M, keySelector: (Byte) -> K): M {\r\n    for (element in this) {\r\n        destination.put(keySelector(element), element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Populates and returns the [destination] mutable map with key-value pairs,\r\n * where key is provided by the [keySelector] function applied to each element of the given array\r\n * and value is the element itself.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n */\r\npublic inline fun <K, M : MutableMap<in K, in Short>> ShortArray.associateByTo(destination: M, keySelector: (Short) -> K): M {\r\n    for (element in this) {\r\n        destination.put(keySelector(element), element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Populates and returns the [destination] mutable map with key-value pairs,\r\n * where key is provided by the [keySelector] function applied to each element of the given array\r\n * and value is the element itself.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n */\r\npublic inline fun <K, M : MutableMap<in K, in Int>> IntArray.associateByTo(destination: M, keySelector: (Int) -> K): M {\r\n    for (element in this) {\r\n        destination.put(keySelector(element), element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Populates and returns the [destination] mutable map with key-value pairs,\r\n * where key is provided by the [keySelector] function applied to each element of the given array\r\n * and value is the element itself.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n */\r\npublic inline fun <K, M : MutableMap<in K, in Long>> LongArray.associateByTo(destination: M, keySelector: (Long) -> K): M {\r\n    for (element in this) {\r\n        destination.put(keySelector(element), element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Populates and returns the [destination] mutable map with key-value pairs,\r\n * where key is provided by the [keySelector] function applied to each element of the given array\r\n * and value is the element itself.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n */\r\npublic inline fun <K, M : MutableMap<in K, in Float>> FloatArray.associateByTo(destination: M, keySelector: (Float) -> K): M {\r\n    for (element in this) {\r\n        destination.put(keySelector(element), element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Populates and returns the [destination] mutable map with key-value pairs,\r\n * where key is provided by the [keySelector] function applied to each element of the given array\r\n * and value is the element itself.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n */\r\npublic inline fun <K, M : MutableMap<in K, in Double>> DoubleArray.associateByTo(destination: M, keySelector: (Double) -> K): M {\r\n    for (element in this) {\r\n        destination.put(keySelector(element), element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Populates and returns the [destination] mutable map with key-value pairs,\r\n * where key is provided by the [keySelector] function applied to each element of the given array\r\n * and value is the element itself.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n */\r\npublic inline fun <K, M : MutableMap<in K, in Boolean>> BooleanArray.associateByTo(destination: M, keySelector: (Boolean) -> K): M {\r\n    for (element in this) {\r\n        destination.put(keySelector(element), element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Populates and returns the [destination] mutable map with key-value pairs,\r\n * where key is provided by the [keySelector] function applied to each element of the given array\r\n * and value is the element itself.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n */\r\npublic inline fun <K, M : MutableMap<in K, in Char>> CharArray.associateByTo(destination: M, keySelector: (Char) -> K): M {\r\n    for (element in this) {\r\n        destination.put(keySelector(element), element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Populates and returns the [destination] mutable map with key-value pairs,\r\n * where key is provided by the [keySelector] function and\r\n * and value is provided by the [valueTransform] function applied to elements of the given array.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n */\r\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\r\n    for (element in this) {\r\n        destination.put(keySelector(element), valueTransform(element))\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Populates and returns the [destination] mutable map with key-value pairs,\r\n * where key is provided by the [keySelector] function and\r\n * and value is provided by the [valueTransform] function applied to elements of the given array.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n */\r\npublic inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateByTo(destination: M, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M {\r\n    for (element in this) {\r\n        destination.put(keySelector(element), valueTransform(element))\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Populates and returns the [destination] mutable map with key-value pairs,\r\n * where key is provided by the [keySelector] function and\r\n * and value is provided by the [valueTransform] function applied to elements of the given array.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n */\r\npublic inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateByTo(destination: M, keySelector: (Short) -> K, valueTransform: (Short) -> V): M {\r\n    for (element in this) {\r\n        destination.put(keySelector(element), valueTransform(element))\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Populates and returns the [destination] mutable map with key-value pairs,\r\n * where key is provided by the [keySelector] function and\r\n * and value is provided by the [valueTransform] function applied to elements of the given array.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n */\r\npublic inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateByTo(destination: M, keySelector: (Int) -> K, valueTransform: (Int) -> V): M {\r\n    for (element in this) {\r\n        destination.put(keySelector(element), valueTransform(element))\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Populates and returns the [destination] mutable map with key-value pairs,\r\n * where key is provided by the [keySelector] function and\r\n * and value is provided by the [valueTransform] function applied to elements of the given array.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n */\r\npublic inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateByTo(destination: M, keySelector: (Long) -> K, valueTransform: (Long) -> V): M {\r\n    for (element in this) {\r\n        destination.put(keySelector(element), valueTransform(element))\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Populates and returns the [destination] mutable map with key-value pairs,\r\n * where key is provided by the [keySelector] function and\r\n * and value is provided by the [valueTransform] function applied to elements of the given array.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n */\r\npublic inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateByTo(destination: M, keySelector: (Float) -> K, valueTransform: (Float) -> V): M {\r\n    for (element in this) {\r\n        destination.put(keySelector(element), valueTransform(element))\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Populates and returns the [destination] mutable map with key-value pairs,\r\n * where key is provided by the [keySelector] function and\r\n * and value is provided by the [valueTransform] function applied to elements of the given array.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n */\r\npublic inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateByTo(destination: M, keySelector: (Double) -> K, valueTransform: (Double) -> V): M {\r\n    for (element in this) {\r\n        destination.put(keySelector(element), valueTransform(element))\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Populates and returns the [destination] mutable map with key-value pairs,\r\n * where key is provided by the [keySelector] function and\r\n * and value is provided by the [valueTransform] function applied to elements of the given array.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n */\r\npublic inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateByTo(destination: M, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M {\r\n    for (element in this) {\r\n        destination.put(keySelector(element), valueTransform(element))\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Populates and returns the [destination] mutable map with key-value pairs,\r\n * where key is provided by the [keySelector] function and\r\n * and value is provided by the [valueTransform] function applied to elements of the given array.\r\n * \r\n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\r\n */\r\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\r\n    for (element in this) {\r\n        destination.put(keySelector(element), valueTransform(element))\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Populates and returns the [destination] mutable map with key-value pairs\r\n * provided by [transform] function applied to each element of the given array.\r\n * \r\n * If any of two pairs would have the same key the last one gets added to the map.\r\n */\r\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\r\n    for (element in this) {\r\n        destination += transform(element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Populates and returns the [destination] mutable map with key-value pairs\r\n * provided by [transform] function applied to each element of the given array.\r\n * \r\n * If any of two pairs would have the same key the last one gets added to the map.\r\n */\r\npublic inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateTo(destination: M, transform: (Byte) -> Pair<K, V>): M {\r\n    for (element in this) {\r\n        destination += transform(element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Populates and returns the [destination] mutable map with key-value pairs\r\n * provided by [transform] function applied to each element of the given array.\r\n * \r\n * If any of two pairs would have the same key the last one gets added to the map.\r\n */\r\npublic inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateTo(destination: M, transform: (Short) -> Pair<K, V>): M {\r\n    for (element in this) {\r\n        destination += transform(element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Populates and returns the [destination] mutable map with key-value pairs\r\n * provided by [transform] function applied to each element of the given array.\r\n * \r\n * If any of two pairs would have the same key the last one gets added to the map.\r\n */\r\npublic inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateTo(destination: M, transform: (Int) -> Pair<K, V>): M {\r\n    for (element in this) {\r\n        destination += transform(element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Populates and returns the [destination] mutable map with key-value pairs\r\n * provided by [transform] function applied to each element of the given array.\r\n * \r\n * If any of two pairs would have the same key the last one gets added to the map.\r\n */\r\npublic inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateTo(destination: M, transform: (Long) -> Pair<K, V>): M {\r\n    for (element in this) {\r\n        destination += transform(element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Populates and returns the [destination] mutable map with key-value pairs\r\n * provided by [transform] function applied to each element of the given array.\r\n * \r\n * If any of two pairs would have the same key the last one gets added to the map.\r\n */\r\npublic inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateTo(destination: M, transform: (Float) -> Pair<K, V>): M {\r\n    for (element in this) {\r\n        destination += transform(element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Populates and returns the [destination] mutable map with key-value pairs\r\n * provided by [transform] function applied to each element of the given array.\r\n * \r\n * If any of two pairs would have the same key the last one gets added to the map.\r\n */\r\npublic inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateTo(destination: M, transform: (Double) -> Pair<K, V>): M {\r\n    for (element in this) {\r\n        destination += transform(element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Populates and returns the [destination] mutable map with key-value pairs\r\n * provided by [transform] function applied to each element of the given array.\r\n * \r\n * If any of two pairs would have the same key the last one gets added to the map.\r\n */\r\npublic inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateTo(destination: M, transform: (Boolean) -> Pair<K, V>): M {\r\n    for (element in this) {\r\n        destination += transform(element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Populates and returns the [destination] mutable map with key-value pairs\r\n * provided by [transform] function applied to each element of the given array.\r\n * \r\n * If any of two pairs would have the same key the last one gets added to the map.\r\n */\r\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateTo(destination: M, transform: (Char) -> Pair<K, V>): M {\r\n    for (element in this) {\r\n        destination += transform(element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements to the given [destination] collection.\r\n */\r\npublic fun <T, C : MutableCollection<in T>> Array<out T>.toCollection(destination: C): C {\r\n    for (item in this) {\r\n        destination.add(item)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements to the given [destination] collection.\r\n */\r\npublic fun <C : MutableCollection<in Byte>> ByteArray.toCollection(destination: C): C {\r\n    for (item in this) {\r\n        destination.add(item)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements to the given [destination] collection.\r\n */\r\npublic fun <C : MutableCollection<in Short>> ShortArray.toCollection(destination: C): C {\r\n    for (item in this) {\r\n        destination.add(item)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements to the given [destination] collection.\r\n */\r\npublic fun <C : MutableCollection<in Int>> IntArray.toCollection(destination: C): C {\r\n    for (item in this) {\r\n        destination.add(item)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements to the given [destination] collection.\r\n */\r\npublic fun <C : MutableCollection<in Long>> LongArray.toCollection(destination: C): C {\r\n    for (item in this) {\r\n        destination.add(item)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements to the given [destination] collection.\r\n */\r\npublic fun <C : MutableCollection<in Float>> FloatArray.toCollection(destination: C): C {\r\n    for (item in this) {\r\n        destination.add(item)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements to the given [destination] collection.\r\n */\r\npublic fun <C : MutableCollection<in Double>> DoubleArray.toCollection(destination: C): C {\r\n    for (item in this) {\r\n        destination.add(item)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements to the given [destination] collection.\r\n */\r\npublic fun <C : MutableCollection<in Boolean>> BooleanArray.toCollection(destination: C): C {\r\n    for (item in this) {\r\n        destination.add(item)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements to the given [destination] collection.\r\n */\r\npublic fun <C : MutableCollection<in Char>> CharArray.toCollection(destination: C): C {\r\n    for (item in this) {\r\n        destination.add(item)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Returns a [HashSet] of all elements.\r\n */\r\npublic fun <T> Array<out T>.toHashSet(): HashSet<T> {\r\n    return toCollection(HashSet<T>(mapCapacity(size)))\r\n}\r\n\r\n/**\r\n * Returns a [HashSet] of all elements.\r\n */\r\npublic fun ByteArray.toHashSet(): HashSet<Byte> {\r\n    return toCollection(HashSet<Byte>(mapCapacity(size)))\r\n}\r\n\r\n/**\r\n * Returns a [HashSet] of all elements.\r\n */\r\npublic fun ShortArray.toHashSet(): HashSet<Short> {\r\n    return toCollection(HashSet<Short>(mapCapacity(size)))\r\n}\r\n\r\n/**\r\n * Returns a [HashSet] of all elements.\r\n */\r\npublic fun IntArray.toHashSet(): HashSet<Int> {\r\n    return toCollection(HashSet<Int>(mapCapacity(size)))\r\n}\r\n\r\n/**\r\n * Returns a [HashSet] of all elements.\r\n */\r\npublic fun LongArray.toHashSet(): HashSet<Long> {\r\n    return toCollection(HashSet<Long>(mapCapacity(size)))\r\n}\r\n\r\n/**\r\n * Returns a [HashSet] of all elements.\r\n */\r\npublic fun FloatArray.toHashSet(): HashSet<Float> {\r\n    return toCollection(HashSet<Float>(mapCapacity(size)))\r\n}\r\n\r\n/**\r\n * Returns a [HashSet] of all elements.\r\n */\r\npublic fun DoubleArray.toHashSet(): HashSet<Double> {\r\n    return toCollection(HashSet<Double>(mapCapacity(size)))\r\n}\r\n\r\n/**\r\n * Returns a [HashSet] of all elements.\r\n */\r\npublic fun BooleanArray.toHashSet(): HashSet<Boolean> {\r\n    return toCollection(HashSet<Boolean>(mapCapacity(size)))\r\n}\r\n\r\n/**\r\n * Returns a [HashSet] of all elements.\r\n */\r\npublic fun CharArray.toHashSet(): HashSet<Char> {\r\n    return toCollection(HashSet<Char>(mapCapacity(size)))\r\n}\r\n\r\n/**\r\n * Returns a [List] containing all elements.\r\n */\r\npublic fun <T> Array<out T>.toList(): List<T> {\r\n    return when (size) {\r\n        0 -> emptyList()\r\n        1 -> listOf(this[0])\r\n        else -> this.toMutableList()\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a [List] containing all elements.\r\n */\r\npublic fun ByteArray.toList(): List<Byte> {\r\n    return when (size) {\r\n        0 -> emptyList()\r\n        1 -> listOf(this[0])\r\n        else -> this.toMutableList()\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a [List] containing all elements.\r\n */\r\npublic fun ShortArray.toList(): List<Short> {\r\n    return when (size) {\r\n        0 -> emptyList()\r\n        1 -> listOf(this[0])\r\n        else -> this.toMutableList()\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a [List] containing all elements.\r\n */\r\npublic fun IntArray.toList(): List<Int> {\r\n    return when (size) {\r\n        0 -> emptyList()\r\n        1 -> listOf(this[0])\r\n        else -> this.toMutableList()\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a [List] containing all elements.\r\n */\r\npublic fun LongArray.toList(): List<Long> {\r\n    return when (size) {\r\n        0 -> emptyList()\r\n        1 -> listOf(this[0])\r\n        else -> this.toMutableList()\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a [List] containing all elements.\r\n */\r\npublic fun FloatArray.toList(): List<Float> {\r\n    return when (size) {\r\n        0 -> emptyList()\r\n        1 -> listOf(this[0])\r\n        else -> this.toMutableList()\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a [List] containing all elements.\r\n */\r\npublic fun DoubleArray.toList(): List<Double> {\r\n    return when (size) {\r\n        0 -> emptyList()\r\n        1 -> listOf(this[0])\r\n        else -> this.toMutableList()\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a [List] containing all elements.\r\n */\r\npublic fun BooleanArray.toList(): List<Boolean> {\r\n    return when (size) {\r\n        0 -> emptyList()\r\n        1 -> listOf(this[0])\r\n        else -> this.toMutableList()\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a [List] containing all elements.\r\n */\r\npublic fun CharArray.toList(): List<Char> {\r\n    return when (size) {\r\n        0 -> emptyList()\r\n        1 -> listOf(this[0])\r\n        else -> this.toMutableList()\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a [MutableList] filled with all elements of this array.\r\n */\r\npublic fun <T> Array<out T>.toMutableList(): MutableList<T> {\r\n    return ArrayList(this.asCollection())\r\n}\r\n\r\n/**\r\n * Returns a [MutableList] filled with all elements of this array.\r\n */\r\npublic fun ByteArray.toMutableList(): MutableList<Byte> {\r\n    val list = ArrayList<Byte>(size)\r\n    for (item in this) list.add(item)\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a [MutableList] filled with all elements of this array.\r\n */\r\npublic fun ShortArray.toMutableList(): MutableList<Short> {\r\n    val list = ArrayList<Short>(size)\r\n    for (item in this) list.add(item)\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a [MutableList] filled with all elements of this array.\r\n */\r\npublic fun IntArray.toMutableList(): MutableList<Int> {\r\n    val list = ArrayList<Int>(size)\r\n    for (item in this) list.add(item)\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a [MutableList] filled with all elements of this array.\r\n */\r\npublic fun LongArray.toMutableList(): MutableList<Long> {\r\n    val list = ArrayList<Long>(size)\r\n    for (item in this) list.add(item)\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a [MutableList] filled with all elements of this array.\r\n */\r\npublic fun FloatArray.toMutableList(): MutableList<Float> {\r\n    val list = ArrayList<Float>(size)\r\n    for (item in this) list.add(item)\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a [MutableList] filled with all elements of this array.\r\n */\r\npublic fun DoubleArray.toMutableList(): MutableList<Double> {\r\n    val list = ArrayList<Double>(size)\r\n    for (item in this) list.add(item)\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a [MutableList] filled with all elements of this array.\r\n */\r\npublic fun BooleanArray.toMutableList(): MutableList<Boolean> {\r\n    val list = ArrayList<Boolean>(size)\r\n    for (item in this) list.add(item)\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a [MutableList] filled with all elements of this array.\r\n */\r\npublic fun CharArray.toMutableList(): MutableList<Char> {\r\n    val list = ArrayList<Char>(size)\r\n    for (item in this) list.add(item)\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a [Set] of all elements.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic fun <T> Array<out T>.toSet(): Set<T> {\r\n    return when (size) {\r\n        0 -> emptySet()\r\n        1 -> setOf(this[0])\r\n        else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a [Set] of all elements.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic fun ByteArray.toSet(): Set<Byte> {\r\n    return when (size) {\r\n        0 -> emptySet()\r\n        1 -> setOf(this[0])\r\n        else -> toCollection(LinkedHashSet<Byte>(mapCapacity(size)))\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a [Set] of all elements.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic fun ShortArray.toSet(): Set<Short> {\r\n    return when (size) {\r\n        0 -> emptySet()\r\n        1 -> setOf(this[0])\r\n        else -> toCollection(LinkedHashSet<Short>(mapCapacity(size)))\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a [Set] of all elements.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic fun IntArray.toSet(): Set<Int> {\r\n    return when (size) {\r\n        0 -> emptySet()\r\n        1 -> setOf(this[0])\r\n        else -> toCollection(LinkedHashSet<Int>(mapCapacity(size)))\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a [Set] of all elements.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic fun LongArray.toSet(): Set<Long> {\r\n    return when (size) {\r\n        0 -> emptySet()\r\n        1 -> setOf(this[0])\r\n        else -> toCollection(LinkedHashSet<Long>(mapCapacity(size)))\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a [Set] of all elements.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic fun FloatArray.toSet(): Set<Float> {\r\n    return when (size) {\r\n        0 -> emptySet()\r\n        1 -> setOf(this[0])\r\n        else -> toCollection(LinkedHashSet<Float>(mapCapacity(size)))\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a [Set] of all elements.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic fun DoubleArray.toSet(): Set<Double> {\r\n    return when (size) {\r\n        0 -> emptySet()\r\n        1 -> setOf(this[0])\r\n        else -> toCollection(LinkedHashSet<Double>(mapCapacity(size)))\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a [Set] of all elements.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic fun BooleanArray.toSet(): Set<Boolean> {\r\n    return when (size) {\r\n        0 -> emptySet()\r\n        1 -> setOf(this[0])\r\n        else -> toCollection(LinkedHashSet<Boolean>(mapCapacity(size)))\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a [Set] of all elements.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic fun CharArray.toSet(): Set<Char> {\r\n    return when (size) {\r\n        0 -> emptySet()\r\n        1 -> setOf(this[0])\r\n        else -> toCollection(LinkedHashSet<Char>(mapCapacity(size)))\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\r\n */\r\npublic inline fun <T, R> Array<out T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\r\n    return flatMapTo(ArrayList<R>(), transform)\r\n}\r\n\r\n/**\r\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\r\n */\r\npublic inline fun <R> ByteArray.flatMap(transform: (Byte) -> Iterable<R>): List<R> {\r\n    return flatMapTo(ArrayList<R>(), transform)\r\n}\r\n\r\n/**\r\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\r\n */\r\npublic inline fun <R> ShortArray.flatMap(transform: (Short) -> Iterable<R>): List<R> {\r\n    return flatMapTo(ArrayList<R>(), transform)\r\n}\r\n\r\n/**\r\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\r\n */\r\npublic inline fun <R> IntArray.flatMap(transform: (Int) -> Iterable<R>): List<R> {\r\n    return flatMapTo(ArrayList<R>(), transform)\r\n}\r\n\r\n/**\r\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\r\n */\r\npublic inline fun <R> LongArray.flatMap(transform: (Long) -> Iterable<R>): List<R> {\r\n    return flatMapTo(ArrayList<R>(), transform)\r\n}\r\n\r\n/**\r\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\r\n */\r\npublic inline fun <R> FloatArray.flatMap(transform: (Float) -> Iterable<R>): List<R> {\r\n    return flatMapTo(ArrayList<R>(), transform)\r\n}\r\n\r\n/**\r\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\r\n */\r\npublic inline fun <R> DoubleArray.flatMap(transform: (Double) -> Iterable<R>): List<R> {\r\n    return flatMapTo(ArrayList<R>(), transform)\r\n}\r\n\r\n/**\r\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\r\n */\r\npublic inline fun <R> BooleanArray.flatMap(transform: (Boolean) -> Iterable<R>): List<R> {\r\n    return flatMapTo(ArrayList<R>(), transform)\r\n}\r\n\r\n/**\r\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\r\n */\r\npublic inline fun <R> CharArray.flatMap(transform: (Char) -> Iterable<R>): List<R> {\r\n    return flatMapTo(ArrayList<R>(), transform)\r\n}\r\n\r\n/**\r\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\r\n */\r\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\r\n    for (element in this) {\r\n        val list = transform(element)\r\n        destination.addAll(list)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\r\n */\r\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.flatMapTo(destination: C, transform: (Byte) -> Iterable<R>): C {\r\n    for (element in this) {\r\n        val list = transform(element)\r\n        destination.addAll(list)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\r\n */\r\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.flatMapTo(destination: C, transform: (Short) -> Iterable<R>): C {\r\n    for (element in this) {\r\n        val list = transform(element)\r\n        destination.addAll(list)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\r\n */\r\npublic inline fun <R, C : MutableCollection<in R>> IntArray.flatMapTo(destination: C, transform: (Int) -> Iterable<R>): C {\r\n    for (element in this) {\r\n        val list = transform(element)\r\n        destination.addAll(list)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\r\n */\r\npublic inline fun <R, C : MutableCollection<in R>> LongArray.flatMapTo(destination: C, transform: (Long) -> Iterable<R>): C {\r\n    for (element in this) {\r\n        val list = transform(element)\r\n        destination.addAll(list)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\r\n */\r\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.flatMapTo(destination: C, transform: (Float) -> Iterable<R>): C {\r\n    for (element in this) {\r\n        val list = transform(element)\r\n        destination.addAll(list)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\r\n */\r\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.flatMapTo(destination: C, transform: (Double) -> Iterable<R>): C {\r\n    for (element in this) {\r\n        val list = transform(element)\r\n        destination.addAll(list)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\r\n */\r\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.flatMapTo(destination: C, transform: (Boolean) -> Iterable<R>): C {\r\n    for (element in this) {\r\n        val list = transform(element)\r\n        destination.addAll(list)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\r\n */\r\npublic inline fun <R, C : MutableCollection<in R>> CharArray.flatMapTo(destination: C, transform: (Char) -> Iterable<R>): C {\r\n    for (element in this) {\r\n        val list = transform(element)\r\n        destination.addAll(list)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Groups elements of the original array by the key returned by the given [keySelector] function\r\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\r\n * \r\n * The returned map preserves the entry iteration order of the keys produced from the original array.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupBy\r\n */\r\npublic inline fun <T, K> Array<out T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\r\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\r\n}\r\n\r\n/**\r\n * Groups elements of the original array by the key returned by the given [keySelector] function\r\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\r\n * \r\n * The returned map preserves the entry iteration order of the keys produced from the original array.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupBy\r\n */\r\npublic inline fun <K> ByteArray.groupBy(keySelector: (Byte) -> K): Map<K, List<Byte>> {\r\n    return groupByTo(LinkedHashMap<K, MutableList<Byte>>(), keySelector)\r\n}\r\n\r\n/**\r\n * Groups elements of the original array by the key returned by the given [keySelector] function\r\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\r\n * \r\n * The returned map preserves the entry iteration order of the keys produced from the original array.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupBy\r\n */\r\npublic inline fun <K> ShortArray.groupBy(keySelector: (Short) -> K): Map<K, List<Short>> {\r\n    return groupByTo(LinkedHashMap<K, MutableList<Short>>(), keySelector)\r\n}\r\n\r\n/**\r\n * Groups elements of the original array by the key returned by the given [keySelector] function\r\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\r\n * \r\n * The returned map preserves the entry iteration order of the keys produced from the original array.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupBy\r\n */\r\npublic inline fun <K> IntArray.groupBy(keySelector: (Int) -> K): Map<K, List<Int>> {\r\n    return groupByTo(LinkedHashMap<K, MutableList<Int>>(), keySelector)\r\n}\r\n\r\n/**\r\n * Groups elements of the original array by the key returned by the given [keySelector] function\r\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\r\n * \r\n * The returned map preserves the entry iteration order of the keys produced from the original array.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupBy\r\n */\r\npublic inline fun <K> LongArray.groupBy(keySelector: (Long) -> K): Map<K, List<Long>> {\r\n    return groupByTo(LinkedHashMap<K, MutableList<Long>>(), keySelector)\r\n}\r\n\r\n/**\r\n * Groups elements of the original array by the key returned by the given [keySelector] function\r\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\r\n * \r\n * The returned map preserves the entry iteration order of the keys produced from the original array.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupBy\r\n */\r\npublic inline fun <K> FloatArray.groupBy(keySelector: (Float) -> K): Map<K, List<Float>> {\r\n    return groupByTo(LinkedHashMap<K, MutableList<Float>>(), keySelector)\r\n}\r\n\r\n/**\r\n * Groups elements of the original array by the key returned by the given [keySelector] function\r\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\r\n * \r\n * The returned map preserves the entry iteration order of the keys produced from the original array.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupBy\r\n */\r\npublic inline fun <K> DoubleArray.groupBy(keySelector: (Double) -> K): Map<K, List<Double>> {\r\n    return groupByTo(LinkedHashMap<K, MutableList<Double>>(), keySelector)\r\n}\r\n\r\n/**\r\n * Groups elements of the original array by the key returned by the given [keySelector] function\r\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\r\n * \r\n * The returned map preserves the entry iteration order of the keys produced from the original array.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupBy\r\n */\r\npublic inline fun <K> BooleanArray.groupBy(keySelector: (Boolean) -> K): Map<K, List<Boolean>> {\r\n    return groupByTo(LinkedHashMap<K, MutableList<Boolean>>(), keySelector)\r\n}\r\n\r\n/**\r\n * Groups elements of the original array by the key returned by the given [keySelector] function\r\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\r\n * \r\n * The returned map preserves the entry iteration order of the keys produced from the original array.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupBy\r\n */\r\npublic inline fun <K> CharArray.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> {\r\n    return groupByTo(LinkedHashMap<K, MutableList<Char>>(), keySelector)\r\n}\r\n\r\n/**\r\n * Groups values returned by the [valueTransform] function applied to each element of the original array\r\n * by the key returned by the given [keySelector] function applied to the element\r\n * and returns a map where each group key is associated with a list of corresponding values.\r\n * \r\n * The returned map preserves the entry iteration order of the keys produced from the original array.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\r\n */\r\npublic inline fun <T, K, V> Array<out T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\r\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\r\n}\r\n\r\n/**\r\n * Groups values returned by the [valueTransform] function applied to each element of the original array\r\n * by the key returned by the given [keySelector] function applied to the element\r\n * and returns a map where each group key is associated with a list of corresponding values.\r\n * \r\n * The returned map preserves the entry iteration order of the keys produced from the original array.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\r\n */\r\npublic inline fun <K, V> ByteArray.groupBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, List<V>> {\r\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\r\n}\r\n\r\n/**\r\n * Groups values returned by the [valueTransform] function applied to each element of the original array\r\n * by the key returned by the given [keySelector] function applied to the element\r\n * and returns a map where each group key is associated with a list of corresponding values.\r\n * \r\n * The returned map preserves the entry iteration order of the keys produced from the original array.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\r\n */\r\npublic inline fun <K, V> ShortArray.groupBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, List<V>> {\r\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\r\n}\r\n\r\n/**\r\n * Groups values returned by the [valueTransform] function applied to each element of the original array\r\n * by the key returned by the given [keySelector] function applied to the element\r\n * and returns a map where each group key is associated with a list of corresponding values.\r\n * \r\n * The returned map preserves the entry iteration order of the keys produced from the original array.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\r\n */\r\npublic inline fun <K, V> IntArray.groupBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, List<V>> {\r\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\r\n}\r\n\r\n/**\r\n * Groups values returned by the [valueTransform] function applied to each element of the original array\r\n * by the key returned by the given [keySelector] function applied to the element\r\n * and returns a map where each group key is associated with a list of corresponding values.\r\n * \r\n * The returned map preserves the entry iteration order of the keys produced from the original array.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\r\n */\r\npublic inline fun <K, V> LongArray.groupBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, List<V>> {\r\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\r\n}\r\n\r\n/**\r\n * Groups values returned by the [valueTransform] function applied to each element of the original array\r\n * by the key returned by the given [keySelector] function applied to the element\r\n * and returns a map where each group key is associated with a list of corresponding values.\r\n * \r\n * The returned map preserves the entry iteration order of the keys produced from the original array.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\r\n */\r\npublic inline fun <K, V> FloatArray.groupBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, List<V>> {\r\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\r\n}\r\n\r\n/**\r\n * Groups values returned by the [valueTransform] function applied to each element of the original array\r\n * by the key returned by the given [keySelector] function applied to the element\r\n * and returns a map where each group key is associated with a list of corresponding values.\r\n * \r\n * The returned map preserves the entry iteration order of the keys produced from the original array.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\r\n */\r\npublic inline fun <K, V> DoubleArray.groupBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, List<V>> {\r\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\r\n}\r\n\r\n/**\r\n * Groups values returned by the [valueTransform] function applied to each element of the original array\r\n * by the key returned by the given [keySelector] function applied to the element\r\n * and returns a map where each group key is associated with a list of corresponding values.\r\n * \r\n * The returned map preserves the entry iteration order of the keys produced from the original array.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\r\n */\r\npublic inline fun <K, V> BooleanArray.groupBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, List<V>> {\r\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\r\n}\r\n\r\n/**\r\n * Groups values returned by the [valueTransform] function applied to each element of the original array\r\n * by the key returned by the given [keySelector] function applied to the element\r\n * and returns a map where each group key is associated with a list of corresponding values.\r\n * \r\n * The returned map preserves the entry iteration order of the keys produced from the original array.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\r\n */\r\npublic inline fun <K, V> CharArray.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>> {\r\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\r\n}\r\n\r\n/**\r\n * Groups elements of the original array by the key returned by the given [keySelector] function\r\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\r\n * \r\n * @return The [destination] map.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupBy\r\n */\r\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Array<out T>.groupByTo(destination: M, keySelector: (T) -> K): M {\r\n    for (element in this) {\r\n        val key = keySelector(element)\r\n        val list = destination.getOrPut(key) { ArrayList<T>() }\r\n        list.add(element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Groups elements of the original array by the key returned by the given [keySelector] function\r\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\r\n * \r\n * @return The [destination] map.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupBy\r\n */\r\npublic inline fun <K, M : MutableMap<in K, MutableList<Byte>>> ByteArray.groupByTo(destination: M, keySelector: (Byte) -> K): M {\r\n    for (element in this) {\r\n        val key = keySelector(element)\r\n        val list = destination.getOrPut(key) { ArrayList<Byte>() }\r\n        list.add(element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Groups elements of the original array by the key returned by the given [keySelector] function\r\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\r\n * \r\n * @return The [destination] map.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupBy\r\n */\r\npublic inline fun <K, M : MutableMap<in K, MutableList<Short>>> ShortArray.groupByTo(destination: M, keySelector: (Short) -> K): M {\r\n    for (element in this) {\r\n        val key = keySelector(element)\r\n        val list = destination.getOrPut(key) { ArrayList<Short>() }\r\n        list.add(element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Groups elements of the original array by the key returned by the given [keySelector] function\r\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\r\n * \r\n * @return The [destination] map.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupBy\r\n */\r\npublic inline fun <K, M : MutableMap<in K, MutableList<Int>>> IntArray.groupByTo(destination: M, keySelector: (Int) -> K): M {\r\n    for (element in this) {\r\n        val key = keySelector(element)\r\n        val list = destination.getOrPut(key) { ArrayList<Int>() }\r\n        list.add(element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Groups elements of the original array by the key returned by the given [keySelector] function\r\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\r\n * \r\n * @return The [destination] map.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupBy\r\n */\r\npublic inline fun <K, M : MutableMap<in K, MutableList<Long>>> LongArray.groupByTo(destination: M, keySelector: (Long) -> K): M {\r\n    for (element in this) {\r\n        val key = keySelector(element)\r\n        val list = destination.getOrPut(key) { ArrayList<Long>() }\r\n        list.add(element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Groups elements of the original array by the key returned by the given [keySelector] function\r\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\r\n * \r\n * @return The [destination] map.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupBy\r\n */\r\npublic inline fun <K, M : MutableMap<in K, MutableList<Float>>> FloatArray.groupByTo(destination: M, keySelector: (Float) -> K): M {\r\n    for (element in this) {\r\n        val key = keySelector(element)\r\n        val list = destination.getOrPut(key) { ArrayList<Float>() }\r\n        list.add(element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Groups elements of the original array by the key returned by the given [keySelector] function\r\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\r\n * \r\n * @return The [destination] map.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupBy\r\n */\r\npublic inline fun <K, M : MutableMap<in K, MutableList<Double>>> DoubleArray.groupByTo(destination: M, keySelector: (Double) -> K): M {\r\n    for (element in this) {\r\n        val key = keySelector(element)\r\n        val list = destination.getOrPut(key) { ArrayList<Double>() }\r\n        list.add(element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Groups elements of the original array by the key returned by the given [keySelector] function\r\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\r\n * \r\n * @return The [destination] map.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupBy\r\n */\r\npublic inline fun <K, M : MutableMap<in K, MutableList<Boolean>>> BooleanArray.groupByTo(destination: M, keySelector: (Boolean) -> K): M {\r\n    for (element in this) {\r\n        val key = keySelector(element)\r\n        val list = destination.getOrPut(key) { ArrayList<Boolean>() }\r\n        list.add(element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Groups elements of the original array by the key returned by the given [keySelector] function\r\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\r\n * \r\n * @return The [destination] map.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupBy\r\n */\r\npublic inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharArray.groupByTo(destination: M, keySelector: (Char) -> K): M {\r\n    for (element in this) {\r\n        val key = keySelector(element)\r\n        val list = destination.getOrPut(key) { ArrayList<Char>() }\r\n        list.add(element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Groups values returned by the [valueTransform] function applied to each element of the original array\r\n * by the key returned by the given [keySelector] function applied to the element\r\n * and puts to the [destination] map each group key associated with a list of corresponding values.\r\n * \r\n * @return The [destination] map.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\r\n */\r\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Array<out T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\r\n    for (element in this) {\r\n        val key = keySelector(element)\r\n        val list = destination.getOrPut(key) { ArrayList<V>() }\r\n        list.add(valueTransform(element))\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Groups values returned by the [valueTransform] function applied to each element of the original array\r\n * by the key returned by the given [keySelector] function applied to the element\r\n * and puts to the [destination] map each group key associated with a list of corresponding values.\r\n * \r\n * @return The [destination] map.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\r\n */\r\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ByteArray.groupByTo(destination: M, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M {\r\n    for (element in this) {\r\n        val key = keySelector(element)\r\n        val list = destination.getOrPut(key) { ArrayList<V>() }\r\n        list.add(valueTransform(element))\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Groups values returned by the [valueTransform] function applied to each element of the original array\r\n * by the key returned by the given [keySelector] function applied to the element\r\n * and puts to the [destination] map each group key associated with a list of corresponding values.\r\n * \r\n * @return The [destination] map.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\r\n */\r\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ShortArray.groupByTo(destination: M, keySelector: (Short) -> K, valueTransform: (Short) -> V): M {\r\n    for (element in this) {\r\n        val key = keySelector(element)\r\n        val list = destination.getOrPut(key) { ArrayList<V>() }\r\n        list.add(valueTransform(element))\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Groups values returned by the [valueTransform] function applied to each element of the original array\r\n * by the key returned by the given [keySelector] function applied to the element\r\n * and puts to the [destination] map each group key associated with a list of corresponding values.\r\n * \r\n * @return The [destination] map.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\r\n */\r\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> IntArray.groupByTo(destination: M, keySelector: (Int) -> K, valueTransform: (Int) -> V): M {\r\n    for (element in this) {\r\n        val key = keySelector(element)\r\n        val list = destination.getOrPut(key) { ArrayList<V>() }\r\n        list.add(valueTransform(element))\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Groups values returned by the [valueTransform] function applied to each element of the original array\r\n * by the key returned by the given [keySelector] function applied to the element\r\n * and puts to the [destination] map each group key associated with a list of corresponding values.\r\n * \r\n * @return The [destination] map.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\r\n */\r\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> LongArray.groupByTo(destination: M, keySelector: (Long) -> K, valueTransform: (Long) -> V): M {\r\n    for (element in this) {\r\n        val key = keySelector(element)\r\n        val list = destination.getOrPut(key) { ArrayList<V>() }\r\n        list.add(valueTransform(element))\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Groups values returned by the [valueTransform] function applied to each element of the original array\r\n * by the key returned by the given [keySelector] function applied to the element\r\n * and puts to the [destination] map each group key associated with a list of corresponding values.\r\n * \r\n * @return The [destination] map.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\r\n */\r\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> FloatArray.groupByTo(destination: M, keySelector: (Float) -> K, valueTransform: (Float) -> V): M {\r\n    for (element in this) {\r\n        val key = keySelector(element)\r\n        val list = destination.getOrPut(key) { ArrayList<V>() }\r\n        list.add(valueTransform(element))\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Groups values returned by the [valueTransform] function applied to each element of the original array\r\n * by the key returned by the given [keySelector] function applied to the element\r\n * and puts to the [destination] map each group key associated with a list of corresponding values.\r\n * \r\n * @return The [destination] map.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\r\n */\r\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> DoubleArray.groupByTo(destination: M, keySelector: (Double) -> K, valueTransform: (Double) -> V): M {\r\n    for (element in this) {\r\n        val key = keySelector(element)\r\n        val list = destination.getOrPut(key) { ArrayList<V>() }\r\n        list.add(valueTransform(element))\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Groups values returned by the [valueTransform] function applied to each element of the original array\r\n * by the key returned by the given [keySelector] function applied to the element\r\n * and puts to the [destination] map each group key associated with a list of corresponding values.\r\n * \r\n * @return The [destination] map.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\r\n */\r\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> BooleanArray.groupByTo(destination: M, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M {\r\n    for (element in this) {\r\n        val key = keySelector(element)\r\n        val list = destination.getOrPut(key) { ArrayList<V>() }\r\n        list.add(valueTransform(element))\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Groups values returned by the [valueTransform] function applied to each element of the original array\r\n * by the key returned by the given [keySelector] function applied to the element\r\n * and puts to the [destination] map each group key associated with a list of corresponding values.\r\n * \r\n * @return The [destination] map.\r\n * \r\n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\r\n */\r\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharArray.groupByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\r\n    for (element in this) {\r\n        val key = keySelector(element)\r\n        val list = destination.getOrPut(key) { ArrayList<V>() }\r\n        list.add(valueTransform(element))\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Creates a [Grouping] source from an array to be used later with one of group-and-fold operations\r\n * using the specified [keySelector] function to extract a key from each element.\r\n * \r\n * @sample samples.collections.Grouping.groupingByEachCount\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic inline fun <T, K> Array<out T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\r\n    return object : Grouping<T, K> {\r\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\r\n        override fun keyOf(element: T): K = keySelector(element)\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a list containing the results of applying the given [transform] function\r\n * to each element in the original array.\r\n */\r\npublic inline fun <T, R> Array<out T>.map(transform: (T) -> R): List<R> {\r\n    return mapTo(ArrayList<R>(size), transform)\r\n}\r\n\r\n/**\r\n * Returns a list containing the results of applying the given [transform] function\r\n * to each element in the original array.\r\n */\r\npublic inline fun <R> ByteArray.map(transform: (Byte) -> R): List<R> {\r\n    return mapTo(ArrayList<R>(size), transform)\r\n}\r\n\r\n/**\r\n * Returns a list containing the results of applying the given [transform] function\r\n * to each element in the original array.\r\n */\r\npublic inline fun <R> ShortArray.map(transform: (Short) -> R): List<R> {\r\n    return mapTo(ArrayList<R>(size), transform)\r\n}\r\n\r\n/**\r\n * Returns a list containing the results of applying the given [transform] function\r\n * to each element in the original array.\r\n */\r\npublic inline fun <R> IntArray.map(transform: (Int) -> R): List<R> {\r\n    return mapTo(ArrayList<R>(size), transform)\r\n}\r\n\r\n/**\r\n * Returns a list containing the results of applying the given [transform] function\r\n * to each element in the original array.\r\n */\r\npublic inline fun <R> LongArray.map(transform: (Long) -> R): List<R> {\r\n    return mapTo(ArrayList<R>(size), transform)\r\n}\r\n\r\n/**\r\n * Returns a list containing the results of applying the given [transform] function\r\n * to each element in the original array.\r\n */\r\npublic inline fun <R> FloatArray.map(transform: (Float) -> R): List<R> {\r\n    return mapTo(ArrayList<R>(size), transform)\r\n}\r\n\r\n/**\r\n * Returns a list containing the results of applying the given [transform] function\r\n * to each element in the original array.\r\n */\r\npublic inline fun <R> DoubleArray.map(transform: (Double) -> R): List<R> {\r\n    return mapTo(ArrayList<R>(size), transform)\r\n}\r\n\r\n/**\r\n * Returns a list containing the results of applying the given [transform] function\r\n * to each element in the original array.\r\n */\r\npublic inline fun <R> BooleanArray.map(transform: (Boolean) -> R): List<R> {\r\n    return mapTo(ArrayList<R>(size), transform)\r\n}\r\n\r\n/**\r\n * Returns a list containing the results of applying the given [transform] function\r\n * to each element in the original array.\r\n */\r\npublic inline fun <R> CharArray.map(transform: (Char) -> R): List<R> {\r\n    return mapTo(ArrayList<R>(size), transform)\r\n}\r\n\r\n/**\r\n * Returns a list containing the results of applying the given [transform] function\r\n * to each element and its index in the original array.\r\n * @param [transform] function that takes the index of an element and the element itself\r\n * and returns the result of the transform applied to the element.\r\n */\r\npublic inline fun <T, R> Array<out T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\r\n    return mapIndexedTo(ArrayList<R>(size), transform)\r\n}\r\n\r\n/**\r\n * Returns a list containing the results of applying the given [transform] function\r\n * to each element and its index in the original array.\r\n * @param [transform] function that takes the index of an element and the element itself\r\n * and returns the result of the transform applied to the element.\r\n */\r\npublic inline fun <R> ByteArray.mapIndexed(transform: (index: Int, Byte) -> R): List<R> {\r\n    return mapIndexedTo(ArrayList<R>(size), transform)\r\n}\r\n\r\n/**\r\n * Returns a list containing the results of applying the given [transform] function\r\n * to each element and its index in the original array.\r\n * @param [transform] function that takes the index of an element and the element itself\r\n * and returns the result of the transform applied to the element.\r\n */\r\npublic inline fun <R> ShortArray.mapIndexed(transform: (index: Int, Short) -> R): List<R> {\r\n    return mapIndexedTo(ArrayList<R>(size), transform)\r\n}\r\n\r\n/**\r\n * Returns a list containing the results of applying the given [transform] function\r\n * to each element and its index in the original array.\r\n * @param [transform] function that takes the index of an element and the element itself\r\n * and returns the result of the transform applied to the element.\r\n */\r\npublic inline fun <R> IntArray.mapIndexed(transform: (index: Int, Int) -> R): List<R> {\r\n    return mapIndexedTo(ArrayList<R>(size), transform)\r\n}\r\n\r\n/**\r\n * Returns a list containing the results of applying the given [transform] function\r\n * to each element and its index in the original array.\r\n * @param [transform] function that takes the index of an element and the element itself\r\n * and returns the result of the transform applied to the element.\r\n */\r\npublic inline fun <R> LongArray.mapIndexed(transform: (index: Int, Long) -> R): List<R> {\r\n    return mapIndexedTo(ArrayList<R>(size), transform)\r\n}\r\n\r\n/**\r\n * Returns a list containing the results of applying the given [transform] function\r\n * to each element and its index in the original array.\r\n * @param [transform] function that takes the index of an element and the element itself\r\n * and returns the result of the transform applied to the element.\r\n */\r\npublic inline fun <R> FloatArray.mapIndexed(transform: (index: Int, Float) -> R): List<R> {\r\n    return mapIndexedTo(ArrayList<R>(size), transform)\r\n}\r\n\r\n/**\r\n * Returns a list containing the results of applying the given [transform] function\r\n * to each element and its index in the original array.\r\n * @param [transform] function that takes the index of an element and the element itself\r\n * and returns the result of the transform applied to the element.\r\n */\r\npublic inline fun <R> DoubleArray.mapIndexed(transform: (index: Int, Double) -> R): List<R> {\r\n    return mapIndexedTo(ArrayList<R>(size), transform)\r\n}\r\n\r\n/**\r\n * Returns a list containing the results of applying the given [transform] function\r\n * to each element and its index in the original array.\r\n * @param [transform] function that takes the index of an element and the element itself\r\n * and returns the result of the transform applied to the element.\r\n */\r\npublic inline fun <R> BooleanArray.mapIndexed(transform: (index: Int, Boolean) -> R): List<R> {\r\n    return mapIndexedTo(ArrayList<R>(size), transform)\r\n}\r\n\r\n/**\r\n * Returns a list containing the results of applying the given [transform] function\r\n * to each element and its index in the original array.\r\n * @param [transform] function that takes the index of an element and the element itself\r\n * and returns the result of the transform applied to the element.\r\n */\r\npublic inline fun <R> CharArray.mapIndexed(transform: (index: Int, Char) -> R): List<R> {\r\n    return mapIndexedTo(ArrayList<R>(size), transform)\r\n}\r\n\r\n/**\r\n * Returns a list containing only the non-null results of applying the given [transform] function\r\n * to each element and its index in the original array.\r\n * @param [transform] function that takes the index of an element and the element itself\r\n * and returns the result of the transform applied to the element.\r\n */\r\npublic inline fun <T, R : Any> Array<out T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\r\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\r\n}\r\n\r\n/**\r\n * Applies the given [transform] function to each element and its index in the original array\r\n * and appends only the non-null results to the given [destination].\r\n * @param [transform] function that takes the index of an element and the element itself\r\n * and returns the result of the transform applied to the element.\r\n */\r\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Array<out T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\r\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Applies the given [transform] function to each element and its index in the original array\r\n * and appends the results to the given [destination].\r\n * @param [transform] function that takes the index of an element and the element itself\r\n * and returns the result of the transform applied to the element.\r\n */\r\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\r\n    var index = 0\r\n    for (item in this)\r\n        destination.add(transform(index++, item))\r\n    return destination\r\n}\r\n\r\n/**\r\n * Applies the given [transform] function to each element and its index in the original array\r\n * and appends the results to the given [destination].\r\n * @param [transform] function that takes the index of an element and the element itself\r\n * and returns the result of the transform applied to the element.\r\n */\r\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.mapIndexedTo(destination: C, transform: (index: Int, Byte) -> R): C {\r\n    var index = 0\r\n    for (item in this)\r\n        destination.add(transform(index++, item))\r\n    return destination\r\n}\r\n\r\n/**\r\n * Applies the given [transform] function to each element and its index in the original array\r\n * and appends the results to the given [destination].\r\n * @param [transform] function that takes the index of an element and the element itself\r\n * and returns the result of the transform applied to the element.\r\n */\r\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.mapIndexedTo(destination: C, transform: (index: Int, Short) -> R): C {\r\n    var index = 0\r\n    for (item in this)\r\n        destination.add(transform(index++, item))\r\n    return destination\r\n}\r\n\r\n/**\r\n * Applies the given [transform] function to each element and its index in the original array\r\n * and appends the results to the given [destination].\r\n * @param [transform] function that takes the index of an element and the element itself\r\n * and returns the result of the transform applied to the element.\r\n */\r\npublic inline fun <R, C : MutableCollection<in R>> IntArray.mapIndexedTo(destination: C, transform: (index: Int, Int) -> R): C {\r\n    var index = 0\r\n    for (item in this)\r\n        destination.add(transform(index++, item))\r\n    return destination\r\n}\r\n\r\n/**\r\n * Applies the given [transform] function to each element and its index in the original array\r\n * and appends the results to the given [destination].\r\n * @param [transform] function that takes the index of an element and the element itself\r\n * and returns the result of the transform applied to the element.\r\n */\r\npublic inline fun <R, C : MutableCollection<in R>> LongArray.mapIndexedTo(destination: C, transform: (index: Int, Long) -> R): C {\r\n    var index = 0\r\n    for (item in this)\r\n        destination.add(transform(index++, item))\r\n    return destination\r\n}\r\n\r\n/**\r\n * Applies the given [transform] function to each element and its index in the original array\r\n * and appends the results to the given [destination].\r\n * @param [transform] function that takes the index of an element and the element itself\r\n * and returns the result of the transform applied to the element.\r\n */\r\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.mapIndexedTo(destination: C, transform: (index: Int, Float) -> R): C {\r\n    var index = 0\r\n    for (item in this)\r\n        destination.add(transform(index++, item))\r\n    return destination\r\n}\r\n\r\n/**\r\n * Applies the given [transform] function to each element and its index in the original array\r\n * and appends the results to the given [destination].\r\n * @param [transform] function that takes the index of an element and the element itself\r\n * and returns the result of the transform applied to the element.\r\n */\r\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.mapIndexedTo(destination: C, transform: (index: Int, Double) -> R): C {\r\n    var index = 0\r\n    for (item in this)\r\n        destination.add(transform(index++, item))\r\n    return destination\r\n}\r\n\r\n/**\r\n * Applies the given [transform] function to each element and its index in the original array\r\n * and appends the results to the given [destination].\r\n * @param [transform] function that takes the index of an element and the element itself\r\n * and returns the result of the transform applied to the element.\r\n */\r\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.mapIndexedTo(destination: C, transform: (index: Int, Boolean) -> R): C {\r\n    var index = 0\r\n    for (item in this)\r\n        destination.add(transform(index++, item))\r\n    return destination\r\n}\r\n\r\n/**\r\n * Applies the given [transform] function to each element and its index in the original array\r\n * and appends the results to the given [destination].\r\n * @param [transform] function that takes the index of an element and the element itself\r\n * and returns the result of the transform applied to the element.\r\n */\r\npublic inline fun <R, C : MutableCollection<in R>> CharArray.mapIndexedTo(destination: C, transform: (index: Int, Char) -> R): C {\r\n    var index = 0\r\n    for (item in this)\r\n        destination.add(transform(index++, item))\r\n    return destination\r\n}\r\n\r\n/**\r\n * Returns a list containing only the non-null results of applying the given [transform] function\r\n * to each element in the original array.\r\n */\r\npublic inline fun <T, R : Any> Array<out T>.mapNotNull(transform: (T) -> R?): List<R> {\r\n    return mapNotNullTo(ArrayList<R>(), transform)\r\n}\r\n\r\n/**\r\n * Applies the given [transform] function to each element in the original array\r\n * and appends only the non-null results to the given [destination].\r\n */\r\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Array<out T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\r\n    forEach { element -> transform(element)?.let { destination.add(it) } }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Applies the given [transform] function to each element of the original array\r\n * and appends the results to the given [destination].\r\n */\r\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapTo(destination: C, transform: (T) -> R): C {\r\n    for (item in this)\r\n        destination.add(transform(item))\r\n    return destination\r\n}\r\n\r\n/**\r\n * Applies the given [transform] function to each element of the original array\r\n * and appends the results to the given [destination].\r\n */\r\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.mapTo(destination: C, transform: (Byte) -> R): C {\r\n    for (item in this)\r\n        destination.add(transform(item))\r\n    return destination\r\n}\r\n\r\n/**\r\n * Applies the given [transform] function to each element of the original array\r\n * and appends the results to the given [destination].\r\n */\r\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.mapTo(destination: C, transform: (Short) -> R): C {\r\n    for (item in this)\r\n        destination.add(transform(item))\r\n    return destination\r\n}\r\n\r\n/**\r\n * Applies the given [transform] function to each element of the original array\r\n * and appends the results to the given [destination].\r\n */\r\npublic inline fun <R, C : MutableCollection<in R>> IntArray.mapTo(destination: C, transform: (Int) -> R): C {\r\n    for (item in this)\r\n        destination.add(transform(item))\r\n    return destination\r\n}\r\n\r\n/**\r\n * Applies the given [transform] function to each element of the original array\r\n * and appends the results to the given [destination].\r\n */\r\npublic inline fun <R, C : MutableCollection<in R>> LongArray.mapTo(destination: C, transform: (Long) -> R): C {\r\n    for (item in this)\r\n        destination.add(transform(item))\r\n    return destination\r\n}\r\n\r\n/**\r\n * Applies the given [transform] function to each element of the original array\r\n * and appends the results to the given [destination].\r\n */\r\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.mapTo(destination: C, transform: (Float) -> R): C {\r\n    for (item in this)\r\n        destination.add(transform(item))\r\n    return destination\r\n}\r\n\r\n/**\r\n * Applies the given [transform] function to each element of the original array\r\n * and appends the results to the given [destination].\r\n */\r\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.mapTo(destination: C, transform: (Double) -> R): C {\r\n    for (item in this)\r\n        destination.add(transform(item))\r\n    return destination\r\n}\r\n\r\n/**\r\n * Applies the given [transform] function to each element of the original array\r\n * and appends the results to the given [destination].\r\n */\r\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.mapTo(destination: C, transform: (Boolean) -> R): C {\r\n    for (item in this)\r\n        destination.add(transform(item))\r\n    return destination\r\n}\r\n\r\n/**\r\n * Applies the given [transform] function to each element of the original array\r\n * and appends the results to the given [destination].\r\n */\r\npublic inline fun <R, C : MutableCollection<in R>> CharArray.mapTo(destination: C, transform: (Char) -> R): C {\r\n    for (item in this)\r\n        destination.add(transform(item))\r\n    return destination\r\n}\r\n\r\n/**\r\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\r\n */\r\npublic fun <T> Array<out T>.withIndex(): Iterable<IndexedValue<T>> {\r\n    return IndexingIterable { iterator() }\r\n}\r\n\r\n/**\r\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\r\n */\r\npublic fun ByteArray.withIndex(): Iterable<IndexedValue<Byte>> {\r\n    return IndexingIterable { iterator() }\r\n}\r\n\r\n/**\r\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\r\n */\r\npublic fun ShortArray.withIndex(): Iterable<IndexedValue<Short>> {\r\n    return IndexingIterable { iterator() }\r\n}\r\n\r\n/**\r\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\r\n */\r\npublic fun IntArray.withIndex(): Iterable<IndexedValue<Int>> {\r\n    return IndexingIterable { iterator() }\r\n}\r\n\r\n/**\r\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\r\n */\r\npublic fun LongArray.withIndex(): Iterable<IndexedValue<Long>> {\r\n    return IndexingIterable { iterator() }\r\n}\r\n\r\n/**\r\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\r\n */\r\npublic fun FloatArray.withIndex(): Iterable<IndexedValue<Float>> {\r\n    return IndexingIterable { iterator() }\r\n}\r\n\r\n/**\r\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\r\n */\r\npublic fun DoubleArray.withIndex(): Iterable<IndexedValue<Double>> {\r\n    return IndexingIterable { iterator() }\r\n}\r\n\r\n/**\r\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\r\n */\r\npublic fun BooleanArray.withIndex(): Iterable<IndexedValue<Boolean>> {\r\n    return IndexingIterable { iterator() }\r\n}\r\n\r\n/**\r\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\r\n */\r\npublic fun CharArray.withIndex(): Iterable<IndexedValue<Char>> {\r\n    return IndexingIterable { iterator() }\r\n}\r\n\r\n/**\r\n * Returns a list containing only distinct elements from the given array.\r\n * \r\n * The elements in the resulting list are in the same order as they were in the source array.\r\n */\r\npublic fun <T> Array<out T>.distinct(): List<T> {\r\n    return this.toMutableSet().toList()\r\n}\r\n\r\n/**\r\n * Returns a list containing only distinct elements from the given array.\r\n * \r\n * The elements in the resulting list are in the same order as they were in the source array.\r\n */\r\npublic fun ByteArray.distinct(): List<Byte> {\r\n    return this.toMutableSet().toList()\r\n}\r\n\r\n/**\r\n * Returns a list containing only distinct elements from the given array.\r\n * \r\n * The elements in the resulting list are in the same order as they were in the source array.\r\n */\r\npublic fun ShortArray.distinct(): List<Short> {\r\n    return this.toMutableSet().toList()\r\n}\r\n\r\n/**\r\n * Returns a list containing only distinct elements from the given array.\r\n * \r\n * The elements in the resulting list are in the same order as they were in the source array.\r\n */\r\npublic fun IntArray.distinct(): List<Int> {\r\n    return this.toMutableSet().toList()\r\n}\r\n\r\n/**\r\n * Returns a list containing only distinct elements from the given array.\r\n * \r\n * The elements in the resulting list are in the same order as they were in the source array.\r\n */\r\npublic fun LongArray.distinct(): List<Long> {\r\n    return this.toMutableSet().toList()\r\n}\r\n\r\n/**\r\n * Returns a list containing only distinct elements from the given array.\r\n * \r\n * The elements in the resulting list are in the same order as they were in the source array.\r\n */\r\npublic fun FloatArray.distinct(): List<Float> {\r\n    return this.toMutableSet().toList()\r\n}\r\n\r\n/**\r\n * Returns a list containing only distinct elements from the given array.\r\n * \r\n * The elements in the resulting list are in the same order as they were in the source array.\r\n */\r\npublic fun DoubleArray.distinct(): List<Double> {\r\n    return this.toMutableSet().toList()\r\n}\r\n\r\n/**\r\n * Returns a list containing only distinct elements from the given array.\r\n * \r\n * The elements in the resulting list are in the same order as they were in the source array.\r\n */\r\npublic fun BooleanArray.distinct(): List<Boolean> {\r\n    return this.toMutableSet().toList()\r\n}\r\n\r\n/**\r\n * Returns a list containing only distinct elements from the given array.\r\n * \r\n * The elements in the resulting list are in the same order as they were in the source array.\r\n */\r\npublic fun CharArray.distinct(): List<Char> {\r\n    return this.toMutableSet().toList()\r\n}\r\n\r\n/**\r\n * Returns a list containing only elements from the given array\r\n * having distinct keys returned by the given [selector] function.\r\n * \r\n * The elements in the resulting list are in the same order as they were in the source array.\r\n */\r\npublic inline fun <T, K> Array<out T>.distinctBy(selector: (T) -> K): List<T> {\r\n    val set = HashSet<K>()\r\n    val list = ArrayList<T>()\r\n    for (e in this) {\r\n        val key = selector(e)\r\n        if (set.add(key))\r\n            list.add(e)\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing only elements from the given array\r\n * having distinct keys returned by the given [selector] function.\r\n * \r\n * The elements in the resulting list are in the same order as they were in the source array.\r\n */\r\npublic inline fun <K> ByteArray.distinctBy(selector: (Byte) -> K): List<Byte> {\r\n    val set = HashSet<K>()\r\n    val list = ArrayList<Byte>()\r\n    for (e in this) {\r\n        val key = selector(e)\r\n        if (set.add(key))\r\n            list.add(e)\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing only elements from the given array\r\n * having distinct keys returned by the given [selector] function.\r\n * \r\n * The elements in the resulting list are in the same order as they were in the source array.\r\n */\r\npublic inline fun <K> ShortArray.distinctBy(selector: (Short) -> K): List<Short> {\r\n    val set = HashSet<K>()\r\n    val list = ArrayList<Short>()\r\n    for (e in this) {\r\n        val key = selector(e)\r\n        if (set.add(key))\r\n            list.add(e)\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing only elements from the given array\r\n * having distinct keys returned by the given [selector] function.\r\n * \r\n * The elements in the resulting list are in the same order as they were in the source array.\r\n */\r\npublic inline fun <K> IntArray.distinctBy(selector: (Int) -> K): List<Int> {\r\n    val set = HashSet<K>()\r\n    val list = ArrayList<Int>()\r\n    for (e in this) {\r\n        val key = selector(e)\r\n        if (set.add(key))\r\n            list.add(e)\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing only elements from the given array\r\n * having distinct keys returned by the given [selector] function.\r\n * \r\n * The elements in the resulting list are in the same order as they were in the source array.\r\n */\r\npublic inline fun <K> LongArray.distinctBy(selector: (Long) -> K): List<Long> {\r\n    val set = HashSet<K>()\r\n    val list = ArrayList<Long>()\r\n    for (e in this) {\r\n        val key = selector(e)\r\n        if (set.add(key))\r\n            list.add(e)\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing only elements from the given array\r\n * having distinct keys returned by the given [selector] function.\r\n * \r\n * The elements in the resulting list are in the same order as they were in the source array.\r\n */\r\npublic inline fun <K> FloatArray.distinctBy(selector: (Float) -> K): List<Float> {\r\n    val set = HashSet<K>()\r\n    val list = ArrayList<Float>()\r\n    for (e in this) {\r\n        val key = selector(e)\r\n        if (set.add(key))\r\n            list.add(e)\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing only elements from the given array\r\n * having distinct keys returned by the given [selector] function.\r\n * \r\n * The elements in the resulting list are in the same order as they were in the source array.\r\n */\r\npublic inline fun <K> DoubleArray.distinctBy(selector: (Double) -> K): List<Double> {\r\n    val set = HashSet<K>()\r\n    val list = ArrayList<Double>()\r\n    for (e in this) {\r\n        val key = selector(e)\r\n        if (set.add(key))\r\n            list.add(e)\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing only elements from the given array\r\n * having distinct keys returned by the given [selector] function.\r\n * \r\n * The elements in the resulting list are in the same order as they were in the source array.\r\n */\r\npublic inline fun <K> BooleanArray.distinctBy(selector: (Boolean) -> K): List<Boolean> {\r\n    val set = HashSet<K>()\r\n    val list = ArrayList<Boolean>()\r\n    for (e in this) {\r\n        val key = selector(e)\r\n        if (set.add(key))\r\n            list.add(e)\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list containing only elements from the given array\r\n * having distinct keys returned by the given [selector] function.\r\n * \r\n * The elements in the resulting list are in the same order as they were in the source array.\r\n */\r\npublic inline fun <K> CharArray.distinctBy(selector: (Char) -> K): List<Char> {\r\n    val set = HashSet<K>()\r\n    val list = ArrayList<Char>()\r\n    for (e in this) {\r\n        val key = selector(e)\r\n        if (set.add(key))\r\n            list.add(e)\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a set containing all elements that are contained by both this set and the specified collection.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic infix fun <T> Array<out T>.intersect(other: Iterable<T>): Set<T> {\r\n    val set = this.toMutableSet()\r\n    set.retainAll(other)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a set containing all elements that are contained by both this set and the specified collection.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic infix fun ByteArray.intersect(other: Iterable<Byte>): Set<Byte> {\r\n    val set = this.toMutableSet()\r\n    set.retainAll(other)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a set containing all elements that are contained by both this set and the specified collection.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic infix fun ShortArray.intersect(other: Iterable<Short>): Set<Short> {\r\n    val set = this.toMutableSet()\r\n    set.retainAll(other)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a set containing all elements that are contained by both this set and the specified collection.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic infix fun IntArray.intersect(other: Iterable<Int>): Set<Int> {\r\n    val set = this.toMutableSet()\r\n    set.retainAll(other)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a set containing all elements that are contained by both this set and the specified collection.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic infix fun LongArray.intersect(other: Iterable<Long>): Set<Long> {\r\n    val set = this.toMutableSet()\r\n    set.retainAll(other)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a set containing all elements that are contained by both this set and the specified collection.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic infix fun FloatArray.intersect(other: Iterable<Float>): Set<Float> {\r\n    val set = this.toMutableSet()\r\n    set.retainAll(other)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a set containing all elements that are contained by both this set and the specified collection.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic infix fun DoubleArray.intersect(other: Iterable<Double>): Set<Double> {\r\n    val set = this.toMutableSet()\r\n    set.retainAll(other)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a set containing all elements that are contained by both this set and the specified collection.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic infix fun BooleanArray.intersect(other: Iterable<Boolean>): Set<Boolean> {\r\n    val set = this.toMutableSet()\r\n    set.retainAll(other)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a set containing all elements that are contained by both this set and the specified collection.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic infix fun CharArray.intersect(other: Iterable<Char>): Set<Char> {\r\n    val set = this.toMutableSet()\r\n    set.retainAll(other)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic infix fun <T> Array<out T>.subtract(other: Iterable<T>): Set<T> {\r\n    val set = this.toMutableSet()\r\n    set.removeAll(other)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic infix fun ByteArray.subtract(other: Iterable<Byte>): Set<Byte> {\r\n    val set = this.toMutableSet()\r\n    set.removeAll(other)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic infix fun ShortArray.subtract(other: Iterable<Short>): Set<Short> {\r\n    val set = this.toMutableSet()\r\n    set.removeAll(other)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic infix fun IntArray.subtract(other: Iterable<Int>): Set<Int> {\r\n    val set = this.toMutableSet()\r\n    set.removeAll(other)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic infix fun LongArray.subtract(other: Iterable<Long>): Set<Long> {\r\n    val set = this.toMutableSet()\r\n    set.removeAll(other)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic infix fun FloatArray.subtract(other: Iterable<Float>): Set<Float> {\r\n    val set = this.toMutableSet()\r\n    set.removeAll(other)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic infix fun DoubleArray.subtract(other: Iterable<Double>): Set<Double> {\r\n    val set = this.toMutableSet()\r\n    set.removeAll(other)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic infix fun BooleanArray.subtract(other: Iterable<Boolean>): Set<Boolean> {\r\n    val set = this.toMutableSet()\r\n    set.removeAll(other)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic infix fun CharArray.subtract(other: Iterable<Char>): Set<Char> {\r\n    val set = this.toMutableSet()\r\n    set.removeAll(other)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a mutable set containing all distinct elements from the given array.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic fun <T> Array<out T>.toMutableSet(): MutableSet<T> {\r\n    val set = LinkedHashSet<T>(mapCapacity(size))\r\n    for (item in this) set.add(item)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a mutable set containing all distinct elements from the given array.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic fun ByteArray.toMutableSet(): MutableSet<Byte> {\r\n    val set = LinkedHashSet<Byte>(mapCapacity(size))\r\n    for (item in this) set.add(item)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a mutable set containing all distinct elements from the given array.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic fun ShortArray.toMutableSet(): MutableSet<Short> {\r\n    val set = LinkedHashSet<Short>(mapCapacity(size))\r\n    for (item in this) set.add(item)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a mutable set containing all distinct elements from the given array.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic fun IntArray.toMutableSet(): MutableSet<Int> {\r\n    val set = LinkedHashSet<Int>(mapCapacity(size))\r\n    for (item in this) set.add(item)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a mutable set containing all distinct elements from the given array.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic fun LongArray.toMutableSet(): MutableSet<Long> {\r\n    val set = LinkedHashSet<Long>(mapCapacity(size))\r\n    for (item in this) set.add(item)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a mutable set containing all distinct elements from the given array.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic fun FloatArray.toMutableSet(): MutableSet<Float> {\r\n    val set = LinkedHashSet<Float>(mapCapacity(size))\r\n    for (item in this) set.add(item)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a mutable set containing all distinct elements from the given array.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic fun DoubleArray.toMutableSet(): MutableSet<Double> {\r\n    val set = LinkedHashSet<Double>(mapCapacity(size))\r\n    for (item in this) set.add(item)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a mutable set containing all distinct elements from the given array.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic fun BooleanArray.toMutableSet(): MutableSet<Boolean> {\r\n    val set = LinkedHashSet<Boolean>(mapCapacity(size))\r\n    for (item in this) set.add(item)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a mutable set containing all distinct elements from the given array.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n */\r\npublic fun CharArray.toMutableSet(): MutableSet<Char> {\r\n    val set = LinkedHashSet<Char>(mapCapacity(size))\r\n    for (item in this) set.add(item)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a set containing all distinct elements from both collections.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n * Those elements of the [other] collection that are unique are iterated in the end\r\n * in the order of the [other] collection.\r\n */\r\npublic infix fun <T> Array<out T>.union(other: Iterable<T>): Set<T> {\r\n    val set = this.toMutableSet()\r\n    set.addAll(other)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a set containing all distinct elements from both collections.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n * Those elements of the [other] collection that are unique are iterated in the end\r\n * in the order of the [other] collection.\r\n */\r\npublic infix fun ByteArray.union(other: Iterable<Byte>): Set<Byte> {\r\n    val set = this.toMutableSet()\r\n    set.addAll(other)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a set containing all distinct elements from both collections.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n * Those elements of the [other] collection that are unique are iterated in the end\r\n * in the order of the [other] collection.\r\n */\r\npublic infix fun ShortArray.union(other: Iterable<Short>): Set<Short> {\r\n    val set = this.toMutableSet()\r\n    set.addAll(other)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a set containing all distinct elements from both collections.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n * Those elements of the [other] collection that are unique are iterated in the end\r\n * in the order of the [other] collection.\r\n */\r\npublic infix fun IntArray.union(other: Iterable<Int>): Set<Int> {\r\n    val set = this.toMutableSet()\r\n    set.addAll(other)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a set containing all distinct elements from both collections.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n * Those elements of the [other] collection that are unique are iterated in the end\r\n * in the order of the [other] collection.\r\n */\r\npublic infix fun LongArray.union(other: Iterable<Long>): Set<Long> {\r\n    val set = this.toMutableSet()\r\n    set.addAll(other)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a set containing all distinct elements from both collections.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n * Those elements of the [other] collection that are unique are iterated in the end\r\n * in the order of the [other] collection.\r\n */\r\npublic infix fun FloatArray.union(other: Iterable<Float>): Set<Float> {\r\n    val set = this.toMutableSet()\r\n    set.addAll(other)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a set containing all distinct elements from both collections.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n * Those elements of the [other] collection that are unique are iterated in the end\r\n * in the order of the [other] collection.\r\n */\r\npublic infix fun DoubleArray.union(other: Iterable<Double>): Set<Double> {\r\n    val set = this.toMutableSet()\r\n    set.addAll(other)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a set containing all distinct elements from both collections.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n * Those elements of the [other] collection that are unique are iterated in the end\r\n * in the order of the [other] collection.\r\n */\r\npublic infix fun BooleanArray.union(other: Iterable<Boolean>): Set<Boolean> {\r\n    val set = this.toMutableSet()\r\n    set.addAll(other)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns a set containing all distinct elements from both collections.\r\n * \r\n * The returned set preserves the element iteration order of the original array.\r\n * Those elements of the [other] collection that are unique are iterated in the end\r\n * in the order of the [other] collection.\r\n */\r\npublic infix fun CharArray.union(other: Iterable<Char>): Set<Char> {\r\n    val set = this.toMutableSet()\r\n    set.addAll(other)\r\n    return set\r\n}\r\n\r\n/**\r\n * Returns `true` if all elements match the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Aggregates.all\r\n */\r\npublic inline fun <T> Array<out T>.all(predicate: (T) -> Boolean): Boolean {\r\n    for (element in this) if (!predicate(element)) return false\r\n    return true\r\n}\r\n\r\n/**\r\n * Returns `true` if all elements match the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Aggregates.all\r\n */\r\npublic inline fun ByteArray.all(predicate: (Byte) -> Boolean): Boolean {\r\n    for (element in this) if (!predicate(element)) return false\r\n    return true\r\n}\r\n\r\n/**\r\n * Returns `true` if all elements match the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Aggregates.all\r\n */\r\npublic inline fun ShortArray.all(predicate: (Short) -> Boolean): Boolean {\r\n    for (element in this) if (!predicate(element)) return false\r\n    return true\r\n}\r\n\r\n/**\r\n * Returns `true` if all elements match the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Aggregates.all\r\n */\r\npublic inline fun IntArray.all(predicate: (Int) -> Boolean): Boolean {\r\n    for (element in this) if (!predicate(element)) return false\r\n    return true\r\n}\r\n\r\n/**\r\n * Returns `true` if all elements match the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Aggregates.all\r\n */\r\npublic inline fun LongArray.all(predicate: (Long) -> Boolean): Boolean {\r\n    for (element in this) if (!predicate(element)) return false\r\n    return true\r\n}\r\n\r\n/**\r\n * Returns `true` if all elements match the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Aggregates.all\r\n */\r\npublic inline fun FloatArray.all(predicate: (Float) -> Boolean): Boolean {\r\n    for (element in this) if (!predicate(element)) return false\r\n    return true\r\n}\r\n\r\n/**\r\n * Returns `true` if all elements match the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Aggregates.all\r\n */\r\npublic inline fun DoubleArray.all(predicate: (Double) -> Boolean): Boolean {\r\n    for (element in this) if (!predicate(element)) return false\r\n    return true\r\n}\r\n\r\n/**\r\n * Returns `true` if all elements match the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Aggregates.all\r\n */\r\npublic inline fun BooleanArray.all(predicate: (Boolean) -> Boolean): Boolean {\r\n    for (element in this) if (!predicate(element)) return false\r\n    return true\r\n}\r\n\r\n/**\r\n * Returns `true` if all elements match the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Aggregates.all\r\n */\r\npublic inline fun CharArray.all(predicate: (Char) -> Boolean): Boolean {\r\n    for (element in this) if (!predicate(element)) return false\r\n    return true\r\n}\r\n\r\n/**\r\n * Returns `true` if array has at least one element.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.any\r\n */\r\npublic fun <T> Array<out T>.any(): Boolean {\r\n    return !isEmpty()\r\n}\r\n\r\n/**\r\n * Returns `true` if array has at least one element.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.any\r\n */\r\npublic fun ByteArray.any(): Boolean {\r\n    return !isEmpty()\r\n}\r\n\r\n/**\r\n * Returns `true` if array has at least one element.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.any\r\n */\r\npublic fun ShortArray.any(): Boolean {\r\n    return !isEmpty()\r\n}\r\n\r\n/**\r\n * Returns `true` if array has at least one element.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.any\r\n */\r\npublic fun IntArray.any(): Boolean {\r\n    return !isEmpty()\r\n}\r\n\r\n/**\r\n * Returns `true` if array has at least one element.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.any\r\n */\r\npublic fun LongArray.any(): Boolean {\r\n    return !isEmpty()\r\n}\r\n\r\n/**\r\n * Returns `true` if array has at least one element.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.any\r\n */\r\npublic fun FloatArray.any(): Boolean {\r\n    return !isEmpty()\r\n}\r\n\r\n/**\r\n * Returns `true` if array has at least one element.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.any\r\n */\r\npublic fun DoubleArray.any(): Boolean {\r\n    return !isEmpty()\r\n}\r\n\r\n/**\r\n * Returns `true` if array has at least one element.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.any\r\n */\r\npublic fun BooleanArray.any(): Boolean {\r\n    return !isEmpty()\r\n}\r\n\r\n/**\r\n * Returns `true` if array has at least one element.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.any\r\n */\r\npublic fun CharArray.any(): Boolean {\r\n    return !isEmpty()\r\n}\r\n\r\n/**\r\n * Returns `true` if at least one element matches the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\r\n */\r\npublic inline fun <T> Array<out T>.any(predicate: (T) -> Boolean): Boolean {\r\n    for (element in this) if (predicate(element)) return true\r\n    return false\r\n}\r\n\r\n/**\r\n * Returns `true` if at least one element matches the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\r\n */\r\npublic inline fun ByteArray.any(predicate: (Byte) -> Boolean): Boolean {\r\n    for (element in this) if (predicate(element)) return true\r\n    return false\r\n}\r\n\r\n/**\r\n * Returns `true` if at least one element matches the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\r\n */\r\npublic inline fun ShortArray.any(predicate: (Short) -> Boolean): Boolean {\r\n    for (element in this) if (predicate(element)) return true\r\n    return false\r\n}\r\n\r\n/**\r\n * Returns `true` if at least one element matches the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\r\n */\r\npublic inline fun IntArray.any(predicate: (Int) -> Boolean): Boolean {\r\n    for (element in this) if (predicate(element)) return true\r\n    return false\r\n}\r\n\r\n/**\r\n * Returns `true` if at least one element matches the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\r\n */\r\npublic inline fun LongArray.any(predicate: (Long) -> Boolean): Boolean {\r\n    for (element in this) if (predicate(element)) return true\r\n    return false\r\n}\r\n\r\n/**\r\n * Returns `true` if at least one element matches the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\r\n */\r\npublic inline fun FloatArray.any(predicate: (Float) -> Boolean): Boolean {\r\n    for (element in this) if (predicate(element)) return true\r\n    return false\r\n}\r\n\r\n/**\r\n * Returns `true` if at least one element matches the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\r\n */\r\npublic inline fun DoubleArray.any(predicate: (Double) -> Boolean): Boolean {\r\n    for (element in this) if (predicate(element)) return true\r\n    return false\r\n}\r\n\r\n/**\r\n * Returns `true` if at least one element matches the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\r\n */\r\npublic inline fun BooleanArray.any(predicate: (Boolean) -> Boolean): Boolean {\r\n    for (element in this) if (predicate(element)) return true\r\n    return false\r\n}\r\n\r\n/**\r\n * Returns `true` if at least one element matches the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\r\n */\r\npublic inline fun CharArray.any(predicate: (Char) -> Boolean): Boolean {\r\n    for (element in this) if (predicate(element)) return true\r\n    return false\r\n}\r\n\r\n/**\r\n * Returns the number of elements in this array.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun <T> Array<out T>.count(): Int {\r\n    return size\r\n}\r\n\r\n/**\r\n * Returns the number of elements in this array.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun ByteArray.count(): Int {\r\n    return size\r\n}\r\n\r\n/**\r\n * Returns the number of elements in this array.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun ShortArray.count(): Int {\r\n    return size\r\n}\r\n\r\n/**\r\n * Returns the number of elements in this array.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun IntArray.count(): Int {\r\n    return size\r\n}\r\n\r\n/**\r\n * Returns the number of elements in this array.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun LongArray.count(): Int {\r\n    return size\r\n}\r\n\r\n/**\r\n * Returns the number of elements in this array.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun FloatArray.count(): Int {\r\n    return size\r\n}\r\n\r\n/**\r\n * Returns the number of elements in this array.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun DoubleArray.count(): Int {\r\n    return size\r\n}\r\n\r\n/**\r\n * Returns the number of elements in this array.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun BooleanArray.count(): Int {\r\n    return size\r\n}\r\n\r\n/**\r\n * Returns the number of elements in this array.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun CharArray.count(): Int {\r\n    return size\r\n}\r\n\r\n/**\r\n * Returns the number of elements matching the given [predicate].\r\n */\r\npublic inline fun <T> Array<out T>.count(predicate: (T) -> Boolean): Int {\r\n    var count = 0\r\n    for (element in this) if (predicate(element)) ++count\r\n    return count\r\n}\r\n\r\n/**\r\n * Returns the number of elements matching the given [predicate].\r\n */\r\npublic inline fun ByteArray.count(predicate: (Byte) -> Boolean): Int {\r\n    var count = 0\r\n    for (element in this) if (predicate(element)) ++count\r\n    return count\r\n}\r\n\r\n/**\r\n * Returns the number of elements matching the given [predicate].\r\n */\r\npublic inline fun ShortArray.count(predicate: (Short) -> Boolean): Int {\r\n    var count = 0\r\n    for (element in this) if (predicate(element)) ++count\r\n    return count\r\n}\r\n\r\n/**\r\n * Returns the number of elements matching the given [predicate].\r\n */\r\npublic inline fun IntArray.count(predicate: (Int) -> Boolean): Int {\r\n    var count = 0\r\n    for (element in this) if (predicate(element)) ++count\r\n    return count\r\n}\r\n\r\n/**\r\n * Returns the number of elements matching the given [predicate].\r\n */\r\npublic inline fun LongArray.count(predicate: (Long) -> Boolean): Int {\r\n    var count = 0\r\n    for (element in this) if (predicate(element)) ++count\r\n    return count\r\n}\r\n\r\n/**\r\n * Returns the number of elements matching the given [predicate].\r\n */\r\npublic inline fun FloatArray.count(predicate: (Float) -> Boolean): Int {\r\n    var count = 0\r\n    for (element in this) if (predicate(element)) ++count\r\n    return count\r\n}\r\n\r\n/**\r\n * Returns the number of elements matching the given [predicate].\r\n */\r\npublic inline fun DoubleArray.count(predicate: (Double) -> Boolean): Int {\r\n    var count = 0\r\n    for (element in this) if (predicate(element)) ++count\r\n    return count\r\n}\r\n\r\n/**\r\n * Returns the number of elements matching the given [predicate].\r\n */\r\npublic inline fun BooleanArray.count(predicate: (Boolean) -> Boolean): Int {\r\n    var count = 0\r\n    for (element in this) if (predicate(element)) ++count\r\n    return count\r\n}\r\n\r\n/**\r\n * Returns the number of elements matching the given [predicate].\r\n */\r\npublic inline fun CharArray.count(predicate: (Char) -> Boolean): Int {\r\n    var count = 0\r\n    for (element in this) if (predicate(element)) ++count\r\n    return count\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\r\n */\r\npublic inline fun <T, R> Array<out T>.fold(initial: R, operation: (acc: R, T) -> R): R {\r\n    var accumulator = initial\r\n    for (element in this) accumulator = operation(accumulator, element)\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\r\n */\r\npublic inline fun <R> ByteArray.fold(initial: R, operation: (acc: R, Byte) -> R): R {\r\n    var accumulator = initial\r\n    for (element in this) accumulator = operation(accumulator, element)\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\r\n */\r\npublic inline fun <R> ShortArray.fold(initial: R, operation: (acc: R, Short) -> R): R {\r\n    var accumulator = initial\r\n    for (element in this) accumulator = operation(accumulator, element)\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\r\n */\r\npublic inline fun <R> IntArray.fold(initial: R, operation: (acc: R, Int) -> R): R {\r\n    var accumulator = initial\r\n    for (element in this) accumulator = operation(accumulator, element)\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\r\n */\r\npublic inline fun <R> LongArray.fold(initial: R, operation: (acc: R, Long) -> R): R {\r\n    var accumulator = initial\r\n    for (element in this) accumulator = operation(accumulator, element)\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\r\n */\r\npublic inline fun <R> FloatArray.fold(initial: R, operation: (acc: R, Float) -> R): R {\r\n    var accumulator = initial\r\n    for (element in this) accumulator = operation(accumulator, element)\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\r\n */\r\npublic inline fun <R> DoubleArray.fold(initial: R, operation: (acc: R, Double) -> R): R {\r\n    var accumulator = initial\r\n    for (element in this) accumulator = operation(accumulator, element)\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\r\n */\r\npublic inline fun <R> BooleanArray.fold(initial: R, operation: (acc: R, Boolean) -> R): R {\r\n    var accumulator = initial\r\n    for (element in this) accumulator = operation(accumulator, element)\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\r\n */\r\npublic inline fun <R> CharArray.fold(initial: R, operation: (acc: R, Char) -> R): R {\r\n    var accumulator = initial\r\n    for (element in this) accumulator = operation(accumulator, element)\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from left to right\r\n * to current accumulator value and each element with its index in the original array.\r\n * @param [operation] function that takes the index of an element, current accumulator value\r\n * and the element itself, and calculates the next accumulator value.\r\n */\r\npublic inline fun <T, R> Array<out T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\r\n    var index = 0\r\n    var accumulator = initial\r\n    for (element in this) accumulator = operation(index++, accumulator, element)\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from left to right\r\n * to current accumulator value and each element with its index in the original array.\r\n * @param [operation] function that takes the index of an element, current accumulator value\r\n * and the element itself, and calculates the next accumulator value.\r\n */\r\npublic inline fun <R> ByteArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): R {\r\n    var index = 0\r\n    var accumulator = initial\r\n    for (element in this) accumulator = operation(index++, accumulator, element)\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from left to right\r\n * to current accumulator value and each element with its index in the original array.\r\n * @param [operation] function that takes the index of an element, current accumulator value\r\n * and the element itself, and calculates the next accumulator value.\r\n */\r\npublic inline fun <R> ShortArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): R {\r\n    var index = 0\r\n    var accumulator = initial\r\n    for (element in this) accumulator = operation(index++, accumulator, element)\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from left to right\r\n * to current accumulator value and each element with its index in the original array.\r\n * @param [operation] function that takes the index of an element, current accumulator value\r\n * and the element itself, and calculates the next accumulator value.\r\n */\r\npublic inline fun <R> IntArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): R {\r\n    var index = 0\r\n    var accumulator = initial\r\n    for (element in this) accumulator = operation(index++, accumulator, element)\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from left to right\r\n * to current accumulator value and each element with its index in the original array.\r\n * @param [operation] function that takes the index of an element, current accumulator value\r\n * and the element itself, and calculates the next accumulator value.\r\n */\r\npublic inline fun <R> LongArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): R {\r\n    var index = 0\r\n    var accumulator = initial\r\n    for (element in this) accumulator = operation(index++, accumulator, element)\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from left to right\r\n * to current accumulator value and each element with its index in the original array.\r\n * @param [operation] function that takes the index of an element, current accumulator value\r\n * and the element itself, and calculates the next accumulator value.\r\n */\r\npublic inline fun <R> FloatArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): R {\r\n    var index = 0\r\n    var accumulator = initial\r\n    for (element in this) accumulator = operation(index++, accumulator, element)\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from left to right\r\n * to current accumulator value and each element with its index in the original array.\r\n * @param [operation] function that takes the index of an element, current accumulator value\r\n * and the element itself, and calculates the next accumulator value.\r\n */\r\npublic inline fun <R> DoubleArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): R {\r\n    var index = 0\r\n    var accumulator = initial\r\n    for (element in this) accumulator = operation(index++, accumulator, element)\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from left to right\r\n * to current accumulator value and each element with its index in the original array.\r\n * @param [operation] function that takes the index of an element, current accumulator value\r\n * and the element itself, and calculates the next accumulator value.\r\n */\r\npublic inline fun <R> BooleanArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): R {\r\n    var index = 0\r\n    var accumulator = initial\r\n    for (element in this) accumulator = operation(index++, accumulator, element)\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from left to right\r\n * to current accumulator value and each element with its index in the original array.\r\n * @param [operation] function that takes the index of an element, current accumulator value\r\n * and the element itself, and calculates the next accumulator value.\r\n */\r\npublic inline fun <R> CharArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): R {\r\n    var index = 0\r\n    var accumulator = initial\r\n    for (element in this) accumulator = operation(index++, accumulator, element)\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\r\n */\r\npublic inline fun <T, R> Array<out T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\r\n    var index = lastIndex\r\n    var accumulator = initial\r\n    while (index >= 0) {\r\n        accumulator = operation(get(index--), accumulator)\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\r\n */\r\npublic inline fun <R> ByteArray.foldRight(initial: R, operation: (Byte, acc: R) -> R): R {\r\n    var index = lastIndex\r\n    var accumulator = initial\r\n    while (index >= 0) {\r\n        accumulator = operation(get(index--), accumulator)\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\r\n */\r\npublic inline fun <R> ShortArray.foldRight(initial: R, operation: (Short, acc: R) -> R): R {\r\n    var index = lastIndex\r\n    var accumulator = initial\r\n    while (index >= 0) {\r\n        accumulator = operation(get(index--), accumulator)\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\r\n */\r\npublic inline fun <R> IntArray.foldRight(initial: R, operation: (Int, acc: R) -> R): R {\r\n    var index = lastIndex\r\n    var accumulator = initial\r\n    while (index >= 0) {\r\n        accumulator = operation(get(index--), accumulator)\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\r\n */\r\npublic inline fun <R> LongArray.foldRight(initial: R, operation: (Long, acc: R) -> R): R {\r\n    var index = lastIndex\r\n    var accumulator = initial\r\n    while (index >= 0) {\r\n        accumulator = operation(get(index--), accumulator)\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\r\n */\r\npublic inline fun <R> FloatArray.foldRight(initial: R, operation: (Float, acc: R) -> R): R {\r\n    var index = lastIndex\r\n    var accumulator = initial\r\n    while (index >= 0) {\r\n        accumulator = operation(get(index--), accumulator)\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\r\n */\r\npublic inline fun <R> DoubleArray.foldRight(initial: R, operation: (Double, acc: R) -> R): R {\r\n    var index = lastIndex\r\n    var accumulator = initial\r\n    while (index >= 0) {\r\n        accumulator = operation(get(index--), accumulator)\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\r\n */\r\npublic inline fun <R> BooleanArray.foldRight(initial: R, operation: (Boolean, acc: R) -> R): R {\r\n    var index = lastIndex\r\n    var accumulator = initial\r\n    while (index >= 0) {\r\n        accumulator = operation(get(index--), accumulator)\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\r\n */\r\npublic inline fun <R> CharArray.foldRight(initial: R, operation: (Char, acc: R) -> R): R {\r\n    var index = lastIndex\r\n    var accumulator = initial\r\n    while (index >= 0) {\r\n        accumulator = operation(get(index--), accumulator)\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from right to left\r\n * to each element with its index in the original array and current accumulator value.\r\n * @param [operation] function that takes the index of an element, the element itself\r\n * and current accumulator value, and calculates the next accumulator value.\r\n */\r\npublic inline fun <T, R> Array<out T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\r\n    var index = lastIndex\r\n    var accumulator = initial\r\n    while (index >= 0) {\r\n        accumulator = operation(index, get(index), accumulator)\r\n        --index\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from right to left\r\n * to each element with its index in the original array and current accumulator value.\r\n * @param [operation] function that takes the index of an element, the element itself\r\n * and current accumulator value, and calculates the next accumulator value.\r\n */\r\npublic inline fun <R> ByteArray.foldRightIndexed(initial: R, operation: (index: Int, Byte, acc: R) -> R): R {\r\n    var index = lastIndex\r\n    var accumulator = initial\r\n    while (index >= 0) {\r\n        accumulator = operation(index, get(index), accumulator)\r\n        --index\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from right to left\r\n * to each element with its index in the original array and current accumulator value.\r\n * @param [operation] function that takes the index of an element, the element itself\r\n * and current accumulator value, and calculates the next accumulator value.\r\n */\r\npublic inline fun <R> ShortArray.foldRightIndexed(initial: R, operation: (index: Int, Short, acc: R) -> R): R {\r\n    var index = lastIndex\r\n    var accumulator = initial\r\n    while (index >= 0) {\r\n        accumulator = operation(index, get(index), accumulator)\r\n        --index\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from right to left\r\n * to each element with its index in the original array and current accumulator value.\r\n * @param [operation] function that takes the index of an element, the element itself\r\n * and current accumulator value, and calculates the next accumulator value.\r\n */\r\npublic inline fun <R> IntArray.foldRightIndexed(initial: R, operation: (index: Int, Int, acc: R) -> R): R {\r\n    var index = lastIndex\r\n    var accumulator = initial\r\n    while (index >= 0) {\r\n        accumulator = operation(index, get(index), accumulator)\r\n        --index\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from right to left\r\n * to each element with its index in the original array and current accumulator value.\r\n * @param [operation] function that takes the index of an element, the element itself\r\n * and current accumulator value, and calculates the next accumulator value.\r\n */\r\npublic inline fun <R> LongArray.foldRightIndexed(initial: R, operation: (index: Int, Long, acc: R) -> R): R {\r\n    var index = lastIndex\r\n    var accumulator = initial\r\n    while (index >= 0) {\r\n        accumulator = operation(index, get(index), accumulator)\r\n        --index\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from right to left\r\n * to each element with its index in the original array and current accumulator value.\r\n * @param [operation] function that takes the index of an element, the element itself\r\n * and current accumulator value, and calculates the next accumulator value.\r\n */\r\npublic inline fun <R> FloatArray.foldRightIndexed(initial: R, operation: (index: Int, Float, acc: R) -> R): R {\r\n    var index = lastIndex\r\n    var accumulator = initial\r\n    while (index >= 0) {\r\n        accumulator = operation(index, get(index), accumulator)\r\n        --index\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from right to left\r\n * to each element with its index in the original array and current accumulator value.\r\n * @param [operation] function that takes the index of an element, the element itself\r\n * and current accumulator value, and calculates the next accumulator value.\r\n */\r\npublic inline fun <R> DoubleArray.foldRightIndexed(initial: R, operation: (index: Int, Double, acc: R) -> R): R {\r\n    var index = lastIndex\r\n    var accumulator = initial\r\n    while (index >= 0) {\r\n        accumulator = operation(index, get(index), accumulator)\r\n        --index\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from right to left\r\n * to each element with its index in the original array and current accumulator value.\r\n * @param [operation] function that takes the index of an element, the element itself\r\n * and current accumulator value, and calculates the next accumulator value.\r\n */\r\npublic inline fun <R> BooleanArray.foldRightIndexed(initial: R, operation: (index: Int, Boolean, acc: R) -> R): R {\r\n    var index = lastIndex\r\n    var accumulator = initial\r\n    while (index >= 0) {\r\n        accumulator = operation(index, get(index), accumulator)\r\n        --index\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from right to left\r\n * to each element with its index in the original array and current accumulator value.\r\n * @param [operation] function that takes the index of an element, the element itself\r\n * and current accumulator value, and calculates the next accumulator value.\r\n */\r\npublic inline fun <R> CharArray.foldRightIndexed(initial: R, operation: (index: Int, Char, acc: R) -> R): R {\r\n    var index = lastIndex\r\n    var accumulator = initial\r\n    while (index >= 0) {\r\n        accumulator = operation(index, get(index), accumulator)\r\n        --index\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Performs the given [action] on each element.\r\n */\r\npublic inline fun <T> Array<out T>.forEach(action: (T) -> Unit): Unit {\r\n    for (element in this) action(element)\r\n}\r\n\r\n/**\r\n * Performs the given [action] on each element.\r\n */\r\npublic inline fun ByteArray.forEach(action: (Byte) -> Unit): Unit {\r\n    for (element in this) action(element)\r\n}\r\n\r\n/**\r\n * Performs the given [action] on each element.\r\n */\r\npublic inline fun ShortArray.forEach(action: (Short) -> Unit): Unit {\r\n    for (element in this) action(element)\r\n}\r\n\r\n/**\r\n * Performs the given [action] on each element.\r\n */\r\npublic inline fun IntArray.forEach(action: (Int) -> Unit): Unit {\r\n    for (element in this) action(element)\r\n}\r\n\r\n/**\r\n * Performs the given [action] on each element.\r\n */\r\npublic inline fun LongArray.forEach(action: (Long) -> Unit): Unit {\r\n    for (element in this) action(element)\r\n}\r\n\r\n/**\r\n * Performs the given [action] on each element.\r\n */\r\npublic inline fun FloatArray.forEach(action: (Float) -> Unit): Unit {\r\n    for (element in this) action(element)\r\n}\r\n\r\n/**\r\n * Performs the given [action] on each element.\r\n */\r\npublic inline fun DoubleArray.forEach(action: (Double) -> Unit): Unit {\r\n    for (element in this) action(element)\r\n}\r\n\r\n/**\r\n * Performs the given [action] on each element.\r\n */\r\npublic inline fun BooleanArray.forEach(action: (Boolean) -> Unit): Unit {\r\n    for (element in this) action(element)\r\n}\r\n\r\n/**\r\n * Performs the given [action] on each element.\r\n */\r\npublic inline fun CharArray.forEach(action: (Char) -> Unit): Unit {\r\n    for (element in this) action(element)\r\n}\r\n\r\n/**\r\n * Performs the given [action] on each element, providing sequential index with the element.\r\n * @param [action] function that takes the index of an element and the element itself\r\n * and performs the desired action on the element.\r\n */\r\npublic inline fun <T> Array<out T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\r\n    var index = 0\r\n    for (item in this) action(index++, item)\r\n}\r\n\r\n/**\r\n * Performs the given [action] on each element, providing sequential index with the element.\r\n * @param [action] function that takes the index of an element and the element itself\r\n * and performs the desired action on the element.\r\n */\r\npublic inline fun ByteArray.forEachIndexed(action: (index: Int, Byte) -> Unit): Unit {\r\n    var index = 0\r\n    for (item in this) action(index++, item)\r\n}\r\n\r\n/**\r\n * Performs the given [action] on each element, providing sequential index with the element.\r\n * @param [action] function that takes the index of an element and the element itself\r\n * and performs the desired action on the element.\r\n */\r\npublic inline fun ShortArray.forEachIndexed(action: (index: Int, Short) -> Unit): Unit {\r\n    var index = 0\r\n    for (item in this) action(index++, item)\r\n}\r\n\r\n/**\r\n * Performs the given [action] on each element, providing sequential index with the element.\r\n * @param [action] function that takes the index of an element and the element itself\r\n * and performs the desired action on the element.\r\n */\r\npublic inline fun IntArray.forEachIndexed(action: (index: Int, Int) -> Unit): Unit {\r\n    var index = 0\r\n    for (item in this) action(index++, item)\r\n}\r\n\r\n/**\r\n * Performs the given [action] on each element, providing sequential index with the element.\r\n * @param [action] function that takes the index of an element and the element itself\r\n * and performs the desired action on the element.\r\n */\r\npublic inline fun LongArray.forEachIndexed(action: (index: Int, Long) -> Unit): Unit {\r\n    var index = 0\r\n    for (item in this) action(index++, item)\r\n}\r\n\r\n/**\r\n * Performs the given [action] on each element, providing sequential index with the element.\r\n * @param [action] function that takes the index of an element and the element itself\r\n * and performs the desired action on the element.\r\n */\r\npublic inline fun FloatArray.forEachIndexed(action: (index: Int, Float) -> Unit): Unit {\r\n    var index = 0\r\n    for (item in this) action(index++, item)\r\n}\r\n\r\n/**\r\n * Performs the given [action] on each element, providing sequential index with the element.\r\n * @param [action] function that takes the index of an element and the element itself\r\n * and performs the desired action on the element.\r\n */\r\npublic inline fun DoubleArray.forEachIndexed(action: (index: Int, Double) -> Unit): Unit {\r\n    var index = 0\r\n    for (item in this) action(index++, item)\r\n}\r\n\r\n/**\r\n * Performs the given [action] on each element, providing sequential index with the element.\r\n * @param [action] function that takes the index of an element and the element itself\r\n * and performs the desired action on the element.\r\n */\r\npublic inline fun BooleanArray.forEachIndexed(action: (index: Int, Boolean) -> Unit): Unit {\r\n    var index = 0\r\n    for (item in this) action(index++, item)\r\n}\r\n\r\n/**\r\n * Performs the given [action] on each element, providing sequential index with the element.\r\n * @param [action] function that takes the index of an element and the element itself\r\n * and performs the desired action on the element.\r\n */\r\npublic inline fun CharArray.forEachIndexed(action: (index: Int, Char) -> Unit): Unit {\r\n    var index = 0\r\n    for (item in this) action(index++, item)\r\n}\r\n\r\n/**\r\n * Returns the largest element or `null` if there are no elements.\r\n * \r\n * If any of elements is `NaN` returns `NaN`.\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic fun Array<out Double>.max(): Double? {\r\n    if (isEmpty()) return null\r\n    var max = this[0]\r\n    if (max.isNaN()) return max\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (e.isNaN()) return e\r\n        if (max < e) max = e\r\n    }\r\n    return max\r\n}\r\n\r\n/**\r\n * Returns the largest element or `null` if there are no elements.\r\n * \r\n * If any of elements is `NaN` returns `NaN`.\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic fun Array<out Float>.max(): Float? {\r\n    if (isEmpty()) return null\r\n    var max = this[0]\r\n    if (max.isNaN()) return max\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (e.isNaN()) return e\r\n        if (max < e) max = e\r\n    }\r\n    return max\r\n}\r\n\r\n/**\r\n * Returns the largest element or `null` if there are no elements.\r\n */\r\npublic fun <T : Comparable<T>> Array<out T>.max(): T? {\r\n    if (isEmpty()) return null\r\n    var max = this[0]\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (max < e) max = e\r\n    }\r\n    return max\r\n}\r\n\r\n/**\r\n * Returns the largest element or `null` if there are no elements.\r\n */\r\npublic fun ByteArray.max(): Byte? {\r\n    if (isEmpty()) return null\r\n    var max = this[0]\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (max < e) max = e\r\n    }\r\n    return max\r\n}\r\n\r\n/**\r\n * Returns the largest element or `null` if there are no elements.\r\n */\r\npublic fun ShortArray.max(): Short? {\r\n    if (isEmpty()) return null\r\n    var max = this[0]\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (max < e) max = e\r\n    }\r\n    return max\r\n}\r\n\r\n/**\r\n * Returns the largest element or `null` if there are no elements.\r\n */\r\npublic fun IntArray.max(): Int? {\r\n    if (isEmpty()) return null\r\n    var max = this[0]\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (max < e) max = e\r\n    }\r\n    return max\r\n}\r\n\r\n/**\r\n * Returns the largest element or `null` if there are no elements.\r\n */\r\npublic fun LongArray.max(): Long? {\r\n    if (isEmpty()) return null\r\n    var max = this[0]\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (max < e) max = e\r\n    }\r\n    return max\r\n}\r\n\r\n/**\r\n * Returns the largest element or `null` if there are no elements.\r\n * \r\n * If any of elements is `NaN` returns `NaN`.\r\n */\r\npublic fun FloatArray.max(): Float? {\r\n    if (isEmpty()) return null\r\n    var max = this[0]\r\n    if (max.isNaN()) return max\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (e.isNaN()) return e\r\n        if (max < e) max = e\r\n    }\r\n    return max\r\n}\r\n\r\n/**\r\n * Returns the largest element or `null` if there are no elements.\r\n * \r\n * If any of elements is `NaN` returns `NaN`.\r\n */\r\npublic fun DoubleArray.max(): Double? {\r\n    if (isEmpty()) return null\r\n    var max = this[0]\r\n    if (max.isNaN()) return max\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (e.isNaN()) return e\r\n        if (max < e) max = e\r\n    }\r\n    return max\r\n}\r\n\r\n/**\r\n * Returns the largest element or `null` if there are no elements.\r\n */\r\npublic fun CharArray.max(): Char? {\r\n    if (isEmpty()) return null\r\n    var max = this[0]\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (max < e) max = e\r\n    }\r\n    return max\r\n}\r\n\r\n/**\r\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.maxBy\r\n */\r\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxBy(selector: (T) -> R): T? {\r\n    if (isEmpty()) return null\r\n    var maxElem = this[0]\r\n    var maxValue = selector(maxElem)\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        val v = selector(e)\r\n        if (maxValue < v) {\r\n            maxElem = e\r\n            maxValue = v\r\n        }\r\n    }\r\n    return maxElem\r\n}\r\n\r\n/**\r\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.maxBy\r\n */\r\npublic inline fun <R : Comparable<R>> ByteArray.maxBy(selector: (Byte) -> R): Byte? {\r\n    if (isEmpty()) return null\r\n    var maxElem = this[0]\r\n    var maxValue = selector(maxElem)\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        val v = selector(e)\r\n        if (maxValue < v) {\r\n            maxElem = e\r\n            maxValue = v\r\n        }\r\n    }\r\n    return maxElem\r\n}\r\n\r\n/**\r\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.maxBy\r\n */\r\npublic inline fun <R : Comparable<R>> ShortArray.maxBy(selector: (Short) -> R): Short? {\r\n    if (isEmpty()) return null\r\n    var maxElem = this[0]\r\n    var maxValue = selector(maxElem)\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        val v = selector(e)\r\n        if (maxValue < v) {\r\n            maxElem = e\r\n            maxValue = v\r\n        }\r\n    }\r\n    return maxElem\r\n}\r\n\r\n/**\r\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.maxBy\r\n */\r\npublic inline fun <R : Comparable<R>> IntArray.maxBy(selector: (Int) -> R): Int? {\r\n    if (isEmpty()) return null\r\n    var maxElem = this[0]\r\n    var maxValue = selector(maxElem)\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        val v = selector(e)\r\n        if (maxValue < v) {\r\n            maxElem = e\r\n            maxValue = v\r\n        }\r\n    }\r\n    return maxElem\r\n}\r\n\r\n/**\r\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.maxBy\r\n */\r\npublic inline fun <R : Comparable<R>> LongArray.maxBy(selector: (Long) -> R): Long? {\r\n    if (isEmpty()) return null\r\n    var maxElem = this[0]\r\n    var maxValue = selector(maxElem)\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        val v = selector(e)\r\n        if (maxValue < v) {\r\n            maxElem = e\r\n            maxValue = v\r\n        }\r\n    }\r\n    return maxElem\r\n}\r\n\r\n/**\r\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.maxBy\r\n */\r\npublic inline fun <R : Comparable<R>> FloatArray.maxBy(selector: (Float) -> R): Float? {\r\n    if (isEmpty()) return null\r\n    var maxElem = this[0]\r\n    var maxValue = selector(maxElem)\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        val v = selector(e)\r\n        if (maxValue < v) {\r\n            maxElem = e\r\n            maxValue = v\r\n        }\r\n    }\r\n    return maxElem\r\n}\r\n\r\n/**\r\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.maxBy\r\n */\r\npublic inline fun <R : Comparable<R>> DoubleArray.maxBy(selector: (Double) -> R): Double? {\r\n    if (isEmpty()) return null\r\n    var maxElem = this[0]\r\n    var maxValue = selector(maxElem)\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        val v = selector(e)\r\n        if (maxValue < v) {\r\n            maxElem = e\r\n            maxValue = v\r\n        }\r\n    }\r\n    return maxElem\r\n}\r\n\r\n/**\r\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.maxBy\r\n */\r\npublic inline fun <R : Comparable<R>> BooleanArray.maxBy(selector: (Boolean) -> R): Boolean? {\r\n    if (isEmpty()) return null\r\n    var maxElem = this[0]\r\n    var maxValue = selector(maxElem)\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        val v = selector(e)\r\n        if (maxValue < v) {\r\n            maxElem = e\r\n            maxValue = v\r\n        }\r\n    }\r\n    return maxElem\r\n}\r\n\r\n/**\r\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.maxBy\r\n */\r\npublic inline fun <R : Comparable<R>> CharArray.maxBy(selector: (Char) -> R): Char? {\r\n    if (isEmpty()) return null\r\n    var maxElem = this[0]\r\n    var maxValue = selector(maxElem)\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        val v = selector(e)\r\n        if (maxValue < v) {\r\n            maxElem = e\r\n            maxValue = v\r\n        }\r\n    }\r\n    return maxElem\r\n}\r\n\r\n/**\r\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\r\n */\r\npublic fun <T> Array<out T>.maxWith(comparator: Comparator<in T>): T? {\r\n    if (isEmpty()) return null\r\n    var max = this[0]\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (comparator.compare(max, e) < 0) max = e\r\n    }\r\n    return max\r\n}\r\n\r\n/**\r\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\r\n */\r\npublic fun ByteArray.maxWith(comparator: Comparator<in Byte>): Byte? {\r\n    if (isEmpty()) return null\r\n    var max = this[0]\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (comparator.compare(max, e) < 0) max = e\r\n    }\r\n    return max\r\n}\r\n\r\n/**\r\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\r\n */\r\npublic fun ShortArray.maxWith(comparator: Comparator<in Short>): Short? {\r\n    if (isEmpty()) return null\r\n    var max = this[0]\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (comparator.compare(max, e) < 0) max = e\r\n    }\r\n    return max\r\n}\r\n\r\n/**\r\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\r\n */\r\npublic fun IntArray.maxWith(comparator: Comparator<in Int>): Int? {\r\n    if (isEmpty()) return null\r\n    var max = this[0]\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (comparator.compare(max, e) < 0) max = e\r\n    }\r\n    return max\r\n}\r\n\r\n/**\r\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\r\n */\r\npublic fun LongArray.maxWith(comparator: Comparator<in Long>): Long? {\r\n    if (isEmpty()) return null\r\n    var max = this[0]\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (comparator.compare(max, e) < 0) max = e\r\n    }\r\n    return max\r\n}\r\n\r\n/**\r\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\r\n */\r\npublic fun FloatArray.maxWith(comparator: Comparator<in Float>): Float? {\r\n    if (isEmpty()) return null\r\n    var max = this[0]\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (comparator.compare(max, e) < 0) max = e\r\n    }\r\n    return max\r\n}\r\n\r\n/**\r\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\r\n */\r\npublic fun DoubleArray.maxWith(comparator: Comparator<in Double>): Double? {\r\n    if (isEmpty()) return null\r\n    var max = this[0]\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (comparator.compare(max, e) < 0) max = e\r\n    }\r\n    return max\r\n}\r\n\r\n/**\r\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\r\n */\r\npublic fun BooleanArray.maxWith(comparator: Comparator<in Boolean>): Boolean? {\r\n    if (isEmpty()) return null\r\n    var max = this[0]\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (comparator.compare(max, e) < 0) max = e\r\n    }\r\n    return max\r\n}\r\n\r\n/**\r\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\r\n */\r\npublic fun CharArray.maxWith(comparator: Comparator<in Char>): Char? {\r\n    if (isEmpty()) return null\r\n    var max = this[0]\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (comparator.compare(max, e) < 0) max = e\r\n    }\r\n    return max\r\n}\r\n\r\n/**\r\n * Returns the smallest element or `null` if there are no elements.\r\n * \r\n * If any of elements is `NaN` returns `NaN`.\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic fun Array<out Double>.min(): Double? {\r\n    if (isEmpty()) return null\r\n    var min = this[0]\r\n    if (min.isNaN()) return min\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (e.isNaN()) return e\r\n        if (min > e) min = e\r\n    }\r\n    return min\r\n}\r\n\r\n/**\r\n * Returns the smallest element or `null` if there are no elements.\r\n * \r\n * If any of elements is `NaN` returns `NaN`.\r\n */\r\n@SinceKotlin(\"1.1\")\r\npublic fun Array<out Float>.min(): Float? {\r\n    if (isEmpty()) return null\r\n    var min = this[0]\r\n    if (min.isNaN()) return min\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (e.isNaN()) return e\r\n        if (min > e) min = e\r\n    }\r\n    return min\r\n}\r\n\r\n/**\r\n * Returns the smallest element or `null` if there are no elements.\r\n */\r\npublic fun <T : Comparable<T>> Array<out T>.min(): T? {\r\n    if (isEmpty()) return null\r\n    var min = this[0]\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (min > e) min = e\r\n    }\r\n    return min\r\n}\r\n\r\n/**\r\n * Returns the smallest element or `null` if there are no elements.\r\n */\r\npublic fun ByteArray.min(): Byte? {\r\n    if (isEmpty()) return null\r\n    var min = this[0]\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (min > e) min = e\r\n    }\r\n    return min\r\n}\r\n\r\n/**\r\n * Returns the smallest element or `null` if there are no elements.\r\n */\r\npublic fun ShortArray.min(): Short? {\r\n    if (isEmpty()) return null\r\n    var min = this[0]\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (min > e) min = e\r\n    }\r\n    return min\r\n}\r\n\r\n/**\r\n * Returns the smallest element or `null` if there are no elements.\r\n */\r\npublic fun IntArray.min(): Int? {\r\n    if (isEmpty()) return null\r\n    var min = this[0]\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (min > e) min = e\r\n    }\r\n    return min\r\n}\r\n\r\n/**\r\n * Returns the smallest element or `null` if there are no elements.\r\n */\r\npublic fun LongArray.min(): Long? {\r\n    if (isEmpty()) return null\r\n    var min = this[0]\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (min > e) min = e\r\n    }\r\n    return min\r\n}\r\n\r\n/**\r\n * Returns the smallest element or `null` if there are no elements.\r\n * \r\n * If any of elements is `NaN` returns `NaN`.\r\n */\r\npublic fun FloatArray.min(): Float? {\r\n    if (isEmpty()) return null\r\n    var min = this[0]\r\n    if (min.isNaN()) return min\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (e.isNaN()) return e\r\n        if (min > e) min = e\r\n    }\r\n    return min\r\n}\r\n\r\n/**\r\n * Returns the smallest element or `null` if there are no elements.\r\n * \r\n * If any of elements is `NaN` returns `NaN`.\r\n */\r\npublic fun DoubleArray.min(): Double? {\r\n    if (isEmpty()) return null\r\n    var min = this[0]\r\n    if (min.isNaN()) return min\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (e.isNaN()) return e\r\n        if (min > e) min = e\r\n    }\r\n    return min\r\n}\r\n\r\n/**\r\n * Returns the smallest element or `null` if there are no elements.\r\n */\r\npublic fun CharArray.min(): Char? {\r\n    if (isEmpty()) return null\r\n    var min = this[0]\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (min > e) min = e\r\n    }\r\n    return min\r\n}\r\n\r\n/**\r\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.minBy\r\n */\r\npublic inline fun <T, R : Comparable<R>> Array<out T>.minBy(selector: (T) -> R): T? {\r\n    if (isEmpty()) return null\r\n    var minElem = this[0]\r\n    var minValue = selector(minElem)\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        val v = selector(e)\r\n        if (minValue > v) {\r\n            minElem = e\r\n            minValue = v\r\n        }\r\n    }\r\n    return minElem\r\n}\r\n\r\n/**\r\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.minBy\r\n */\r\npublic inline fun <R : Comparable<R>> ByteArray.minBy(selector: (Byte) -> R): Byte? {\r\n    if (isEmpty()) return null\r\n    var minElem = this[0]\r\n    var minValue = selector(minElem)\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        val v = selector(e)\r\n        if (minValue > v) {\r\n            minElem = e\r\n            minValue = v\r\n        }\r\n    }\r\n    return minElem\r\n}\r\n\r\n/**\r\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.minBy\r\n */\r\npublic inline fun <R : Comparable<R>> ShortArray.minBy(selector: (Short) -> R): Short? {\r\n    if (isEmpty()) return null\r\n    var minElem = this[0]\r\n    var minValue = selector(minElem)\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        val v = selector(e)\r\n        if (minValue > v) {\r\n            minElem = e\r\n            minValue = v\r\n        }\r\n    }\r\n    return minElem\r\n}\r\n\r\n/**\r\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.minBy\r\n */\r\npublic inline fun <R : Comparable<R>> IntArray.minBy(selector: (Int) -> R): Int? {\r\n    if (isEmpty()) return null\r\n    var minElem = this[0]\r\n    var minValue = selector(minElem)\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        val v = selector(e)\r\n        if (minValue > v) {\r\n            minElem = e\r\n            minValue = v\r\n        }\r\n    }\r\n    return minElem\r\n}\r\n\r\n/**\r\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.minBy\r\n */\r\npublic inline fun <R : Comparable<R>> LongArray.minBy(selector: (Long) -> R): Long? {\r\n    if (isEmpty()) return null\r\n    var minElem = this[0]\r\n    var minValue = selector(minElem)\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        val v = selector(e)\r\n        if (minValue > v) {\r\n            minElem = e\r\n            minValue = v\r\n        }\r\n    }\r\n    return minElem\r\n}\r\n\r\n/**\r\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.minBy\r\n */\r\npublic inline fun <R : Comparable<R>> FloatArray.minBy(selector: (Float) -> R): Float? {\r\n    if (isEmpty()) return null\r\n    var minElem = this[0]\r\n    var minValue = selector(minElem)\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        val v = selector(e)\r\n        if (minValue > v) {\r\n            minElem = e\r\n            minValue = v\r\n        }\r\n    }\r\n    return minElem\r\n}\r\n\r\n/**\r\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.minBy\r\n */\r\npublic inline fun <R : Comparable<R>> DoubleArray.minBy(selector: (Double) -> R): Double? {\r\n    if (isEmpty()) return null\r\n    var minElem = this[0]\r\n    var minValue = selector(minElem)\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        val v = selector(e)\r\n        if (minValue > v) {\r\n            minElem = e\r\n            minValue = v\r\n        }\r\n    }\r\n    return minElem\r\n}\r\n\r\n/**\r\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.minBy\r\n */\r\npublic inline fun <R : Comparable<R>> BooleanArray.minBy(selector: (Boolean) -> R): Boolean? {\r\n    if (isEmpty()) return null\r\n    var minElem = this[0]\r\n    var minValue = selector(minElem)\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        val v = selector(e)\r\n        if (minValue > v) {\r\n            minElem = e\r\n            minValue = v\r\n        }\r\n    }\r\n    return minElem\r\n}\r\n\r\n/**\r\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.minBy\r\n */\r\npublic inline fun <R : Comparable<R>> CharArray.minBy(selector: (Char) -> R): Char? {\r\n    if (isEmpty()) return null\r\n    var minElem = this[0]\r\n    var minValue = selector(minElem)\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        val v = selector(e)\r\n        if (minValue > v) {\r\n            minElem = e\r\n            minValue = v\r\n        }\r\n    }\r\n    return minElem\r\n}\r\n\r\n/**\r\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\r\n */\r\npublic fun <T> Array<out T>.minWith(comparator: Comparator<in T>): T? {\r\n    if (isEmpty()) return null\r\n    var min = this[0]\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (comparator.compare(min, e) > 0) min = e\r\n    }\r\n    return min\r\n}\r\n\r\n/**\r\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\r\n */\r\npublic fun ByteArray.minWith(comparator: Comparator<in Byte>): Byte? {\r\n    if (isEmpty()) return null\r\n    var min = this[0]\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (comparator.compare(min, e) > 0) min = e\r\n    }\r\n    return min\r\n}\r\n\r\n/**\r\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\r\n */\r\npublic fun ShortArray.minWith(comparator: Comparator<in Short>): Short? {\r\n    if (isEmpty()) return null\r\n    var min = this[0]\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (comparator.compare(min, e) > 0) min = e\r\n    }\r\n    return min\r\n}\r\n\r\n/**\r\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\r\n */\r\npublic fun IntArray.minWith(comparator: Comparator<in Int>): Int? {\r\n    if (isEmpty()) return null\r\n    var min = this[0]\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (comparator.compare(min, e) > 0) min = e\r\n    }\r\n    return min\r\n}\r\n\r\n/**\r\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\r\n */\r\npublic fun LongArray.minWith(comparator: Comparator<in Long>): Long? {\r\n    if (isEmpty()) return null\r\n    var min = this[0]\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (comparator.compare(min, e) > 0) min = e\r\n    }\r\n    return min\r\n}\r\n\r\n/**\r\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\r\n */\r\npublic fun FloatArray.minWith(comparator: Comparator<in Float>): Float? {\r\n    if (isEmpty()) return null\r\n    var min = this[0]\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (comparator.compare(min, e) > 0) min = e\r\n    }\r\n    return min\r\n}\r\n\r\n/**\r\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\r\n */\r\npublic fun DoubleArray.minWith(comparator: Comparator<in Double>): Double? {\r\n    if (isEmpty()) return null\r\n    var min = this[0]\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (comparator.compare(min, e) > 0) min = e\r\n    }\r\n    return min\r\n}\r\n\r\n/**\r\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\r\n */\r\npublic fun BooleanArray.minWith(comparator: Comparator<in Boolean>): Boolean? {\r\n    if (isEmpty()) return null\r\n    var min = this[0]\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (comparator.compare(min, e) > 0) min = e\r\n    }\r\n    return min\r\n}\r\n\r\n/**\r\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\r\n */\r\npublic fun CharArray.minWith(comparator: Comparator<in Char>): Char? {\r\n    if (isEmpty()) return null\r\n    var min = this[0]\r\n    for (i in 1..lastIndex) {\r\n        val e = this[i]\r\n        if (comparator.compare(min, e) > 0) min = e\r\n    }\r\n    return min\r\n}\r\n\r\n/**\r\n * Returns `true` if the array has no elements.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.none\r\n */\r\npublic fun <T> Array<out T>.none(): Boolean {\r\n    return isEmpty()\r\n}\r\n\r\n/**\r\n * Returns `true` if the array has no elements.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.none\r\n */\r\npublic fun ByteArray.none(): Boolean {\r\n    return isEmpty()\r\n}\r\n\r\n/**\r\n * Returns `true` if the array has no elements.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.none\r\n */\r\npublic fun ShortArray.none(): Boolean {\r\n    return isEmpty()\r\n}\r\n\r\n/**\r\n * Returns `true` if the array has no elements.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.none\r\n */\r\npublic fun IntArray.none(): Boolean {\r\n    return isEmpty()\r\n}\r\n\r\n/**\r\n * Returns `true` if the array has no elements.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.none\r\n */\r\npublic fun LongArray.none(): Boolean {\r\n    return isEmpty()\r\n}\r\n\r\n/**\r\n * Returns `true` if the array has no elements.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.none\r\n */\r\npublic fun FloatArray.none(): Boolean {\r\n    return isEmpty()\r\n}\r\n\r\n/**\r\n * Returns `true` if the array has no elements.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.none\r\n */\r\npublic fun DoubleArray.none(): Boolean {\r\n    return isEmpty()\r\n}\r\n\r\n/**\r\n * Returns `true` if the array has no elements.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.none\r\n */\r\npublic fun BooleanArray.none(): Boolean {\r\n    return isEmpty()\r\n}\r\n\r\n/**\r\n * Returns `true` if the array has no elements.\r\n * \r\n * @sample samples.collections.Collections.Aggregates.none\r\n */\r\npublic fun CharArray.none(): Boolean {\r\n    return isEmpty()\r\n}\r\n\r\n/**\r\n * Returns `true` if no elements match the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\r\n */\r\npublic inline fun <T> Array<out T>.none(predicate: (T) -> Boolean): Boolean {\r\n    for (element in this) if (predicate(element)) return false\r\n    return true\r\n}\r\n\r\n/**\r\n * Returns `true` if no elements match the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\r\n */\r\npublic inline fun ByteArray.none(predicate: (Byte) -> Boolean): Boolean {\r\n    for (element in this) if (predicate(element)) return false\r\n    return true\r\n}\r\n\r\n/**\r\n * Returns `true` if no elements match the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\r\n */\r\npublic inline fun ShortArray.none(predicate: (Short) -> Boolean): Boolean {\r\n    for (element in this) if (predicate(element)) return false\r\n    return true\r\n}\r\n\r\n/**\r\n * Returns `true` if no elements match the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\r\n */\r\npublic inline fun IntArray.none(predicate: (Int) -> Boolean): Boolean {\r\n    for (element in this) if (predicate(element)) return false\r\n    return true\r\n}\r\n\r\n/**\r\n * Returns `true` if no elements match the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\r\n */\r\npublic inline fun LongArray.none(predicate: (Long) -> Boolean): Boolean {\r\n    for (element in this) if (predicate(element)) return false\r\n    return true\r\n}\r\n\r\n/**\r\n * Returns `true` if no elements match the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\r\n */\r\npublic inline fun FloatArray.none(predicate: (Float) -> Boolean): Boolean {\r\n    for (element in this) if (predicate(element)) return false\r\n    return true\r\n}\r\n\r\n/**\r\n * Returns `true` if no elements match the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\r\n */\r\npublic inline fun DoubleArray.none(predicate: (Double) -> Boolean): Boolean {\r\n    for (element in this) if (predicate(element)) return false\r\n    return true\r\n}\r\n\r\n/**\r\n * Returns `true` if no elements match the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\r\n */\r\npublic inline fun BooleanArray.none(predicate: (Boolean) -> Boolean): Boolean {\r\n    for (element in this) if (predicate(element)) return false\r\n    return true\r\n}\r\n\r\n/**\r\n * Returns `true` if no elements match the given [predicate].\r\n * \r\n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\r\n */\r\npublic inline fun CharArray.none(predicate: (Char) -> Boolean): Boolean {\r\n    for (element in this) if (predicate(element)) return false\r\n    return true\r\n}\r\n\r\n/**\r\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\r\n */\r\npublic inline fun <S, T : S> Array<out T>.reduce(operation: (acc: S, T) -> S): S {\r\n    if (isEmpty())\r\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator: S = this[0]\r\n    for (index in 1..lastIndex) {\r\n        accumulator = operation(accumulator, this[index])\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\r\n */\r\npublic inline fun ByteArray.reduce(operation: (acc: Byte, Byte) -> Byte): Byte {\r\n    if (isEmpty())\r\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator = this[0]\r\n    for (index in 1..lastIndex) {\r\n        accumulator = operation(accumulator, this[index])\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\r\n */\r\npublic inline fun ShortArray.reduce(operation: (acc: Short, Short) -> Short): Short {\r\n    if (isEmpty())\r\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator = this[0]\r\n    for (index in 1..lastIndex) {\r\n        accumulator = operation(accumulator, this[index])\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\r\n */\r\npublic inline fun IntArray.reduce(operation: (acc: Int, Int) -> Int): Int {\r\n    if (isEmpty())\r\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator = this[0]\r\n    for (index in 1..lastIndex) {\r\n        accumulator = operation(accumulator, this[index])\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\r\n */\r\npublic inline fun LongArray.reduce(operation: (acc: Long, Long) -> Long): Long {\r\n    if (isEmpty())\r\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator = this[0]\r\n    for (index in 1..lastIndex) {\r\n        accumulator = operation(accumulator, this[index])\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\r\n */\r\npublic inline fun FloatArray.reduce(operation: (acc: Float, Float) -> Float): Float {\r\n    if (isEmpty())\r\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator = this[0]\r\n    for (index in 1..lastIndex) {\r\n        accumulator = operation(accumulator, this[index])\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\r\n */\r\npublic inline fun DoubleArray.reduce(operation: (acc: Double, Double) -> Double): Double {\r\n    if (isEmpty())\r\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator = this[0]\r\n    for (index in 1..lastIndex) {\r\n        accumulator = operation(accumulator, this[index])\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\r\n */\r\npublic inline fun BooleanArray.reduce(operation: (acc: Boolean, Boolean) -> Boolean): Boolean {\r\n    if (isEmpty())\r\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator = this[0]\r\n    for (index in 1..lastIndex) {\r\n        accumulator = operation(accumulator, this[index])\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\r\n */\r\npublic inline fun CharArray.reduce(operation: (acc: Char, Char) -> Char): Char {\r\n    if (isEmpty())\r\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator = this[0]\r\n    for (index in 1..lastIndex) {\r\n        accumulator = operation(accumulator, this[index])\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with the first element and applying [operation] from left to right\r\n * to current accumulator value and each element with its index in the original array.\r\n * @param [operation] function that takes the index of an element, current accumulator value\r\n * and the element itself and calculates the next accumulator value.\r\n */\r\npublic inline fun <S, T : S> Array<out T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\r\n    if (isEmpty())\r\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator: S = this[0]\r\n    for (index in 1..lastIndex) {\r\n        accumulator = operation(index, accumulator, this[index])\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with the first element and applying [operation] from left to right\r\n * to current accumulator value and each element with its index in the original array.\r\n * @param [operation] function that takes the index of an element, current accumulator value\r\n * and the element itself and calculates the next accumulator value.\r\n */\r\npublic inline fun ByteArray.reduceIndexed(operation: (index: Int, acc: Byte, Byte) -> Byte): Byte {\r\n    if (isEmpty())\r\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator = this[0]\r\n    for (index in 1..lastIndex) {\r\n        accumulator = operation(index, accumulator, this[index])\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with the first element and applying [operation] from left to right\r\n * to current accumulator value and each element with its index in the original array.\r\n * @param [operation] function that takes the index of an element, current accumulator value\r\n * and the element itself and calculates the next accumulator value.\r\n */\r\npublic inline fun ShortArray.reduceIndexed(operation: (index: Int, acc: Short, Short) -> Short): Short {\r\n    if (isEmpty())\r\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator = this[0]\r\n    for (index in 1..lastIndex) {\r\n        accumulator = operation(index, accumulator, this[index])\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with the first element and applying [operation] from left to right\r\n * to current accumulator value and each element with its index in the original array.\r\n * @param [operation] function that takes the index of an element, current accumulator value\r\n * and the element itself and calculates the next accumulator value.\r\n */\r\npublic inline fun IntArray.reduceIndexed(operation: (index: Int, acc: Int, Int) -> Int): Int {\r\n    if (isEmpty())\r\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator = this[0]\r\n    for (index in 1..lastIndex) {\r\n        accumulator = operation(index, accumulator, this[index])\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with the first element and applying [operation] from left to right\r\n * to current accumulator value and each element with its index in the original array.\r\n * @param [operation] function that takes the index of an element, current accumulator value\r\n * and the element itself and calculates the next accumulator value.\r\n */\r\npublic inline fun LongArray.reduceIndexed(operation: (index: Int, acc: Long, Long) -> Long): Long {\r\n    if (isEmpty())\r\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator = this[0]\r\n    for (index in 1..lastIndex) {\r\n        accumulator = operation(index, accumulator, this[index])\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with the first element and applying [operation] from left to right\r\n * to current accumulator value and each element with its index in the original array.\r\n * @param [operation] function that takes the index of an element, current accumulator value\r\n * and the element itself and calculates the next accumulator value.\r\n */\r\npublic inline fun FloatArray.reduceIndexed(operation: (index: Int, acc: Float, Float) -> Float): Float {\r\n    if (isEmpty())\r\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator = this[0]\r\n    for (index in 1..lastIndex) {\r\n        accumulator = operation(index, accumulator, this[index])\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with the first element and applying [operation] from left to right\r\n * to current accumulator value and each element with its index in the original array.\r\n * @param [operation] function that takes the index of an element, current accumulator value\r\n * and the element itself and calculates the next accumulator value.\r\n */\r\npublic inline fun DoubleArray.reduceIndexed(operation: (index: Int, acc: Double, Double) -> Double): Double {\r\n    if (isEmpty())\r\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator = this[0]\r\n    for (index in 1..lastIndex) {\r\n        accumulator = operation(index, accumulator, this[index])\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with the first element and applying [operation] from left to right\r\n * to current accumulator value and each element with its index in the original array.\r\n * @param [operation] function that takes the index of an element, current accumulator value\r\n * and the element itself and calculates the next accumulator value.\r\n */\r\npublic inline fun BooleanArray.reduceIndexed(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): Boolean {\r\n    if (isEmpty())\r\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator = this[0]\r\n    for (index in 1..lastIndex) {\r\n        accumulator = operation(index, accumulator, this[index])\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with the first element and applying [operation] from left to right\r\n * to current accumulator value and each element with its index in the original array.\r\n * @param [operation] function that takes the index of an element, current accumulator value\r\n * and the element itself and calculates the next accumulator value.\r\n */\r\npublic inline fun CharArray.reduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): Char {\r\n    if (isEmpty())\r\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator = this[0]\r\n    for (index in 1..lastIndex) {\r\n        accumulator = operation(index, accumulator, this[index])\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\r\n */\r\npublic inline fun <S, T : S> Array<out T>.reduceRight(operation: (T, acc: S) -> S): S {\r\n    var index = lastIndex\r\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator: S = get(index--)\r\n    while (index >= 0) {\r\n        accumulator = operation(get(index--), accumulator)\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\r\n */\r\npublic inline fun ByteArray.reduceRight(operation: (Byte, acc: Byte) -> Byte): Byte {\r\n    var index = lastIndex\r\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator = get(index--)\r\n    while (index >= 0) {\r\n        accumulator = operation(get(index--), accumulator)\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\r\n */\r\npublic inline fun ShortArray.reduceRight(operation: (Short, acc: Short) -> Short): Short {\r\n    var index = lastIndex\r\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator = get(index--)\r\n    while (index >= 0) {\r\n        accumulator = operation(get(index--), accumulator)\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\r\n */\r\npublic inline fun IntArray.reduceRight(operation: (Int, acc: Int) -> Int): Int {\r\n    var index = lastIndex\r\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator = get(index--)\r\n    while (index >= 0) {\r\n        accumulator = operation(get(index--), accumulator)\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\r\n */\r\npublic inline fun LongArray.reduceRight(operation: (Long, acc: Long) -> Long): Long {\r\n    var index = lastIndex\r\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator = get(index--)\r\n    while (index >= 0) {\r\n        accumulator = operation(get(index--), accumulator)\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\r\n */\r\npublic inline fun FloatArray.reduceRight(operation: (Float, acc: Float) -> Float): Float {\r\n    var index = lastIndex\r\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator = get(index--)\r\n    while (index >= 0) {\r\n        accumulator = operation(get(index--), accumulator)\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\r\n */\r\npublic inline fun DoubleArray.reduceRight(operation: (Double, acc: Double) -> Double): Double {\r\n    var index = lastIndex\r\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator = get(index--)\r\n    while (index >= 0) {\r\n        accumulator = operation(get(index--), accumulator)\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\r\n */\r\npublic inline fun BooleanArray.reduceRight(operation: (Boolean, acc: Boolean) -> Boolean): Boolean {\r\n    var index = lastIndex\r\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator = get(index--)\r\n    while (index >= 0) {\r\n        accumulator = operation(get(index--), accumulator)\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\r\n */\r\npublic inline fun CharArray.reduceRight(operation: (Char, acc: Char) -> Char): Char {\r\n    var index = lastIndex\r\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator = get(index--)\r\n    while (index >= 0) {\r\n        accumulator = operation(get(index--), accumulator)\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with last element and applying [operation] from right to left\r\n * to each element with its index in the original array and current accumulator value.\r\n * @param [operation] function that takes the index of an element, the element itself\r\n * and current accumulator value, and calculates the next accumulator value.\r\n */\r\npublic inline fun <S, T : S> Array<out T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\r\n    var index = lastIndex\r\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator: S = get(index--)\r\n    while (index >= 0) {\r\n        accumulator = operation(index, get(index), accumulator)\r\n        --index\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with last element and applying [operation] from right to left\r\n * to each element with its index in the original array and current accumulator value.\r\n * @param [operation] function that takes the index of an element, the element itself\r\n * and current accumulator value, and calculates the next accumulator value.\r\n */\r\npublic inline fun ByteArray.reduceRightIndexed(operation: (index: Int, Byte, acc: Byte) -> Byte): Byte {\r\n    var index = lastIndex\r\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator = get(index--)\r\n    while (index >= 0) {\r\n        accumulator = operation(index, get(index), accumulator)\r\n        --index\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with last element and applying [operation] from right to left\r\n * to each element with its index in the original array and current accumulator value.\r\n * @param [operation] function that takes the index of an element, the element itself\r\n * and current accumulator value, and calculates the next accumulator value.\r\n */\r\npublic inline fun ShortArray.reduceRightIndexed(operation: (index: Int, Short, acc: Short) -> Short): Short {\r\n    var index = lastIndex\r\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator = get(index--)\r\n    while (index >= 0) {\r\n        accumulator = operation(index, get(index), accumulator)\r\n        --index\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with last element and applying [operation] from right to left\r\n * to each element with its index in the original array and current accumulator value.\r\n * @param [operation] function that takes the index of an element, the element itself\r\n * and current accumulator value, and calculates the next accumulator value.\r\n */\r\npublic inline fun IntArray.reduceRightIndexed(operation: (index: Int, Int, acc: Int) -> Int): Int {\r\n    var index = lastIndex\r\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator = get(index--)\r\n    while (index >= 0) {\r\n        accumulator = operation(index, get(index), accumulator)\r\n        --index\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with last element and applying [operation] from right to left\r\n * to each element with its index in the original array and current accumulator value.\r\n * @param [operation] function that takes the index of an element, the element itself\r\n * and current accumulator value, and calculates the next accumulator value.\r\n */\r\npublic inline fun LongArray.reduceRightIndexed(operation: (index: Int, Long, acc: Long) -> Long): Long {\r\n    var index = lastIndex\r\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator = get(index--)\r\n    while (index >= 0) {\r\n        accumulator = operation(index, get(index), accumulator)\r\n        --index\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with last element and applying [operation] from right to left\r\n * to each element with its index in the original array and current accumulator value.\r\n * @param [operation] function that takes the index of an element, the element itself\r\n * and current accumulator value, and calculates the next accumulator value.\r\n */\r\npublic inline fun FloatArray.reduceRightIndexed(operation: (index: Int, Float, acc: Float) -> Float): Float {\r\n    var index = lastIndex\r\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator = get(index--)\r\n    while (index >= 0) {\r\n        accumulator = operation(index, get(index), accumulator)\r\n        --index\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with last element and applying [operation] from right to left\r\n * to each element with its index in the original array and current accumulator value.\r\n * @param [operation] function that takes the index of an element, the element itself\r\n * and current accumulator value, and calculates the next accumulator value.\r\n */\r\npublic inline fun DoubleArray.reduceRightIndexed(operation: (index: Int, Double, acc: Double) -> Double): Double {\r\n    var index = lastIndex\r\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator = get(index--)\r\n    while (index >= 0) {\r\n        accumulator = operation(index, get(index), accumulator)\r\n        --index\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with last element and applying [operation] from right to left\r\n * to each element with its index in the original array and current accumulator value.\r\n * @param [operation] function that takes the index of an element, the element itself\r\n * and current accumulator value, and calculates the next accumulator value.\r\n */\r\npublic inline fun BooleanArray.reduceRightIndexed(operation: (index: Int, Boolean, acc: Boolean) -> Boolean): Boolean {\r\n    var index = lastIndex\r\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator = get(index--)\r\n    while (index >= 0) {\r\n        accumulator = operation(index, get(index), accumulator)\r\n        --index\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Accumulates value starting with last element and applying [operation] from right to left\r\n * to each element with its index in the original array and current accumulator value.\r\n * @param [operation] function that takes the index of an element, the element itself\r\n * and current accumulator value, and calculates the next accumulator value.\r\n */\r\npublic inline fun CharArray.reduceRightIndexed(operation: (index: Int, Char, acc: Char) -> Char): Char {\r\n    var index = lastIndex\r\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\r\n    var accumulator = get(index--)\r\n    while (index >= 0) {\r\n        accumulator = operation(index, get(index), accumulator)\r\n        --index\r\n    }\r\n    return accumulator\r\n}\r\n\r\n/**\r\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\r\n */\r\npublic inline fun <T> Array<out T>.sumBy(selector: (T) -> Int): Int {\r\n    var sum: Int = 0\r\n    for (element in this) {\r\n        sum += selector(element)\r\n    }\r\n    return sum\r\n}\r\n\r\n/**\r\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\r\n */\r\npublic inline fun ByteArray.sumBy(selector: (Byte) -> Int): Int {\r\n    var sum: Int = 0\r\n    for (element in this) {\r\n        sum += selector(element)\r\n    }\r\n    return sum\r\n}\r\n\r\n/**\r\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\r\n */\r\npublic inline fun ShortArray.sumBy(selector: (Short) -> Int): Int {\r\n    var sum: Int = 0\r\n    for (element in this) {\r\n        sum += selector(element)\r\n    }\r\n    return sum\r\n}\r\n\r\n/**\r\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\r\n */\r\npublic inline fun IntArray.sumBy(selector: (Int) -> Int): Int {\r\n    var sum: Int = 0\r\n    for (element in this) {\r\n        sum += selector(element)\r\n    }\r\n    return sum\r\n}\r\n\r\n/**\r\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\r\n */\r\npublic inline fun LongArray.sumBy(selector: (Long) -> Int): Int {\r\n    var sum: Int = 0\r\n    for (element in this) {\r\n        sum += selector(element)\r\n    }\r\n    return sum\r\n}\r\n\r\n/**\r\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\r\n */\r\npublic inline fun FloatArray.sumBy(selector: (Float) -> Int): Int {\r\n    var sum: Int = 0\r\n    for (element in this) {\r\n        sum += selector(element)\r\n    }\r\n    return sum\r\n}\r\n\r\n/**\r\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\r\n */\r\npublic inline fun DoubleArray.sumBy(selector: (Double) -> Int): Int {\r\n    var sum: Int = 0\r\n    for (element in this) {\r\n        sum += selector(element)\r\n    }\r\n    return sum\r\n}\r\n\r\n/**\r\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\r\n */\r\npublic inline fun BooleanArray.sumBy(selector: (Boolean) -> Int): Int {\r\n    var sum: Int = 0\r\n    for (element in this) {\r\n        sum += selector(element)\r\n    }\r\n    return sum\r\n}\r\n\r\n/**\r\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\r\n */\r\npublic inline fun CharArray.sumBy(selector: (Char) -> Int): Int {\r\n    var sum: Int = 0\r\n    for (element in this) {\r\n        sum += selector(element)\r\n    }\r\n    return sum\r\n}\r\n\r\n/**\r\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\r\n */\r\npublic inline fun <T> Array<out T>.sumByDouble(selector: (T) -> Double): Double {\r\n    var sum: Double = 0.0\r\n    for (element in this) {\r\n        sum += selector(element)\r\n    }\r\n    return sum\r\n}\r\n\r\n/**\r\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\r\n */\r\npublic inline fun ByteArray.sumByDouble(selector: (Byte) -> Double): Double {\r\n    var sum: Double = 0.0\r\n    for (element in this) {\r\n        sum += selector(element)\r\n    }\r\n    return sum\r\n}\r\n\r\n/**\r\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\r\n */\r\npublic inline fun ShortArray.sumByDouble(selector: (Short) -> Double): Double {\r\n    var sum: Double = 0.0\r\n    for (element in this) {\r\n        sum += selector(element)\r\n    }\r\n    return sum\r\n}\r\n\r\n/**\r\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\r\n */\r\npublic inline fun IntArray.sumByDouble(selector: (Int) -> Double): Double {\r\n    var sum: Double = 0.0\r\n    for (element in this) {\r\n        sum += selector(element)\r\n    }\r\n    return sum\r\n}\r\n\r\n/**\r\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\r\n */\r\npublic inline fun LongArray.sumByDouble(selector: (Long) -> Double): Double {\r\n    var sum: Double = 0.0\r\n    for (element in this) {\r\n        sum += selector(element)\r\n    }\r\n    return sum\r\n}\r\n\r\n/**\r\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\r\n */\r\npublic inline fun FloatArray.sumByDouble(selector: (Float) -> Double): Double {\r\n    var sum: Double = 0.0\r\n    for (element in this) {\r\n        sum += selector(element)\r\n    }\r\n    return sum\r\n}\r\n\r\n/**\r\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\r\n */\r\npublic inline fun DoubleArray.sumByDouble(selector: (Double) -> Double): Double {\r\n    var sum: Double = 0.0\r\n    for (element in this) {\r\n        sum += selector(element)\r\n    }\r\n    return sum\r\n}\r\n\r\n/**\r\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\r\n */\r\npublic inline fun BooleanArray.sumByDouble(selector: (Boolean) -> Double): Double {\r\n    var sum: Double = 0.0\r\n    for (element in this) {\r\n        sum += selector(element)\r\n    }\r\n    return sum\r\n}\r\n\r\n/**\r\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\r\n */\r\npublic inline fun CharArray.sumByDouble(selector: (Char) -> Double): Double {\r\n    var sum: Double = 0.0\r\n    for (element in this) {\r\n        sum += selector(element)\r\n    }\r\n    return sum\r\n}\r\n\r\n/**\r\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\r\n */\r\npublic fun <T : Any> Array<T?>.requireNoNulls(): Array<T> {\r\n    for (element in this) {\r\n        if (element == null) {\r\n            throw IllegalArgumentException(\"null element found in $this.\")\r\n        }\r\n    }\r\n    @Suppress(\"UNCHECKED_CAST\")\r\n    return this as Array<T>\r\n}\r\n\r\n/**\r\n * Splits the original array into pair of lists,\r\n * where *first* list contains elements for which [predicate] yielded `true`,\r\n * while *second* list contains elements for which [predicate] yielded `false`.\r\n */\r\npublic inline fun <T> Array<out T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\r\n    val first = ArrayList<T>()\r\n    val second = ArrayList<T>()\r\n    for (element in this) {\r\n        if (predicate(element)) {\r\n            first.add(element)\r\n        } else {\r\n            second.add(element)\r\n        }\r\n    }\r\n    return Pair(first, second)\r\n}\r\n\r\n/**\r\n * Splits the original array into pair of lists,\r\n * where *first* list contains elements for which [predicate] yielded `true`,\r\n * while *second* list contains elements for which [predicate] yielded `false`.\r\n */\r\npublic inline fun ByteArray.partition(predicate: (Byte) -> Boolean): Pair<List<Byte>, List<Byte>> {\r\n    val first = ArrayList<Byte>()\r\n    val second = ArrayList<Byte>()\r\n    for (element in this) {\r\n        if (predicate(element)) {\r\n            first.add(element)\r\n        } else {\r\n            second.add(element)\r\n        }\r\n    }\r\n    return Pair(first, second)\r\n}\r\n\r\n/**\r\n * Splits the original array into pair of lists,\r\n * where *first* list contains elements for which [predicate] yielded `true`,\r\n * while *second* list contains elements for which [predicate] yielded `false`.\r\n */\r\npublic inline fun ShortArray.partition(predicate: (Short) -> Boolean): Pair<List<Short>, List<Short>> {\r\n    val first = ArrayList<Short>()\r\n    val second = ArrayList<Short>()\r\n    for (element in this) {\r\n        if (predicate(element)) {\r\n            first.add(element)\r\n        } else {\r\n            second.add(element)\r\n        }\r\n    }\r\n    return Pair(first, second)\r\n}\r\n\r\n/**\r\n * Splits the original array into pair of lists,\r\n * where *first* list contains elements for which [predicate] yielded `true`,\r\n * while *second* list contains elements for which [predicate] yielded `false`.\r\n */\r\npublic inline fun IntArray.partition(predicate: (Int) -> Boolean): Pair<List<Int>, List<Int>> {\r\n    val first = ArrayList<Int>()\r\n    val second = ArrayList<Int>()\r\n    for (element in this) {\r\n        if (predicate(element)) {\r\n            first.add(element)\r\n        } else {\r\n            second.add(element)\r\n        }\r\n    }\r\n    return Pair(first, second)\r\n}\r\n\r\n/**\r\n * Splits the original array into pair of lists,\r\n * where *first* list contains elements for which [predicate] yielded `true`,\r\n * while *second* list contains elements for which [predicate] yielded `false`.\r\n */\r\npublic inline fun LongArray.partition(predicate: (Long) -> Boolean): Pair<List<Long>, List<Long>> {\r\n    val first = ArrayList<Long>()\r\n    val second = ArrayList<Long>()\r\n    for (element in this) {\r\n        if (predicate(element)) {\r\n            first.add(element)\r\n        } else {\r\n            second.add(element)\r\n        }\r\n    }\r\n    return Pair(first, second)\r\n}\r\n\r\n/**\r\n * Splits the original array into pair of lists,\r\n * where *first* list contains elements for which [predicate] yielded `true`,\r\n * while *second* list contains elements for which [predicate] yielded `false`.\r\n */\r\npublic inline fun FloatArray.partition(predicate: (Float) -> Boolean): Pair<List<Float>, List<Float>> {\r\n    val first = ArrayList<Float>()\r\n    val second = ArrayList<Float>()\r\n    for (element in this) {\r\n        if (predicate(element)) {\r\n            first.add(element)\r\n        } else {\r\n            second.add(element)\r\n        }\r\n    }\r\n    return Pair(first, second)\r\n}\r\n\r\n/**\r\n * Splits the original array into pair of lists,\r\n * where *first* list contains elements for which [predicate] yielded `true`,\r\n * while *second* list contains elements for which [predicate] yielded `false`.\r\n */\r\npublic inline fun DoubleArray.partition(predicate: (Double) -> Boolean): Pair<List<Double>, List<Double>> {\r\n    val first = ArrayList<Double>()\r\n    val second = ArrayList<Double>()\r\n    for (element in this) {\r\n        if (predicate(element)) {\r\n            first.add(element)\r\n        } else {\r\n            second.add(element)\r\n        }\r\n    }\r\n    return Pair(first, second)\r\n}\r\n\r\n/**\r\n * Splits the original array into pair of lists,\r\n * where *first* list contains elements for which [predicate] yielded `true`,\r\n * while *second* list contains elements for which [predicate] yielded `false`.\r\n */\r\npublic inline fun BooleanArray.partition(predicate: (Boolean) -> Boolean): Pair<List<Boolean>, List<Boolean>> {\r\n    val first = ArrayList<Boolean>()\r\n    val second = ArrayList<Boolean>()\r\n    for (element in this) {\r\n        if (predicate(element)) {\r\n            first.add(element)\r\n        } else {\r\n            second.add(element)\r\n        }\r\n    }\r\n    return Pair(first, second)\r\n}\r\n\r\n/**\r\n * Splits the original array into pair of lists,\r\n * where *first* list contains elements for which [predicate] yielded `true`,\r\n * while *second* list contains elements for which [predicate] yielded `false`.\r\n */\r\npublic inline fun CharArray.partition(predicate: (Char) -> Boolean): Pair<List<Char>, List<Char>> {\r\n    val first = ArrayList<Char>()\r\n    val second = ArrayList<Char>()\r\n    for (element in this) {\r\n        if (predicate(element)) {\r\n            first.add(element)\r\n        } else {\r\n            second.add(element)\r\n        }\r\n    }\r\n    return Pair(first, second)\r\n}\r\n\r\n/**\r\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterable\r\n */\r\npublic infix fun <T, R> Array<out T>.zip(other: Array<out R>): List<Pair<T, R>> {\r\n    return zip(other) { t1, t2 -> t1 to t2 }\r\n}\r\n\r\n/**\r\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterable\r\n */\r\npublic infix fun <R> ByteArray.zip(other: Array<out R>): List<Pair<Byte, R>> {\r\n    return zip(other) { t1, t2 -> t1 to t2 }\r\n}\r\n\r\n/**\r\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterable\r\n */\r\npublic infix fun <R> ShortArray.zip(other: Array<out R>): List<Pair<Short, R>> {\r\n    return zip(other) { t1, t2 -> t1 to t2 }\r\n}\r\n\r\n/**\r\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterable\r\n */\r\npublic infix fun <R> IntArray.zip(other: Array<out R>): List<Pair<Int, R>> {\r\n    return zip(other) { t1, t2 -> t1 to t2 }\r\n}\r\n\r\n/**\r\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterable\r\n */\r\npublic infix fun <R> LongArray.zip(other: Array<out R>): List<Pair<Long, R>> {\r\n    return zip(other) { t1, t2 -> t1 to t2 }\r\n}\r\n\r\n/**\r\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterable\r\n */\r\npublic infix fun <R> FloatArray.zip(other: Array<out R>): List<Pair<Float, R>> {\r\n    return zip(other) { t1, t2 -> t1 to t2 }\r\n}\r\n\r\n/**\r\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterable\r\n */\r\npublic infix fun <R> DoubleArray.zip(other: Array<out R>): List<Pair<Double, R>> {\r\n    return zip(other) { t1, t2 -> t1 to t2 }\r\n}\r\n\r\n/**\r\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterable\r\n */\r\npublic infix fun <R> BooleanArray.zip(other: Array<out R>): List<Pair<Boolean, R>> {\r\n    return zip(other) { t1, t2 -> t1 to t2 }\r\n}\r\n\r\n/**\r\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterable\r\n */\r\npublic infix fun <R> CharArray.zip(other: Array<out R>): List<Pair<Char, R>> {\r\n    return zip(other) { t1, t2 -> t1 to t2 }\r\n}\r\n\r\n/**\r\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\r\n * using the provided [transform] function applied to each pair of elements.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\r\n */\r\npublic inline fun <T, R, V> Array<out T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\r\n    val size = minOf(size, other.size)\r\n    val list = ArrayList<V>(size)\r\n    for (i in 0 until size) {\r\n        list.add(transform(this[i], other[i]))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\r\n * using the provided [transform] function applied to each pair of elements.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\r\n */\r\npublic inline fun <R, V> ByteArray.zip(other: Array<out R>, transform: (a: Byte, b: R) -> V): List<V> {\r\n    val size = minOf(size, other.size)\r\n    val list = ArrayList<V>(size)\r\n    for (i in 0 until size) {\r\n        list.add(transform(this[i], other[i]))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\r\n * using the provided [transform] function applied to each pair of elements.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\r\n */\r\npublic inline fun <R, V> ShortArray.zip(other: Array<out R>, transform: (a: Short, b: R) -> V): List<V> {\r\n    val size = minOf(size, other.size)\r\n    val list = ArrayList<V>(size)\r\n    for (i in 0 until size) {\r\n        list.add(transform(this[i], other[i]))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\r\n * using the provided [transform] function applied to each pair of elements.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\r\n */\r\npublic inline fun <R, V> IntArray.zip(other: Array<out R>, transform: (a: Int, b: R) -> V): List<V> {\r\n    val size = minOf(size, other.size)\r\n    val list = ArrayList<V>(size)\r\n    for (i in 0 until size) {\r\n        list.add(transform(this[i], other[i]))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\r\n * using the provided [transform] function applied to each pair of elements.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\r\n */\r\npublic inline fun <R, V> LongArray.zip(other: Array<out R>, transform: (a: Long, b: R) -> V): List<V> {\r\n    val size = minOf(size, other.size)\r\n    val list = ArrayList<V>(size)\r\n    for (i in 0 until size) {\r\n        list.add(transform(this[i], other[i]))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\r\n * using the provided [transform] function applied to each pair of elements.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\r\n */\r\npublic inline fun <R, V> FloatArray.zip(other: Array<out R>, transform: (a: Float, b: R) -> V): List<V> {\r\n    val size = minOf(size, other.size)\r\n    val list = ArrayList<V>(size)\r\n    for (i in 0 until size) {\r\n        list.add(transform(this[i], other[i]))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\r\n * using the provided [transform] function applied to each pair of elements.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\r\n */\r\npublic inline fun <R, V> DoubleArray.zip(other: Array<out R>, transform: (a: Double, b: R) -> V): List<V> {\r\n    val size = minOf(size, other.size)\r\n    val list = ArrayList<V>(size)\r\n    for (i in 0 until size) {\r\n        list.add(transform(this[i], other[i]))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\r\n * using the provided [transform] function applied to each pair of elements.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\r\n */\r\npublic inline fun <R, V> BooleanArray.zip(other: Array<out R>, transform: (a: Boolean, b: R) -> V): List<V> {\r\n    val size = minOf(size, other.size)\r\n    val list = ArrayList<V>(size)\r\n    for (i in 0 until size) {\r\n        list.add(transform(this[i], other[i]))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\r\n * using the provided [transform] function applied to each pair of elements.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\r\n */\r\npublic inline fun <R, V> CharArray.zip(other: Array<out R>, transform: (a: Char, b: R) -> V): List<V> {\r\n    val size = minOf(size, other.size)\r\n    val list = ArrayList<V>(size)\r\n    for (i in 0 until size) {\r\n        list.add(transform(this[i], other[i]))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterable\r\n */\r\npublic infix fun <T, R> Array<out T>.zip(other: Iterable<R>): List<Pair<T, R>> {\r\n    return zip(other) { t1, t2 -> t1 to t2 }\r\n}\r\n\r\n/**\r\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterable\r\n */\r\npublic infix fun <R> ByteArray.zip(other: Iterable<R>): List<Pair<Byte, R>> {\r\n    return zip(other) { t1, t2 -> t1 to t2 }\r\n}\r\n\r\n/**\r\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterable\r\n */\r\npublic infix fun <R> ShortArray.zip(other: Iterable<R>): List<Pair<Short, R>> {\r\n    return zip(other) { t1, t2 -> t1 to t2 }\r\n}\r\n\r\n/**\r\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterable\r\n */\r\npublic infix fun <R> IntArray.zip(other: Iterable<R>): List<Pair<Int, R>> {\r\n    return zip(other) { t1, t2 -> t1 to t2 }\r\n}\r\n\r\n/**\r\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterable\r\n */\r\npublic infix fun <R> LongArray.zip(other: Iterable<R>): List<Pair<Long, R>> {\r\n    return zip(other) { t1, t2 -> t1 to t2 }\r\n}\r\n\r\n/**\r\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterable\r\n */\r\npublic infix fun <R> FloatArray.zip(other: Iterable<R>): List<Pair<Float, R>> {\r\n    return zip(other) { t1, t2 -> t1 to t2 }\r\n}\r\n\r\n/**\r\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterable\r\n */\r\npublic infix fun <R> DoubleArray.zip(other: Iterable<R>): List<Pair<Double, R>> {\r\n    return zip(other) { t1, t2 -> t1 to t2 }\r\n}\r\n\r\n/**\r\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterable\r\n */\r\npublic infix fun <R> BooleanArray.zip(other: Iterable<R>): List<Pair<Boolean, R>> {\r\n    return zip(other) { t1, t2 -> t1 to t2 }\r\n}\r\n\r\n/**\r\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterable\r\n */\r\npublic infix fun <R> CharArray.zip(other: Iterable<R>): List<Pair<Char, R>> {\r\n    return zip(other) { t1, t2 -> t1 to t2 }\r\n}\r\n\r\n/**\r\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\r\n * using the provided [transform] function applied to each pair of elements.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\r\n */\r\npublic inline fun <T, R, V> Array<out T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\r\n    val arraySize = size\r\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\r\n    var i = 0\r\n    for (element in other) {\r\n        if (i >= arraySize) break\r\n        list.add(transform(this[i++], element))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\r\n * using the provided [transform] function applied to each pair of elements.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\r\n */\r\npublic inline fun <R, V> ByteArray.zip(other: Iterable<R>, transform: (a: Byte, b: R) -> V): List<V> {\r\n    val arraySize = size\r\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\r\n    var i = 0\r\n    for (element in other) {\r\n        if (i >= arraySize) break\r\n        list.add(transform(this[i++], element))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\r\n * using the provided [transform] function applied to each pair of elements.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\r\n */\r\npublic inline fun <R, V> ShortArray.zip(other: Iterable<R>, transform: (a: Short, b: R) -> V): List<V> {\r\n    val arraySize = size\r\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\r\n    var i = 0\r\n    for (element in other) {\r\n        if (i >= arraySize) break\r\n        list.add(transform(this[i++], element))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\r\n * using the provided [transform] function applied to each pair of elements.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\r\n */\r\npublic inline fun <R, V> IntArray.zip(other: Iterable<R>, transform: (a: Int, b: R) -> V): List<V> {\r\n    val arraySize = size\r\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\r\n    var i = 0\r\n    for (element in other) {\r\n        if (i >= arraySize) break\r\n        list.add(transform(this[i++], element))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\r\n * using the provided [transform] function applied to each pair of elements.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\r\n */\r\npublic inline fun <R, V> LongArray.zip(other: Iterable<R>, transform: (a: Long, b: R) -> V): List<V> {\r\n    val arraySize = size\r\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\r\n    var i = 0\r\n    for (element in other) {\r\n        if (i >= arraySize) break\r\n        list.add(transform(this[i++], element))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\r\n * using the provided [transform] function applied to each pair of elements.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\r\n */\r\npublic inline fun <R, V> FloatArray.zip(other: Iterable<R>, transform: (a: Float, b: R) -> V): List<V> {\r\n    val arraySize = size\r\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\r\n    var i = 0\r\n    for (element in other) {\r\n        if (i >= arraySize) break\r\n        list.add(transform(this[i++], element))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\r\n * using the provided [transform] function applied to each pair of elements.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\r\n */\r\npublic inline fun <R, V> DoubleArray.zip(other: Iterable<R>, transform: (a: Double, b: R) -> V): List<V> {\r\n    val arraySize = size\r\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\r\n    var i = 0\r\n    for (element in other) {\r\n        if (i >= arraySize) break\r\n        list.add(transform(this[i++], element))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\r\n * using the provided [transform] function applied to each pair of elements.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\r\n */\r\npublic inline fun <R, V> BooleanArray.zip(other: Iterable<R>, transform: (a: Boolean, b: R) -> V): List<V> {\r\n    val arraySize = size\r\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\r\n    var i = 0\r\n    for (element in other) {\r\n        if (i >= arraySize) break\r\n        list.add(transform(this[i++], element))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\r\n * using the provided [transform] function applied to each pair of elements.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\r\n */\r\npublic inline fun <R, V> CharArray.zip(other: Iterable<R>, transform: (a: Char, b: R) -> V): List<V> {\r\n    val arraySize = size\r\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\r\n    var i = 0\r\n    for (element in other) {\r\n        if (i >= arraySize) break\r\n        list.add(transform(this[i++], element))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterable\r\n */\r\npublic infix fun ByteArray.zip(other: ByteArray): List<Pair<Byte, Byte>> {\r\n    return zip(other) { t1, t2 -> t1 to t2 }\r\n}\r\n\r\n/**\r\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterable\r\n */\r\npublic infix fun ShortArray.zip(other: ShortArray): List<Pair<Short, Short>> {\r\n    return zip(other) { t1, t2 -> t1 to t2 }\r\n}\r\n\r\n/**\r\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterable\r\n */\r\npublic infix fun IntArray.zip(other: IntArray): List<Pair<Int, Int>> {\r\n    return zip(other) { t1, t2 -> t1 to t2 }\r\n}\r\n\r\n/**\r\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterable\r\n */\r\npublic infix fun LongArray.zip(other: LongArray): List<Pair<Long, Long>> {\r\n    return zip(other) { t1, t2 -> t1 to t2 }\r\n}\r\n\r\n/**\r\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterable\r\n */\r\npublic infix fun FloatArray.zip(other: FloatArray): List<Pair<Float, Float>> {\r\n    return zip(other) { t1, t2 -> t1 to t2 }\r\n}\r\n\r\n/**\r\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterable\r\n */\r\npublic infix fun DoubleArray.zip(other: DoubleArray): List<Pair<Double, Double>> {\r\n    return zip(other) { t1, t2 -> t1 to t2 }\r\n}\r\n\r\n/**\r\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterable\r\n */\r\npublic infix fun BooleanArray.zip(other: BooleanArray): List<Pair<Boolean, Boolean>> {\r\n    return zip(other) { t1, t2 -> t1 to t2 }\r\n}\r\n\r\n/**\r\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\r\n * The returned list has length of the shortest collection.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterable\r\n */\r\npublic infix fun CharArray.zip(other: CharArray): List<Pair<Char, Char>> {\r\n    return zip(other) { t1, t2 -> t1 to t2 }\r\n}\r\n\r\n/**\r\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\r\n * using the provided [transform] function applied to each pair of elements.\r\n * The returned list has length of the shortest array.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\r\n */\r\npublic inline fun <V> ByteArray.zip(other: ByteArray, transform: (a: Byte, b: Byte) -> V): List<V> {\r\n    val size = minOf(size, other.size)\r\n    val list = ArrayList<V>(size)\r\n    for (i in 0 until size) {\r\n        list.add(transform(this[i], other[i]))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\r\n * using the provided [transform] function applied to each pair of elements.\r\n * The returned list has length of the shortest array.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\r\n */\r\npublic inline fun <V> ShortArray.zip(other: ShortArray, transform: (a: Short, b: Short) -> V): List<V> {\r\n    val size = minOf(size, other.size)\r\n    val list = ArrayList<V>(size)\r\n    for (i in 0 until size) {\r\n        list.add(transform(this[i], other[i]))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\r\n * using the provided [transform] function applied to each pair of elements.\r\n * The returned list has length of the shortest array.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\r\n */\r\npublic inline fun <V> IntArray.zip(other: IntArray, transform: (a: Int, b: Int) -> V): List<V> {\r\n    val size = minOf(size, other.size)\r\n    val list = ArrayList<V>(size)\r\n    for (i in 0 until size) {\r\n        list.add(transform(this[i], other[i]))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\r\n * using the provided [transform] function applied to each pair of elements.\r\n * The returned list has length of the shortest array.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\r\n */\r\npublic inline fun <V> LongArray.zip(other: LongArray, transform: (a: Long, b: Long) -> V): List<V> {\r\n    val size = minOf(size, other.size)\r\n    val list = ArrayList<V>(size)\r\n    for (i in 0 until size) {\r\n        list.add(transform(this[i], other[i]))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\r\n * using the provided [transform] function applied to each pair of elements.\r\n * The returned list has length of the shortest array.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\r\n */\r\npublic inline fun <V> FloatArray.zip(other: FloatArray, transform: (a: Float, b: Float) -> V): List<V> {\r\n    val size = minOf(size, other.size)\r\n    val list = ArrayList<V>(size)\r\n    for (i in 0 until size) {\r\n        list.add(transform(this[i], other[i]))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\r\n * using the provided [transform] function applied to each pair of elements.\r\n * The returned list has length of the shortest array.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\r\n */\r\npublic inline fun <V> DoubleArray.zip(other: DoubleArray, transform: (a: Double, b: Double) -> V): List<V> {\r\n    val size = minOf(size, other.size)\r\n    val list = ArrayList<V>(size)\r\n    for (i in 0 until size) {\r\n        list.add(transform(this[i], other[i]))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\r\n * using the provided [transform] function applied to each pair of elements.\r\n * The returned list has length of the shortest array.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\r\n */\r\npublic inline fun <V> BooleanArray.zip(other: BooleanArray, transform: (a: Boolean, b: Boolean) -> V): List<V> {\r\n    val size = minOf(size, other.size)\r\n    val list = ArrayList<V>(size)\r\n    for (i in 0 until size) {\r\n        list.add(transform(this[i], other[i]))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\r\n * using the provided [transform] function applied to each pair of elements.\r\n * The returned list has length of the shortest array.\r\n * \r\n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\r\n */\r\npublic inline fun <V> CharArray.zip(other: CharArray, transform: (a: Char, b: Char) -> V): List<V> {\r\n    val size = minOf(size, other.size)\r\n    val list = ArrayList<V>(size)\r\n    for (i in 0 until size) {\r\n        list.add(transform(this[i], other[i]))\r\n    }\r\n    return list\r\n}\r\n\r\n/**\r\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\r\n * \r\n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\r\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\r\n * \r\n * @sample samples.collections.Collections.Transformations.joinTo\r\n */\r\npublic fun <T, A : Appendable> Array<out T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\r\n    buffer.append(prefix)\r\n    var count = 0\r\n    for (element in this) {\r\n        if (++count > 1) buffer.append(separator)\r\n        if (limit < 0 || count <= limit) {\r\n            buffer.appendElement(element, transform)\r\n        } else break\r\n    }\r\n    if (limit >= 0 && count > limit) buffer.append(truncated)\r\n    buffer.append(postfix)\r\n    return buffer\r\n}\r\n\r\n/**\r\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\r\n * \r\n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\r\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\r\n * \r\n * @sample samples.collections.Collections.Transformations.joinTo\r\n */\r\npublic fun <A : Appendable> ByteArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Byte) -> CharSequence)? = null): A {\r\n    buffer.append(prefix)\r\n    var count = 0\r\n    for (element in this) {\r\n        if (++count > 1) buffer.append(separator)\r\n        if (limit < 0 || count <= limit) {\r\n            if (transform != null)\r\n                buffer.append(transform(element))\r\n            else\r\n                buffer.append(element.toString())\r\n        } else break\r\n    }\r\n    if (limit >= 0 && count > limit) buffer.append(truncated)\r\n    buffer.append(postfix)\r\n    return buffer\r\n}\r\n\r\n/**\r\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\r\n * \r\n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\r\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\r\n * \r\n * @sample samples.collections.Collections.Transformations.joinTo\r\n */\r\npublic fun <A : Appendable> ShortArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Short) -> CharSequence)? = null): A {\r\n    buffer.append(prefix)\r\n    var count = 0\r\n    for (element in this) {\r\n        if (++count > 1) buffer.append(separator)\r\n        if (limit < 0 || count <= limit) {\r\n            if (transform != null)\r\n                buffer.append(transform(element))\r\n            else\r\n                buffer.append(element.toString())\r\n        } else break\r\n    }\r\n    if (limit >= 0 && count > limit) buffer.append(truncated)\r\n    buffer.append(postfix)\r\n    return buffer\r\n}\r\n\r\n/**\r\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\r\n * \r\n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\r\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\r\n * \r\n * @sample samples.collections.Collections.Transformations.joinTo\r\n */\r\npublic fun <A : Appendable> IntArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Int) -> CharSequence)? = null): A {\r\n    buffer.append(prefix)\r\n    var count = 0\r\n    for (element in this) {\r\n        if (++count > 1) buffer.append(separator)\r\n        if (limit < 0 || count <= limit) {\r\n            if (transform != null)\r\n                buffer.append(transform(element))\r\n            else\r\n                buffer.append(element.toString())\r\n        } else break\r\n    }\r\n    if (limit >= 0 && count > limit) buffer.append(truncated)\r\n    buffer.append(postfix)\r\n    return buffer\r\n}\r\n\r\n/**\r\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\r\n * \r\n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\r\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\r\n * \r\n * @sample samples.collections.Collections.Transformations.joinTo\r\n */\r\npublic fun <A : Appendable> LongArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Long) -> CharSequence)? = null): A {\r\n    buffer.append(prefix)\r\n    var count = 0\r\n    for (element in this) {\r\n        if (++count > 1) buffer.append(separator)\r\n        if (limit < 0 || count <= limit) {\r\n            if (transform != null)\r\n                buffer.append(transform(element))\r\n            else\r\n                buffer.append(element.toString())\r\n        } else break\r\n    }\r\n    if (limit >= 0 && count > limit) buffer.append(truncated)\r\n    buffer.append(postfix)\r\n    return buffer\r\n}\r\n\r\n/**\r\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\r\n * \r\n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\r\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\r\n * \r\n * @sample samples.collections.Collections.Transformations.joinTo\r\n */\r\npublic fun <A : Appendable> FloatArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Float) -> CharSequence)? = null): A {\r\n    buffer.append(prefix)\r\n    var count = 0\r\n    for (element in this) {\r\n        if (++count > 1) buffer.append(separator)\r\n        if (limit < 0 || count <= limit) {\r\n            if (transform != null)\r\n                buffer.append(transform(element))\r\n            else\r\n                buffer.append(element.toString())\r\n        } else break\r\n    }\r\n    if (limit >= 0 && count > limit) buffer.append(truncated)\r\n    buffer.append(postfix)\r\n    return buffer\r\n}\r\n\r\n/**\r\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\r\n * \r\n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\r\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\r\n * \r\n * @sample samples.collections.Collections.Transformations.joinTo\r\n */\r\npublic fun <A : Appendable> DoubleArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Double) -> CharSequence)? = null): A {\r\n    buffer.append(prefix)\r\n    var count = 0\r\n    for (element in this) {\r\n        if (++count > 1) buffer.append(separator)\r\n        if (limit < 0 || count <= limit) {\r\n            if (transform != null)\r\n                buffer.append(transform(element))\r\n            else\r\n                buffer.append(element.toString())\r\n        } else break\r\n    }\r\n    if (limit >= 0 && count > limit) buffer.append(truncated)\r\n    buffer.append(postfix)\r\n    return buffer\r\n}\r\n\r\n/**\r\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\r\n * \r\n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\r\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\r\n * \r\n * @sample samples.collections.Collections.Transformations.joinTo\r\n */\r\npublic fun <A : Appendable> BooleanArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Boolean) -> CharSequence)? = null): A {\r\n    buffer.append(prefix)\r\n    var count = 0\r\n    for (element in this) {\r\n        if (++count > 1) buffer.append(separator)\r\n        if (limit < 0 || count <= limit) {\r\n            if (transform != null)\r\n                buffer.append(transform(element))\r\n            else\r\n                buffer.append(element.toString())\r\n        } else break\r\n    }\r\n    if (limit >= 0 && count > limit) buffer.append(truncated)\r\n    buffer.append(postfix)\r\n    return buffer\r\n}\r\n\r\n/**\r\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\r\n * \r\n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\r\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\r\n * \r\n * @sample samples.collections.Collections.Transformations.joinTo\r\n */\r\npublic fun <A : Appendable> CharArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Char) -> CharSequence)? = null): A {\r\n    buffer.append(prefix)\r\n    var count = 0\r\n    for (element in this) {\r\n        if (++count > 1) buffer.append(separator)\r\n        if (limit < 0 || count <= limit) {\r\n            if (transform != null)\r\n                buffer.append(transform(element))\r\n            else\r\n                buffer.append(element)\r\n        } else break\r\n    }\r\n    if (limit >= 0 && count > limit) buffer.append(truncated)\r\n    buffer.append(postfix)\r\n    return buffer\r\n}\r\n\r\n/**\r\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\r\n * \r\n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\r\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\r\n * \r\n * @sample samples.collections.Collections.Transformations.joinToString\r\n */\r\npublic fun <T> Array<out T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\r\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\r\n}\r\n\r\n/**\r\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\r\n * \r\n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\r\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\r\n * \r\n * @sample samples.collections.Collections.Transformations.joinToString\r\n */\r\npublic fun ByteArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Byte) -> CharSequence)? = null): String {\r\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\r\n}\r\n\r\n/**\r\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\r\n * \r\n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\r\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\r\n * \r\n * @sample samples.collections.Collections.Transformations.joinToString\r\n */\r\npublic fun ShortArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Short) -> CharSequence)? = null): String {\r\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\r\n}\r\n\r\n/**\r\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\r\n * \r\n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\r\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\r\n * \r\n * @sample samples.collections.Collections.Transformations.joinToString\r\n */\r\npublic fun IntArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Int) -> CharSequence)? = null): String {\r\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\r\n}\r\n\r\n/**\r\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\r\n * \r\n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\r\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\r\n * \r\n * @sample samples.collections.Collections.Transformations.joinToString\r\n */\r\npublic fun LongArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Long) -> CharSequence)? = null): String {\r\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\r\n}\r\n\r\n/**\r\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\r\n * \r\n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\r\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\r\n * \r\n * @sample samples.collections.Collections.Transformations.joinToString\r\n */\r\npublic fun FloatArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Float) -> CharSequence)? = null): String {\r\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\r\n}\r\n\r\n/**\r\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\r\n * \r\n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\r\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\r\n * \r\n * @sample samples.collections.Collections.Transformations.joinToString\r\n */\r\npublic fun DoubleArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Double) -> CharSequence)? = null): String {\r\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\r\n}\r\n\r\n/**\r\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\r\n * \r\n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\r\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\r\n * \r\n * @sample samples.collections.Collections.Transformations.joinToString\r\n */\r\npublic fun BooleanArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Boolean) -> CharSequence)? = null): String {\r\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\r\n}\r\n\r\n/**\r\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\r\n * \r\n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\r\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\r\n * \r\n * @sample samples.collections.Collections.Transformations.joinToString\r\n */\r\npublic fun CharArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Char) -> CharSequence)? = null): String {\r\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\r\n}\r\n\r\n/**\r\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\r\n */\r\npublic fun <T> Array<out T>.asIterable(): Iterable<T> {\r\n    if (isEmpty()) return emptyList()\r\n    return Iterable { this.iterator() }\r\n}\r\n\r\n/**\r\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\r\n */\r\npublic fun ByteArray.asIterable(): Iterable<Byte> {\r\n    if (isEmpty()) return emptyList()\r\n    return Iterable { this.iterator() }\r\n}\r\n\r\n/**\r\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\r\n */\r\npublic fun ShortArray.asIterable(): Iterable<Short> {\r\n    if (isEmpty()) return emptyList()\r\n    return Iterable { this.iterator() }\r\n}\r\n\r\n/**\r\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\r\n */\r\npublic fun IntArray.asIterable(): Iterable<Int> {\r\n    if (isEmpty()) return emptyList()\r\n    return Iterable { this.iterator() }\r\n}\r\n\r\n/**\r\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\r\n */\r\npublic fun LongArray.asIterable(): Iterable<Long> {\r\n    if (isEmpty()) return emptyList()\r\n    return Iterable { this.iterator() }\r\n}\r\n\r\n/**\r\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\r\n */\r\npublic fun FloatArray.asIterable(): Iterable<Float> {\r\n    if (isEmpty()) return emptyList()\r\n    return Iterable { this.iterator() }\r\n}\r\n\r\n/**\r\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\r\n */\r\npublic fun DoubleArray.asIterable(): Iterable<Double> {\r\n    if (isEmpty()) return emptyList()\r\n    return Iterable { this.iterator() }\r\n}\r\n\r\n/**\r\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\r\n */\r\npublic fun BooleanArray.asIterable(): Iterable<Boolean> {\r\n    if (isEmpty()) return emptyList()\r\n    return Iterable { this.iterator() }\r\n}\r\n\r\n/**\r\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\r\n */\r\npublic fun CharArray.asIterable(): Iterable<Char> {\r\n    if (isEmpty()) return emptyList()\r\n    return Iterable { this.iterator() }\r\n}\r\n\r\n/**\r\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\r\n * \r\n * @sample samples.collections.Sequences.Building.sequenceFromArray\r\n */\r\npublic fun <T> Array<out T>.asSequence(): Sequence<T> {\r\n    if (isEmpty()) return emptySequence()\r\n    return Sequence { this.iterator() }\r\n}\r\n\r\n/**\r\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\r\n * \r\n * @sample samples.collections.Sequences.Building.sequenceFromArray\r\n */\r\npublic fun ByteArray.asSequence(): Sequence<Byte> {\r\n    if (isEmpty()) return emptySequence()\r\n    return Sequence { this.iterator() }\r\n}\r\n\r\n/**\r\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\r\n * \r\n * @sample samples.collections.Sequences.Building.sequenceFromArray\r\n */\r\npublic fun ShortArray.asSequence(): Sequence<Short> {\r\n    if (isEmpty()) return emptySequence()\r\n    return Sequence { this.iterator() }\r\n}\r\n\r\n/**\r\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\r\n * \r\n * @sample samples.collections.Sequences.Building.sequenceFromArray\r\n */\r\npublic fun IntArray.asSequence(): Sequence<Int> {\r\n    if (isEmpty()) return emptySequence()\r\n    return Sequence { this.iterator() }\r\n}\r\n\r\n/**\r\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\r\n * \r\n * @sample samples.collections.Sequences.Building.sequenceFromArray\r\n */\r\npublic fun LongArray.asSequence(): Sequence<Long> {\r\n    if (isEmpty()) return emptySequence()\r\n    return Sequence { this.iterator() }\r\n}\r\n\r\n/**\r\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\r\n * \r\n * @sample samples.collections.Sequences.Building.sequenceFromArray\r\n */\r\npublic fun FloatArray.asSequence(): Sequence<Float> {\r\n    if (isEmpty()) return emptySequence()\r\n    return Sequence { this.iterator() }\r\n}\r\n\r\n/**\r\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\r\n * \r\n * @sample samples.collections.Sequences.Building.sequenceFromArray\r\n */\r\npublic fun DoubleArray.asSequence(): Sequence<Double> {\r\n    if (isEmpty()) return emptySequence()\r\n    return Sequence { this.iterator() }\r\n}\r\n\r\n/**\r\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\r\n * \r\n * @sample samples.collections.Sequences.Building.sequenceFromArray\r\n */\r\npublic fun BooleanArray.asSequence(): Sequence<Boolean> {\r\n    if (isEmpty()) return emptySequence()\r\n    return Sequence { this.iterator() }\r\n}\r\n\r\n/**\r\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\r\n * \r\n * @sample samples.collections.Sequences.Building.sequenceFromArray\r\n */\r\npublic fun CharArray.asSequence(): Sequence<Char> {\r\n    if (isEmpty()) return emptySequence()\r\n    return Sequence { this.iterator() }\r\n}\r\n\r\n/**\r\n * Returns an average value of elements in the array.\r\n */\r\n@kotlin.jvm.JvmName(\"averageOfByte\")\r\npublic fun Array<out Byte>.average(): Double {\r\n    var sum: Double = 0.0\r\n    var count: Int = 0\r\n    for (element in this) {\r\n        sum += element\r\n        ++count\r\n    }\r\n    return if (count == 0) Double.NaN else sum / count\r\n}\r\n\r\n/**\r\n * Returns an average value of elements in the array.\r\n */\r\n@kotlin.jvm.JvmName(\"averageOfShort\")\r\npublic fun Array<out Short>.average(): Double {\r\n    var sum: Double = 0.0\r\n    var count: Int = 0\r\n    for (element in this) {\r\n        sum += element\r\n        ++count\r\n    }\r\n    return if (count == 0) Double.NaN else sum / count\r\n}\r\n\r\n/**\r\n * Returns an average value of elements in the array.\r\n */\r\n@kotlin.jvm.JvmName(\"averageOfInt\")\r\npublic fun Array<out Int>.average(): Double {\r\n    var sum: Double = 0.0\r\n    var count: Int = 0\r\n    for (element in this) {\r\n        sum += element\r\n        ++count\r\n    }\r\n    return if (count == 0) Double.NaN else sum / count\r\n}\r\n\r\n/**\r\n * Returns an average value of elements in the array.\r\n */\r\n@kotlin.jvm.JvmName(\"averageOfLong\")\r\npublic fun Array<out Long>.average(): Double {\r\n    var sum: Double = 0.0\r\n    var count: Int = 0\r\n    for (element in this) {\r\n        sum += element\r\n        ++count\r\n    }\r\n    return if (count == 0) Double.NaN else sum / count\r\n}\r\n\r\n/**\r\n * Returns an average value of elements in the array.\r\n */\r\n@kotlin.jvm.JvmName(\"averageOfFloat\")\r\npublic fun Array<out Float>.average(): Double {\r\n    var sum: Double = 0.0\r\n    var count: Int = 0\r\n    for (element in this) {\r\n        sum += element\r\n        ++count\r\n    }\r\n    return if (count == 0) Double.NaN else sum / count\r\n}\r\n\r\n/**\r\n * Returns an average value of elements in the array.\r\n */\r\n@kotlin.jvm.JvmName(\"averageOfDouble\")\r\npublic fun Array<out Double>.average(): Double {\r\n    var sum: Double = 0.0\r\n    var count: Int = 0\r\n    for (element in this) {\r\n        sum += element\r\n        ++count\r\n    }\r\n    return if (count == 0) Double.NaN else sum / count\r\n}\r\n\r\n/**\r\n * Returns an average value of elements in the array.\r\n */\r\npublic fun ByteArray.average(): Double {\r\n    var sum: Double = 0.0\r\n    var count: Int = 0\r\n    for (element in this) {\r\n        sum += element\r\n        ++count\r\n    }\r\n    return if (count == 0) Double.NaN else sum / count\r\n}\r\n\r\n/**\r\n * Returns an average value of elements in the array.\r\n */\r\npublic fun ShortArray.average(): Double {\r\n    var sum: Double = 0.0\r\n    var count: Int = 0\r\n    for (element in this) {\r\n        sum += element\r\n        ++count\r\n    }\r\n    return if (count == 0) Double.NaN else sum / count\r\n}\r\n\r\n/**\r\n * Returns an average value of elements in the array.\r\n */\r\npublic fun IntArray.average(): Double {\r\n    var sum: Double = 0.0\r\n    var count: Int = 0\r\n    for (element in this) {\r\n        sum += element\r\n        ++count\r\n    }\r\n    return if (count == 0) Double.NaN else sum / count\r\n}\r\n\r\n/**\r\n * Returns an average value of elements in the array.\r\n */\r\npublic fun LongArray.average(): Double {\r\n    var sum: Double = 0.0\r\n    var count: Int = 0\r\n    for (element in this) {\r\n        sum += element\r\n        ++count\r\n    }\r\n    return if (count == 0) Double.NaN else sum / count\r\n}\r\n\r\n/**\r\n * Returns an average value of elements in the array.\r\n */\r\npublic fun FloatArray.average(): Double {\r\n    var sum: Double = 0.0\r\n    var count: Int = 0\r\n    for (element in this) {\r\n        sum += element\r\n        ++count\r\n    }\r\n    return if (count == 0) Double.NaN else sum / count\r\n}\r\n\r\n/**\r\n * Returns an average value of elements in the array.\r\n */\r\npublic fun DoubleArray.average(): Double {\r\n    var sum: Double = 0.0\r\n    var count: Int = 0\r\n    for (element in this) {\r\n        sum += element\r\n        ++count\r\n    }\r\n    return if (count == 0) Double.NaN else sum / count\r\n}\r\n\r\n/**\r\n * Returns the sum of all elements in the array.\r\n */\r\n@kotlin.jvm.JvmName(\"sumOfByte\")\r\npublic fun Array<out Byte>.sum(): Int {\r\n    var sum: Int = 0\r\n    for (element in this) {\r\n        sum += element\r\n    }\r\n    return sum\r\n}\r\n\r\n/**\r\n * Returns the sum of all elements in the array.\r\n */\r\n@kotlin.jvm.JvmName(\"sumOfShort\")\r\npublic fun Array<out Short>.sum(): Int {\r\n    var sum: Int = 0\r\n    for (element in this) {\r\n        sum += element\r\n    }\r\n    return sum\r\n}\r\n\r\n/**\r\n * Returns the sum of all elements in the array.\r\n */\r\n@kotlin.jvm.JvmName(\"sumOfInt\")\r\npublic fun Array<out Int>.sum(): Int {\r\n    var sum: Int = 0\r\n    for (element in this) {\r\n        sum += element\r\n    }\r\n    return sum\r\n}\r\n\r\n/**\r\n * Returns the sum of all elements in the array.\r\n */\r\n@kotlin.jvm.JvmName(\"sumOfLong\")\r\npublic fun Array<out Long>.sum(): Long {\r\n    var sum: Long = 0L\r\n    for (element in this) {\r\n        sum += element\r\n    }\r\n    return sum\r\n}\r\n\r\n/**\r\n * Returns the sum of all elements in the array.\r\n */\r\n@kotlin.jvm.JvmName(\"sumOfFloat\")\r\npublic fun Array<out Float>.sum(): Float {\r\n    var sum: Float = 0.0f\r\n    for (element in this) {\r\n        sum += element\r\n    }\r\n    return sum\r\n}\r\n\r\n/**\r\n * Returns the sum of all elements in the array.\r\n */\r\n@kotlin.jvm.JvmName(\"sumOfDouble\")\r\npublic fun Array<out Double>.sum(): Double {\r\n    var sum: Double = 0.0\r\n    for (element in this) {\r\n        sum += element\r\n    }\r\n    return sum\r\n}\r\n\r\n/**\r\n * Returns the sum of all elements in the array.\r\n */\r\npublic fun ByteArray.sum(): Int {\r\n    var sum: Int = 0\r\n    for (element in this) {\r\n        sum += element\r\n    }\r\n    return sum\r\n}\r\n\r\n/**\r\n * Returns the sum of all elements in the array.\r\n */\r\npublic fun ShortArray.sum(): Int {\r\n    var sum: Int = 0\r\n    for (element in this) {\r\n        sum += element\r\n    }\r\n    return sum\r\n}\r\n\r\n/**\r\n * Returns the sum of all elements in the array.\r\n */\r\npublic fun IntArray.sum(): Int {\r\n    var sum: Int = 0\r\n    for (element in this) {\r\n        sum += element\r\n    }\r\n    return sum\r\n}\r\n\r\n/**\r\n * Returns the sum of all elements in the array.\r\n */\r\npublic fun LongArray.sum(): Long {\r\n    var sum: Long = 0L\r\n    for (element in this) {\r\n        sum += element\r\n    }\r\n    return sum\r\n}\r\n\r\n/**\r\n * Returns the sum of all elements in the array.\r\n */\r\npublic fun FloatArray.sum(): Float {\r\n    var sum: Float = 0.0f\r\n    for (element in this) {\r\n        sum += element\r\n    }\r\n    return sum\r\n}\r\n\r\n/**\r\n * Returns the sum of all elements in the array.\r\n */\r\npublic fun DoubleArray.sum(): Double {\r\n    var sum: Double = 0.0\r\n    for (element in this) {\r\n        sum += element\r\n    }\r\n    return sum\r\n}\r\n\r\n","/*\r\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\r\n * that can be found in the license/LICENSE.txt file.\r\n */\r\n\r\npackage kotlin.collections\r\n\r\nimport kotlin.comparisons.naturalOrder\r\nimport kotlin.random.Random\r\n\r\n/** Returns the array if it's not `null`, or an empty array otherwise. */\r\n@kotlin.internal.InlineOnly\r\npublic actual inline fun <T> Array<out T>?.orEmpty(): Array<out T> = this ?: emptyArray<T>()\r\n\r\n@kotlin.internal.InlineOnly\r\npublic actual inline fun <T> Collection<T>.toTypedArray(): Array<T> = copyToArray(this)\r\n\r\n@JsName(\"copyToArray\")\r\n@PublishedApi\r\ninternal fun <T> copyToArray(collection: Collection<T>): Array<T> {\r\n    return if (collection.asDynamic().toArray !== undefined)\r\n        collection.asDynamic().toArray().unsafeCast<Array<T>>()\r\n    else\r\n        copyToArrayImpl(collection).unsafeCast<Array<T>>()\r\n}\r\n\r\n@JsName(\"copyToArrayImpl\")\r\ninternal actual fun copyToArrayImpl(collection: Collection<*>): Array<Any?> {\r\n    val array = emptyArray<Any?>()\r\n    val iterator = collection.iterator()\r\n    while (iterator.hasNext())\r\n        array.asDynamic().push(iterator.next())\r\n    return array\r\n}\r\n\r\n@JsName(\"copyToExistingArrayImpl\")\r\ninternal actual fun <T> copyToArrayImpl(collection: Collection<*>, array: Array<T>): Array<T> {\r\n    if (array.size < collection.size)\r\n        return copyToArrayImpl(collection).unsafeCast<Array<T>>()\r\n\r\n    val iterator = collection.iterator()\r\n    var index = 0\r\n    while (iterator.hasNext()) {\r\n        array[index++] = iterator.next().unsafeCast<T>()\r\n    }\r\n    if (index < array.size) {\r\n        array[index] = null.unsafeCast<T>()\r\n    }\r\n    return array\r\n}\r\n\r\n/**\r\n * Returns an immutable list containing only the specified object [element].\r\n */\r\npublic fun <T> listOf(element: T): List<T> = arrayListOf(element)\r\n\r\n/**\r\n * Returns an immutable set containing only the specified object [element].\r\n */\r\npublic fun <T> setOf(element: T): Set<T> = hashSetOf(element)\r\n\r\n/**\r\n * Returns an immutable map, mapping only the specified key to the\r\n * specified value.\r\n */\r\npublic fun <K, V> mapOf(pair: Pair<K, V>): Map<K, V> = hashMapOf(pair)\r\n\r\n/**\r\n * Fills the list with the provided [value].\r\n *\r\n * Each element in the list gets replaced with the [value].\r\n */\r\n@SinceKotlin(\"1.2\")\r\npublic actual fun <T> MutableList<T>.fill(value: T): Unit {\r\n    for (index in 0..lastIndex) {\r\n        this[index] = value\r\n    }\r\n}\r\n\r\n/**\r\n * Randomly shuffles elements in this list.\r\n *\r\n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\r\n */\r\n@SinceKotlin(\"1.2\")\r\npublic actual fun <T> MutableList<T>.shuffle(): Unit = shuffle(Random)\r\n\r\n/**\r\n * Returns a new list with the elements of this list randomly shuffled.\r\n */\r\n@SinceKotlin(\"1.2\")\r\npublic actual fun <T> Iterable<T>.shuffled(): List<T> = toMutableList().apply { shuffle() }\r\n\r\n/**\r\n * Sorts elements in the list in-place according to their natural sort order.\r\n *\r\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\r\n */\r\npublic actual fun <T : Comparable<T>> MutableList<T>.sort(): Unit {\r\n    collectionsSort(this, naturalOrder())\r\n}\r\n\r\n/**\r\n * Sorts elements in the list in-place according to the order specified with [comparator].\r\n *\r\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\r\n */\r\npublic actual fun <T> MutableList<T>.sortWith(comparator: Comparator<in T>): Unit {\r\n    collectionsSort(this, comparator)\r\n}\r\n\r\nprivate fun <T> collectionsSort(list: MutableList<T>, comparator: Comparator<in T>) {\r\n    if (list.size <= 1) return\r\n\r\n    val array = copyToArray(list)\r\n    sortArrayWith(array, comparator)\r\n\r\n    for (i in 0 until array.size) {\r\n        list[i] = array[i]\r\n    }\r\n}\r\n\r\ninternal actual fun <T> arrayOfNulls(reference: Array<T>, size: Int): Array<T> {\r\n    return arrayOfNulls<Any>(size).unsafeCast<Array<T>>()\r\n}\r\n\r\n@SinceKotlin(\"1.3\")\r\n@PublishedApi\r\n@JsName(\"arrayCopy\")\r\ninternal fun <T> arrayCopy(source: Array<out T>, destination: Array<in T>, destinationOffset: Int, startIndex: Int, endIndex: Int) {\r\n    AbstractList.checkRangeIndexes(startIndex, endIndex, source.size)\r\n    val rangeSize = endIndex - startIndex\r\n    AbstractList.checkRangeIndexes(destinationOffset, destinationOffset + rangeSize, destination.size)\r\n\r\n    if (js(\"ArrayBuffer\").isView(destination) && js(\"ArrayBuffer\").isView(source)) {\r\n        val subrange = source.asDynamic().subarray(startIndex, endIndex)\r\n        destination.asDynamic().set(subrange, destinationOffset)\r\n    } else {\r\n        if (source !== destination || destinationOffset <= startIndex) {\r\n            for (index in 0 until rangeSize) {\r\n                destination[destinationOffset + index] = source[startIndex + index]\r\n            }\r\n        } else {\r\n            for (index in rangeSize - 1 downTo 0) {\r\n                destination[destinationOffset + index] = source[startIndex + index]\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// no singleton map implementation in js, return map as is\r\n@Suppress(\"NOTHING_TO_INLINE\")\r\ninternal actual inline fun <K, V> Map<K, V>.toSingletonMapOrSelf(): Map<K, V> = this\r\n\r\n@Suppress(\"NOTHING_TO_INLINE\")\r\ninternal actual inline fun <K, V> Map<out K, V>.toSingletonMap(): Map<K, V> = this.toMutableMap()\r\n\r\n\r\n@Suppress(\"NOTHING_TO_INLINE\")\r\ninternal actual inline fun <T> Array<out T>.copyToArrayOfAny(isVarargs: Boolean): Array<out Any?> =\r\n    if (isVarargs)\r\n    // no need to copy vararg array in JS\r\n        this\r\n    else\r\n        this.copyOf()\r\n\r\n\r\n\r\n@PublishedApi\r\ninternal actual fun checkIndexOverflow(index: Int): Int {\r\n    if (index < 0) {\r\n        throwIndexOverflow()\r\n    }\r\n    return index\r\n}\r\n\r\n@PublishedApi\r\ninternal actual fun checkCountOverflow(count: Int): Int {\r\n    if (count < 0) {\r\n        throwCountOverflow()\r\n    }\r\n    return count\r\n}\r\n\r\n","/*\r\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\r\n * that can be found in the license/LICENSE.txt file.\r\n */\r\n\r\n@file:Suppress(\"UNUSED_PARAMETER\", \"NOTHING_TO_INLINE\")\r\n\r\npackage kotlin\r\n\r\n/**\r\n * Returns an empty array of the specified type [T].\r\n */\r\npublic inline fun <T> emptyArray(): Array<T> = js(\"[]\")\r\n\r\n@library\r\npublic fun <T> arrayOf(vararg elements: T): Array<T> = definedExternally\r\n\r\n@library\r\npublic fun doubleArrayOf(vararg elements: Double): DoubleArray = definedExternally\r\n\r\n@library\r\npublic fun floatArrayOf(vararg elements: Float): FloatArray = definedExternally\r\n\r\n@library\r\npublic fun longArrayOf(vararg elements: Long): LongArray = definedExternally\r\n\r\n@library\r\npublic fun intArrayOf(vararg elements: Int): IntArray = definedExternally\r\n\r\n@library\r\npublic fun charArrayOf(vararg elements: Char): CharArray = definedExternally\r\n\r\n@library\r\npublic fun shortArrayOf(vararg elements: Short): ShortArray = definedExternally\r\n\r\n@library\r\npublic fun byteArrayOf(vararg elements: Byte): ByteArray = definedExternally\r\n\r\n@library\r\npublic fun booleanArrayOf(vararg elements: Boolean): BooleanArray = definedExternally\r\n\r\n/**\r\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\r\n */\r\npublic actual fun <T> lazy(initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\r\n\r\n/**\r\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\r\n *\r\n * The [mode] parameter is ignored. */\r\npublic actual fun <T> lazy(mode: LazyThreadSafetyMode, initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\r\n\r\n/**\r\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\r\n *\r\n * The [lock] parameter is ignored.\r\n */\r\npublic actual fun <T> lazy(lock: Any?, initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\r\n\r\n\r\ninternal fun fillFrom(src: dynamic, dst: dynamic): dynamic {\r\n    val srcLen: Int = src.length\r\n    val dstLen: Int = dst.length\r\n    var index: Int = 0\r\n    while (index < srcLen && index < dstLen) dst[index] = src[index++]\r\n    return dst\r\n}\r\n\r\n\r\ninternal fun arrayCopyResize(source: dynamic, newSize: Int, defaultValue: Any?): dynamic {\r\n    val result = source.slice(0, newSize)\r\n    copyArrayType(source, result)\r\n    var index: Int = source.length\r\n    if (newSize > index) {\r\n        result.length = newSize\r\n        while (index < newSize) result[index++] = defaultValue\r\n    }\r\n    return result\r\n}\r\n\r\ninternal fun <T> arrayPlusCollection(array: dynamic, collection: Collection<T>): dynamic {\r\n    val result = array.slice()\r\n    result.length += collection.size\r\n    copyArrayType(array, result)\r\n    var index: Int = array.length\r\n    for (element in collection) result[index++] = element\r\n    return result\r\n}\r\n\r\ninternal fun <T> fillFromCollection(dst: dynamic, startIndex: Int, collection: Collection<T>): dynamic {\r\n    var index = startIndex\r\n    for (element in collection) dst[index++] = element\r\n    return dst\r\n}\r\n\r\ninternal inline fun copyArrayType(from: dynamic, to: dynamic) {\r\n    if (from.`$type$` !== undefined) {\r\n        to.`$type$` = from.`$type$`\r\n    }\r\n}\r\n\r\ninternal inline fun jsIsType(obj: dynamic, jsClass: dynamic) = js(\"Kotlin\").isType(obj, jsClass)","/*\r\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\r\n * that can be found in the license/LICENSE.txt file.\r\n */\r\n@file:Suppress(\"DEPRECATION\", \"DEPRECATION_ERROR\")\r\npackage kotlin.math\r\n\r\n\r\nimport kotlin.internal.InlineOnly\r\nimport kotlin.js.Math as nativeMath\r\n\r\n\r\n// region ================ Double Math ========================================\r\n\r\n/** Computes the sine of the angle [x] given in radians.\r\n *\r\n *  Special cases:\r\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\r\n\r\n/** Computes the cosine of the angle [x] given in radians.\r\n *\r\n *  Special cases:\r\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\r\n\r\n/** Computes the tangent of the angle [x] given in radians.\r\n *\r\n *  Special cases:\r\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\r\n\r\n/**\r\n * Computes the arc sine of the value [x];\r\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\r\n *\r\n * Special cases:\r\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\r\n\r\n/**\r\n * Computes the arc cosine of the value [x];\r\n * the returned value is an angle in the range from `0.0` to `PI` radians.\r\n *\r\n * Special cases:\r\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\r\n\r\n/**\r\n * Computes the arc tangent of the value [x];\r\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\r\n *\r\n * Special cases:\r\n *   - `atan(NaN)` is `NaN`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\r\n\r\n/**\r\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\r\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\r\n * the returned value is an angle in the range from `-PI` to `PI` radians.\r\n *\r\n * Special cases:\r\n *   - `atan2(0.0, 0.0)` is `0.0`\r\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\r\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\r\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\r\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\r\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\r\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\r\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\r\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\r\n\r\n/**\r\n * Computes the hyperbolic sine of the value [x].\r\n *\r\n * Special cases:\r\n *   - `sinh(NaN)` is `NaN`\r\n *   - `sinh(+Inf)` is `+Inf`\r\n *   - `sinh(-Inf)` is `-Inf`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun sinh(x: Double): Double = nativeMath.sinh(x)\r\n\r\n/**\r\n * Computes the hyperbolic cosine of the value [x].\r\n *\r\n * Special cases:\r\n *   - `cosh(NaN)` is `NaN`\r\n *   - `cosh(+Inf|-Inf)` is `+Inf`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun cosh(x: Double): Double = nativeMath.cosh(x)\r\n\r\n/**\r\n * Computes the hyperbolic tangent of the value [x].\r\n *\r\n * Special cases:\r\n *   - `tanh(NaN)` is `NaN`\r\n *   - `tanh(+Inf)` is `1.0`\r\n *   - `tanh(-Inf)` is `-1.0`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun tanh(x: Double): Double = nativeMath.tanh(x)\r\n\r\n/**\r\n * Computes the inverse hyperbolic sine of the value [x].\r\n *\r\n * The returned value is `y` such that `sinh(y) == x`.\r\n *\r\n * Special cases:\r\n *   - `asinh(NaN)` is `NaN`\r\n *   - `asinh(+Inf)` is `+Inf`\r\n *   - `asinh(-Inf)` is `-Inf`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun asinh(x: Double): Double = nativeMath.asinh(x)\r\n\r\n/**\r\n * Computes the inverse hyperbolic cosine of the value [x].\r\n *\r\n * The returned value is positive `y` such that `cosh(y) == x`.\r\n *\r\n * Special cases:\r\n *   - `acosh(NaN)` is `NaN`\r\n *   - `acosh(x)` is `NaN` when `x < 1`\r\n *   - `acosh(+Inf)` is `+Inf`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun acosh(x: Double): Double = nativeMath.acosh(x)\r\n\r\n/**\r\n * Computes the inverse hyperbolic tangent of the value [x].\r\n *\r\n * The returned value is `y` such that `tanh(y) == x`.\r\n *\r\n * Special cases:\r\n *   - `tanh(NaN)` is `NaN`\r\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\r\n *   - `tanh(1.0)` is `+Inf`\r\n *   - `tanh(-1.0)` is `-Inf`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun atanh(x: Double): Double = nativeMath.atanh(x)\r\n\r\n/**\r\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\r\n *\r\n * Special cases:\r\n *   - returns `+Inf` if any of arguments is infinite\r\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeMath.hypot(x, y)\r\n\r\n/**\r\n * Computes the positive square root of the value [x].\r\n *\r\n * Special cases:\r\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\r\n\r\n/**\r\n * Computes Euler's number `e` raised to the power of the value [x].\r\n *\r\n * Special cases:\r\n *   - `exp(NaN)` is `NaN`\r\n *   - `exp(+Inf)` is `+Inf`\r\n *   - `exp(-Inf)` is `0.0`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\r\n\r\n/**\r\n * Computes `exp(x) - 1`.\r\n *\r\n * This function can be implemented to produce more precise result for [x] near zero.\r\n *\r\n * Special cases:\r\n *   - `expm1(NaN)` is `NaN`\r\n *   - `expm1(+Inf)` is `+Inf`\r\n *   - `expm1(-Inf)` is `-1.0`\r\n *\r\n * @see [exp] function.\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun expm1(x: Double): Double = nativeMath.expm1(x)\r\n\r\n/**\r\n * Computes the logarithm of the value [x] to the given [base].\r\n *\r\n * Special cases:\r\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\r\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\r\n *   - `log(+Inf, +Inf)` is `NaN`\r\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\r\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\r\n *\r\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\r\n */\r\n@SinceKotlin(\"1.2\")\r\npublic actual fun log(x: Double, base: Double): Double {\r\n    if (base <= 0.0 || base == 1.0) return Double.NaN\r\n    return nativeMath.log(x) / nativeMath.log(base)\r\n}\r\n\r\n/**\r\n * Computes the natural logarithm (base `E`) of the value [x].\r\n *\r\n * Special cases:\r\n *   - `ln(NaN)` is `NaN`\r\n *   - `ln(x)` is `NaN` when `x < 0.0`\r\n *   - `ln(+Inf)` is `+Inf`\r\n *   - `ln(0.0)` is `-Inf`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\r\n\r\n/**\r\n * Computes the common logarithm (base 10) of the value [x].\r\n *\r\n * @see [ln] function for special cases.\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun log10(x: Double): Double = nativeMath.log10(x)\r\n\r\n/**\r\n * Computes the binary logarithm (base 2) of the value [x].\r\n *\r\n * @see [ln] function for special cases.\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun log2(x: Double): Double = nativeMath.log2(x)\r\n\r\n/**\r\n * Computes `ln(x + 1)`.\r\n *\r\n * This function can be implemented to produce more precise result for [x] near zero.\r\n *\r\n * Special cases:\r\n *   - `ln1p(NaN)` is `NaN`\r\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\r\n *   - `ln1p(-1.0)` is `-Inf`\r\n *   - `ln1p(+Inf)` is `+Inf`\r\n *\r\n * @see [ln] function\r\n * @see [expm1] function\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun ln1p(x: Double): Double = nativeMath.log1p(x)\r\n\r\n/**\r\n * Rounds the given value [x] to an integer towards positive infinity.\r\n\r\n * @return the smallest double value that is greater than the given value [x] and is a mathematical integer.\r\n *\r\n * Special cases:\r\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x).unsafeCast<Double>() // TODO: Remove unsafe cast after removing public js.math\r\n\r\n/**\r\n * Rounds the given value [x] to an integer towards negative infinity.\r\n\r\n * @return the largest double value that is smaller than the given value [x] and is a mathematical integer.\r\n *\r\n * Special cases:\r\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x).unsafeCast<Double>()\r\n\r\n/**\r\n * Rounds the given value [x] to an integer towards zero.\r\n *\r\n * @return the value [x] having its fractional part truncated.\r\n *\r\n * Special cases:\r\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun truncate(x: Double): Double = nativeMath.trunc(x)\r\n\r\n/**\r\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\r\n *\r\n * Special cases:\r\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\r\n */\r\n@SinceKotlin(\"1.2\")\r\npublic actual fun round(x: Double): Double {\r\n    if (x % 0.5 != 0.0) {\r\n        return nativeMath.round(x).unsafeCast<Double>()\r\n    }\r\n    val floor = floor(x)\r\n    return if (floor % 2 == 0.0) floor else ceil(x)\r\n}\r\n\r\n/**\r\n * Returns the absolute value of the given value [x].\r\n *\r\n * Special cases:\r\n *   - `abs(NaN)` is `NaN`\r\n *\r\n * @see absoluteValue extension property for [Double]\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\r\n\r\n/**\r\n * Returns the sign of the given value [x]:\r\n *   - `-1.0` if the value is negative,\r\n *   - zero if the value is zero,\r\n *   - `1.0` if the value is positive\r\n *\r\n * Special case:\r\n *   - `sign(NaN)` is `NaN`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun sign(x: Double): Double = nativeMath.sign(x)\r\n\r\n\r\n/**\r\n * Returns the smaller of two values.\r\n *\r\n * If either value is `NaN`, then the result is `NaN`.\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\r\n\r\n/**\r\n * Returns the greater of two values.\r\n *\r\n * If either value is `NaN`, then the result is `NaN`.\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\r\n\r\n// extensions\r\n\r\n/**\r\n * Raises this value to the power [x].\r\n *\r\n * Special cases:\r\n *   - `b.pow(0.0)` is `1.0`\r\n *   - `b.pow(1.0) == b`\r\n *   - `b.pow(NaN)` is `NaN`\r\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\r\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\r\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\r\n\r\n/**\r\n * Raises this value to the integer power [n].\r\n *\r\n * See the other overload of [pow] for details.\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\r\n\r\n/**\r\n * Returns the absolute value of this value.\r\n *\r\n * Special cases:\r\n *   - `NaN.absoluteValue` is `NaN`\r\n *\r\n * @see abs function\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\r\n\r\n/**\r\n * Returns the sign of this value:\r\n *   - `-1.0` if the value is negative,\r\n *   - zero if the value is zero,\r\n *   - `1.0` if the value is positive\r\n *\r\n * Special case:\r\n *   - `NaN.sign` is `NaN`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline val Double.sign: Double get() = nativeMath.sign(this)\r\n\r\n/**\r\n * Returns this value with the sign bit same as of the [sign] value.\r\n *\r\n * If [sign] is `NaN` the sign of the result is undefined.\r\n */\r\n@SinceKotlin(\"1.2\")\r\npublic actual fun Double.withSign(sign: Double): Double {\r\n    val thisSignBit = js(\"Kotlin\").doubleSignBit(this).unsafeCast<Int>()\r\n    val newSignBit = js(\"Kotlin\").doubleSignBit(sign).unsafeCast<Int>()\r\n    return if (thisSignBit == newSignBit) this else -this\r\n}\r\n\r\n/**\r\n * Returns this value with the sign bit same as of the [sign] value.\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\r\n\r\n/**\r\n * Returns the ulp (unit in the last place) of this value.\r\n *\r\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\r\n *\r\n * Special Cases:\r\n *   - `NaN.ulp` is `NaN`\r\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\r\n *   - `0.0.ulp` is `Double.MIN_VALUE`\r\n */\r\n@SinceKotlin(\"1.2\")\r\npublic actual val Double.ulp: Double get() = when {\r\n    this < 0 -> (-this).ulp\r\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\r\n    this == Double.MAX_VALUE -> this - this.nextDown()\r\n    else -> this.nextUp() - this\r\n}\r\n\r\n/**\r\n * Returns the [Double] value nearest to this value in direction of positive infinity.\r\n */\r\n@SinceKotlin(\"1.2\")\r\npublic actual fun Double.nextUp(): Double = when {\r\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\r\n    this == 0.0 -> Double.MIN_VALUE\r\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\r\n}\r\n\r\n/**\r\n * Returns the [Double] value nearest to this value in direction of negative infinity.\r\n */\r\n@SinceKotlin(\"1.2\")\r\npublic actual fun Double.nextDown(): Double = when {\r\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\r\n    this == 0.0 -> -Double.MIN_VALUE\r\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\r\n}\r\n\r\n\r\n/**\r\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\r\n *\r\n * Special cases:\r\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\r\n *   - `x.nextTowards(x) == x`\r\n *\r\n */\r\n@SinceKotlin(\"1.2\")\r\npublic actual fun Double.nextTowards(to: Double): Double = when {\r\n    this.isNaN() || to.isNaN() -> Double.NaN\r\n    to == this -> to\r\n    to > this -> this.nextUp()\r\n    else /* to < this */ -> this.nextDown()\r\n}\r\n\r\n\r\n/**\r\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\r\n * Ties are rounded towards positive infinity.\r\n *\r\n * Special cases:\r\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\r\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\r\n *\r\n * @throws IllegalArgumentException when this value is `NaN`\r\n */\r\n@SinceKotlin(\"1.2\")\r\npublic actual fun Double.roundToInt(): Int = when {\r\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\r\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\r\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\r\n    else -> nativeMath.round(this).unsafeCast<Double>().toInt()\r\n}\r\n\r\n/**\r\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\r\n * Ties are rounded towards positive infinity.\r\n *\r\n * Special cases:\r\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\r\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\r\n *\r\n * @throws IllegalArgumentException when this value is `NaN`\r\n */\r\n@SinceKotlin(\"1.2\")\r\npublic actual fun Double.roundToLong(): Long = when {\r\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\r\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\r\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\r\n    else -> nativeMath.round(this).unsafeCast<Double>().toLong()\r\n}\r\n\r\n// endregion\r\n\r\n\r\n\r\n// region ================ Float Math ========================================\r\n\r\n/** Computes the sine of the angle [x] given in radians.\r\n *\r\n *  Special cases:\r\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\r\n\r\n/** Computes the cosine of the angle [x] given in radians.\r\n *\r\n *  Special cases:\r\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\r\n\r\n/** Computes the tangent of the angle [x] given in radians.\r\n *\r\n *  Special cases:\r\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\r\n\r\n/**\r\n * Computes the arc sine of the value [x];\r\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\r\n *\r\n * Special cases:\r\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\r\n\r\n/**\r\n * Computes the arc cosine of the value [x];\r\n * the returned value is an angle in the range from `0.0` to `PI` radians.\r\n *\r\n * Special cases:\r\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\r\n\r\n/**\r\n * Computes the arc tangent of the value [x];\r\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\r\n *\r\n * Special cases:\r\n *   - `atan(NaN)` is `NaN`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\r\n\r\n/**\r\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\r\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\r\n * the returned value is an angle in the range from `-PI` to `PI` radians.\r\n *\r\n * Special cases:\r\n *   - `atan2(0.0, 0.0)` is `0.0`\r\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\r\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\r\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\r\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\r\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\r\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\r\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\r\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\r\n\r\n/**\r\n * Computes the hyperbolic sine of the value [x].\r\n *\r\n * Special cases:\r\n *   - `sinh(NaN)` is `NaN`\r\n *   - `sinh(+Inf)` is `+Inf`\r\n *   - `sinh(-Inf)` is `-Inf`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun sinh(x: Float): Float = nativeMath.sinh(x.toDouble()).toFloat()\r\n\r\n/**\r\n * Computes the hyperbolic cosine of the value [x].\r\n *\r\n * Special cases:\r\n *   - `cosh(NaN)` is `NaN`\r\n *   - `cosh(+Inf|-Inf)` is `+Inf`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun cosh(x: Float): Float = nativeMath.cosh(x.toDouble()).toFloat()\r\n\r\n/**\r\n * Computes the hyperbolic tangent of the value [x].\r\n *\r\n * Special cases:\r\n *   - `tanh(NaN)` is `NaN`\r\n *   - `tanh(+Inf)` is `1.0`\r\n *   - `tanh(-Inf)` is `-1.0`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun tanh(x: Float): Float = nativeMath.tanh(x.toDouble()).toFloat()\r\n\r\n/**\r\n * Computes the inverse hyperbolic sine of the value [x].\r\n *\r\n * The returned value is `y` such that `sinh(y) == x`.\r\n *\r\n * Special cases:\r\n *   - `asinh(NaN)` is `NaN`\r\n *   - `asinh(+Inf)` is `+Inf`\r\n *   - `asinh(-Inf)` is `-Inf`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun asinh(x: Float): Float = nativeMath.asinh(x.toDouble()).toFloat()\r\n\r\n/**\r\n * Computes the inverse hyperbolic cosine of the value [x].\r\n *\r\n * The returned value is positive `y` such that `cosh(y) == x`.\r\n *\r\n * Special cases:\r\n *   - `acosh(NaN)` is `NaN`\r\n *   - `acosh(x)` is `NaN` when `x < 1`\r\n *   - `acosh(+Inf)` is `+Inf`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun acosh(x: Float): Float = nativeMath.acosh(x.toDouble()).toFloat()\r\n\r\n/**\r\n * Computes the inverse hyperbolic tangent of the value [x].\r\n *\r\n * The returned value is `y` such that `tanh(y) == x`.\r\n *\r\n * Special cases:\r\n *   - `tanh(NaN)` is `NaN`\r\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\r\n *   - `tanh(1.0)` is `+Inf`\r\n *   - `tanh(-1.0)` is `-Inf`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun atanh(x: Float): Float = nativeMath.atanh(x.toDouble()).toFloat()\r\n\r\n/**\r\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\r\n *\r\n * Special cases:\r\n *   - returns `+Inf` if any of arguments is infinite\r\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeMath.hypot(x.toDouble(), y.toDouble()).toFloat()\r\n\r\n/**\r\n * Computes the positive square root of the value [x].\r\n *\r\n * Special cases:\r\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\r\n\r\n/**\r\n * Computes Euler's number `e` raised to the power of the value [x].\r\n *\r\n * Special cases:\r\n *   - `exp(NaN)` is `NaN`\r\n *   - `exp(+Inf)` is `+Inf`\r\n *   - `exp(-Inf)` is `0.0`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\r\n\r\n/**\r\n * Computes `exp(x) - 1`.\r\n *\r\n * This function can be implemented to produce more precise result for [x] near zero.\r\n *\r\n * Special cases:\r\n *   - `expm1(NaN)` is `NaN`\r\n *   - `expm1(+Inf)` is `+Inf`\r\n *   - `expm1(-Inf)` is `-1.0`\r\n *\r\n * @see [exp] function.\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun expm1(x: Float): Float = nativeMath.expm1(x.toDouble()).toFloat()\r\n\r\n/**\r\n * Computes the logarithm of the value [x] to the given [base].\r\n *\r\n * Special cases:\r\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\r\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\r\n *   - `log(+Inf, +Inf)` is `NaN`\r\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\r\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\r\n *\r\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\r\n\r\n/**\r\n * Computes the natural logarithm (base `E`) of the value [x].\r\n *\r\n * Special cases:\r\n *   - `ln(NaN)` is `NaN`\r\n *   - `ln(x)` is `NaN` when `x < 0.0`\r\n *   - `ln(+Inf)` is `+Inf`\r\n *   - `ln(0.0)` is `-Inf`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\r\n\r\n/**\r\n * Computes the common logarithm (base 10) of the value [x].\r\n *\r\n * @see [ln] function for special cases.\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun log10(x: Float): Float = nativeMath.log10(x.toDouble()).toFloat()\r\n\r\n/**\r\n * Computes the binary logarithm (base 2) of the value [x].\r\n *\r\n * @see [ln] function for special cases.\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun log2(x: Float): Float = nativeMath.log2(x.toDouble()).toFloat()\r\n\r\n/**\r\n * Computes `ln(a + 1)`.\r\n *\r\n * This function can be implemented to produce more precise result for [x] near zero.\r\n *\r\n * Special cases:\r\n *   - `ln1p(NaN)` is `NaN`\r\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\r\n *   - `ln1p(-1.0)` is `-Inf`\r\n *   - `ln1p(+Inf)` is `+Inf`\r\n *\r\n * @see [ln] function\r\n * @see [expm1] function\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun ln1p(x: Float): Float = nativeMath.log1p(x.toDouble()).toFloat()\r\n\r\n/**\r\n * Rounds the given value [x] to an integer towards positive infinity.\r\n\r\n * @return the smallest Float value that is greater than the given value [x] and is a mathematical integer.\r\n *\r\n * Special cases:\r\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\r\n\r\n/**\r\n * Rounds the given value [x] to an integer towards negative infinity.\r\n\r\n * @return the largest Float value that is smaller than the given value [x] and is a mathematical integer.\r\n *\r\n * Special cases:\r\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\r\n\r\n/**\r\n * Rounds the given value [x] to an integer towards zero.\r\n *\r\n * @return the value [x] having its fractional part truncated.\r\n *\r\n * Special cases:\r\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\r\n\r\n/**\r\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\r\n *\r\n * Special cases:\r\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\r\n\r\n\r\n/**\r\n * Returns the absolute value of the given value [x].\r\n *\r\n * Special cases:\r\n *   - `abs(NaN)` is `NaN`\r\n *\r\n * @see absoluteValue extension property for [Float]\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\r\n\r\n/**\r\n * Returns the sign of the given value [x]:\r\n *   - `-1.0` if the value is negative,\r\n *   - zero if the value is zero,\r\n *   - `1.0` if the value is positive\r\n *\r\n * Special case:\r\n *   - `sign(NaN)` is `NaN`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun sign(x: Float): Float = nativeMath.sign(x.toDouble()).toFloat()\r\n\r\n\r\n\r\n/**\r\n * Returns the smaller of two values.\r\n *\r\n * If either value is `NaN`, then the result is `NaN`.\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\r\n\r\n/**\r\n * Returns the greater of two values.\r\n *\r\n * If either value is `NaN`, then the result is `NaN`.\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\r\n\r\n// extensions\r\n\r\n\r\n/**\r\n * Raises this value to the power [x].\r\n *\r\n * Special cases:\r\n *   - `b.pow(0.0)` is `1.0`\r\n *   - `b.pow(1.0) == b`\r\n *   - `b.pow(NaN)` is `NaN`\r\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\r\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\r\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\r\n\r\n/**\r\n * Raises this value to the integer power [n].\r\n *\r\n * See the other overload of [pow] for details.\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\r\n\r\n/**\r\n * Returns the absolute value of this value.\r\n *\r\n * Special cases:\r\n *   - `NaN.absoluteValue` is `NaN`\r\n *\r\n * @see abs function\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\r\n\r\n/**\r\n * Returns the sign of this value:\r\n *   - `-1.0` if the value is negative,\r\n *   - zero if the value is zero,\r\n *   - `1.0` if the value is positive\r\n *\r\n * Special case:\r\n *   - `NaN.sign` is `NaN`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline val Float.sign: Float get() = nativeMath.sign(this.toDouble()).toFloat()\r\n\r\n/**\r\n * Returns this value with the sign bit same as of the [sign] value.\r\n *\r\n * If [sign] is `NaN` the sign of the result is undefined.\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\r\n\r\n/**\r\n * Returns this value with the sign bit same as of the [sign] value.\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\r\n\r\n\r\n/**\r\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\r\n * Ties are rounded towards positive infinity.\r\n *\r\n * Special cases:\r\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\r\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\r\n *\r\n * @throws IllegalArgumentException when this value is `NaN`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\r\n\r\n/**\r\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\r\n * Ties are rounded towards positive infinity.\r\n *\r\n * Special cases:\r\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\r\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\r\n *\r\n * @throws IllegalArgumentException when this value is `NaN`\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\r\n\r\n\r\n// endregion\r\n\r\n// region ================ Integer Math ========================================\r\n\r\n\r\n/**\r\n * Returns the absolute value of the given value [n].\r\n *\r\n * Special cases:\r\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\r\n *\r\n * @see absoluteValue extension property for [Int]\r\n */\r\n// TODO: remove manual 'or' when KT-19290 is fixed\r\n@SinceKotlin(\"1.2\")\r\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\r\n\r\n/**\r\n * Returns the smaller of two values.\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\r\n\r\n/**\r\n * Returns the greater of two values.\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\r\n\r\n/**\r\n * Returns the absolute value of this value.\r\n *\r\n * Special cases:\r\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\r\n *\r\n * @see abs function\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\r\n\r\n/**\r\n * Returns the sign of this value:\r\n *   - `-1` if the value is negative,\r\n *   - `0` if the value is zero,\r\n *   - `1` if the value is positive\r\n */\r\n@SinceKotlin(\"1.2\")\r\npublic actual val Int.sign: Int get() = when {\r\n    this < 0 -> -1\r\n    this > 0 -> 1\r\n    else -> 0\r\n}\r\n\r\n\r\n\r\n/**\r\n * Returns the absolute value of the given value [n].\r\n *\r\n * Special cases:\r\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\r\n *\r\n * @see absoluteValue extension property for [Long]\r\n */\r\n@SinceKotlin(\"1.2\")\r\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\r\n\r\n/**\r\n * Returns the smaller of two values.\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@Suppress(\"NOTHING_TO_INLINE\")\r\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\r\n\r\n/**\r\n * Returns the greater of two values.\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@Suppress(\"NOTHING_TO_INLINE\")\r\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\r\n\r\n/**\r\n * Returns the absolute value of this value.\r\n *\r\n * Special cases:\r\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\r\n *\r\n * @see abs function\r\n */\r\n@SinceKotlin(\"1.2\")\r\n@InlineOnly\r\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\r\n\r\n/**\r\n * Returns the sign of this value:\r\n *   - `-1` if the value is negative,\r\n *   - `0` if the value is zero,\r\n *   - `1` if the value is positive\r\n */\r\n@SinceKotlin(\"1.2\")\r\npublic actual val Long.sign: Int get() = when {\r\n    this < 0 -> -1\r\n    this > 0 -> 1\r\n    else -> 0\r\n}\r\n\r\n\r\n// endregion\r\n","import kotlin.js.Date as DateJS\r\n\r\nclass BuyHouse(val price: Int, val downpaymentPctn: Int, val mortgage: Int) : Strategy {\r\n    var executed = false\r\n    val requiredDownpayment = price * downpaymentPctn / 100\r\n    override fun run(cp: Checkpoint): Checkpoint {\r\n        if (cp.downpayment >= requiredDownpayment && !executed) {\r\n            executed = true\r\n            return buyHouse(cp).also { print(cp.messages.lastOrNull()) }\r\n        }\r\n        return cp\r\n    }\r\n\r\n    private fun buyHouse(cp: Checkpoint) =\r\n        cp.modifyDownpayment(-requiredDownpayment)\r\n            .copy(\r\n                expenses = cp.expenses.copy(rent = 0, mortgage = cp.expenses.mortgage + mortgage),\r\n                flags = cp.flags.plus(\"boughtHouse\" to true),\r\n                messages = cp.messages.plus(\"Buying  a house for $price and paying downpayment=$requiredDownpayment instantly\")\r\n            )\r\n}\r\n\r\nclass MakeBaby(\r\n    val condition: (Checkpoint) -> Boolean,\r\n    val delay: Int = 0,\r\n    val workingMonthsBeforeDecret: Int = 0,\r\n    val decretAfterBirth: Int = 0,\r\n    val newSalary: Int\r\n) : Strategy {\r\n    var started = false\r\n    lateinit var startedDate: Date\r\n\r\n    override fun run(cp: Checkpoint): Checkpoint {\r\n        if (!started) {\r\n            started = condition(cp)\r\n            startedDate = cp.date\r\n        }\r\n        if (started) {\r\n//            return when (Period.between(startedDate, cp.date).toTotalMonths().toInt()) {\r\n            return when (monthDiff(startedDate, cp.date)) {\r\n                0 -> {\r\n                    val msg = \"Start thinking about a baby\"\r\n                    println(msg)\r\n                    cp.copy(messages = cp.messages.plus(msg))\r\n                }\r\n                delay -> {\r\n                    val msg = \"Started a baby\"\r\n                    println(msg)\r\n                    cp.copy(flags = cp.flags.plus(\"started_baby\" to true), messages = cp.messages.plus(msg))\r\n                }\r\n                delay + workingMonthsBeforeDecret -> {\r\n                    val msg = \"Valya goes into decret\"\r\n                    println(msg)\r\n                    cp.copy(valyaSalary = 0, messages = cp.messages.plus(msg))\r\n                }\r\n                delay + 9 -> {\r\n                    val msg = \"Baby's born\"\r\n                    println(msg)\r\n                    cp.copy(flags = cp.flags.plus(\"baby_born\" to true), messages = cp.messages.plus(msg))\r\n                }\r\n                delay + 9 + decretAfterBirth -> {\r\n                    val msg = \"Valya goes back to work\"\r\n                    println(msg)\r\n                    cp.copy(valyaSalary = newSalary, messages = cp.messages.plus(msg))\r\n                }\r\n                else -> cp\r\n            }\r\n        }\r\n        return cp\r\n    }\r\n\r\n    private fun monthDiff(date1: Date, date2: Date): Int {\r\n        return 12 * (date2.year - date1.year) + (date2.month - date1.month)\r\n    }\r\n}\r\n\r\nclass KidEducation(val kidName: String, val birthday: Date, val dayCarePrice: Int, val schoolPrice: Int) :\r\n    Strategy {\r\n    val schoolStarts = Date(year = birthday.year + if (birthday.month < 9) 5 else 6, month = 9, day = 1)\r\n    override fun run(cp: Checkpoint): Checkpoint {\r\n        return cp\r\n    }\r\n\r\n}\r\n\r\nclass NoopStrategy : Strategy {\r\n    override fun run(cp: Checkpoint): Checkpoint {\r\n        println(cp)\r\n        return cp\r\n    }\r\n}\r\n\r\ninterface Strategy {\r\n    fun run(cp: Checkpoint): Checkpoint\r\n\r\n}\r\n\r\nclass StratChain(vararg val strats: Strategy) : Strategy {\r\n    override fun run(cp: Checkpoint): Checkpoint {\r\n        return strats.fold(cp, { cp, s -> s.run(cp) })\r\n    }\r\n}\r\n\r\nclass CustomStrat(val once: Boolean, val condition: String, val effect: String) : Strategy {\r\n    var executed = false\r\n    override fun run(checkpoint: Checkpoint): Checkpoint {\r\n        val cp = checkpoint.copy()\r\n        if (once && executed) return cp\r\n        try {\r\n            if (eval(condition)){\r\n                executed = true\r\n                eval(effect)\r\n            }\r\n        } catch (e: Exception) {\r\n            console.log(\"Error: \")\r\n            console.log(e)\r\n        }\r\n        return cp\r\n    }\r\n}","/*\r\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\r\n * that can be found in the license/LICENSE.txt file.\r\n */\r\n\r\n@file:kotlin.jvm.JvmMultifileClass\r\n@file:kotlin.jvm.JvmName(\"StandardKt\")\r\npackage kotlin\r\n\r\nimport kotlin.contracts.*\r\n\r\n/**\r\n * An exception is thrown to indicate that a method body remains to be implemented.\r\n */\r\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\r\n\r\n/**\r\n * Always throws [NotImplementedError] stating that operation is not implemented.\r\n */\r\n\r\n@kotlin.internal.InlineOnly\r\npublic inline fun TODO(): Nothing = throw NotImplementedError()\r\n\r\n/**\r\n * Always throws [NotImplementedError] stating that operation is not implemented.\r\n *\r\n * @param reason a string explaining why the implementation is missing.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\r\n\r\n\r\n\r\n/**\r\n * Calls the specified function [block] and returns its result.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun <R> run(block: () -> R): R {\r\n    contract {\r\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\r\n    }\r\n    return block()\r\n}\r\n\r\n/**\r\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun <T, R> T.run(block: T.() -> R): R {\r\n    contract {\r\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\r\n    }\r\n    return block()\r\n}\r\n\r\n/**\r\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\r\n    contract {\r\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\r\n    }\r\n    return receiver.block()\r\n}\r\n\r\n/**\r\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\r\n    contract {\r\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\r\n    }\r\n    block()\r\n    return this\r\n}\r\n\r\n/**\r\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\r\n */\r\n@kotlin.internal.InlineOnly\r\n@SinceKotlin(\"1.1\")\r\npublic inline fun <T> T.also(block: (T) -> Unit): T {\r\n    contract {\r\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\r\n    }\r\n    block(this)\r\n    return this\r\n}\r\n\r\n/**\r\n * Calls the specified function [block] with `this` value as its argument and returns its result.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun <T, R> T.let(block: (T) -> R): R {\r\n    contract {\r\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\r\n    }\r\n    return block(this)\r\n}\r\n\r\n/**\r\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\r\n */\r\n@kotlin.internal.InlineOnly\r\n@SinceKotlin(\"1.1\")\r\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\r\n    contract {\r\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\r\n    }\r\n    return if (predicate(this)) this else null\r\n}\r\n\r\n/**\r\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\r\n */\r\n@kotlin.internal.InlineOnly\r\n@SinceKotlin(\"1.1\")\r\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\r\n    contract {\r\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\r\n    }\r\n    return if (!predicate(this)) this else null\r\n}\r\n\r\n/**\r\n * Executes the given function [action] specified number of [times].\r\n *\r\n * A zero-based index of current iteration is passed as a parameter to [action].\r\n *\r\n * @sample samples.misc.ControlFlow.repeat\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\r\n    contract { callsInPlace(action) }\r\n\r\n    for (index in 0 until times) {\r\n        action(index)\r\n    }\r\n}\r\n","/*\r\n * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license \r\n * that can be found in the license/LICENSE.txt file.\r\n */\r\n\r\npackage kotlin.collections\r\n\r\n//\r\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\r\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\r\n//\r\n\r\nimport kotlin.js.*\r\nimport primitiveArrayConcat\r\nimport withType\r\n\r\n/**\r\n * Returns a [List] that wraps the original array.\r\n */\r\npublic actual fun <T> Array<out T>.asList(): List<T> {\r\n    return ArrayList<T>(this.unsafeCast<Array<Any?>>())\r\n}\r\n\r\n/**\r\n * Returns a [List] that wraps the original array.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic actual inline fun ByteArray.asList(): List<Byte> {\r\n    return this.unsafeCast<Array<Byte>>().asList()\r\n}\r\n\r\n/**\r\n * Returns a [List] that wraps the original array.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic actual inline fun ShortArray.asList(): List<Short> {\r\n    return this.unsafeCast<Array<Short>>().asList()\r\n}\r\n\r\n/**\r\n * Returns a [List] that wraps the original array.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic actual inline fun IntArray.asList(): List<Int> {\r\n    return this.unsafeCast<Array<Int>>().asList()\r\n}\r\n\r\n/**\r\n * Returns a [List] that wraps the original array.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic actual inline fun LongArray.asList(): List<Long> {\r\n    return this.unsafeCast<Array<Long>>().asList()\r\n}\r\n\r\n/**\r\n * Returns a [List] that wraps the original array.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic actual inline fun FloatArray.asList(): List<Float> {\r\n    return this.unsafeCast<Array<Float>>().asList()\r\n}\r\n\r\n/**\r\n * Returns a [List] that wraps the original array.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic actual inline fun DoubleArray.asList(): List<Double> {\r\n    return this.unsafeCast<Array<Double>>().asList()\r\n}\r\n\r\n/**\r\n * Returns a [List] that wraps the original array.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic actual inline fun BooleanArray.asList(): List<Boolean> {\r\n    return this.unsafeCast<Array<Boolean>>().asList()\r\n}\r\n\r\n/**\r\n * Returns a [List] that wraps the original array.\r\n */\r\npublic actual fun CharArray.asList(): List<Char> {\r\n    return object : AbstractList<Char>(), RandomAccess {\r\n        override val size: Int get() = this@asList.size\r\n        override fun isEmpty(): Boolean = this@asList.isEmpty()\r\n        override fun contains(element: Char): Boolean = this@asList.contains(element)\r\n        override fun get(index: Int): Char = this@asList[index]\r\n        override fun indexOf(element: Char): Int = this@asList.indexOf(element)\r\n        override fun lastIndexOf(element: Char): Int = this@asList.lastIndexOf(element)\r\n    }\r\n}\r\n\r\n/**\r\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\r\n * i.e. contain the same number of the same elements in the same order.\r\n * \r\n * If two corresponding elements are nested arrays, they are also compared deeply.\r\n * If any of arrays contains itself on any nesting level the behavior is undefined.\r\n * \r\n * The elements of other types are compared for equality with the [equals][Any.equals] function.\r\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@library(\"arrayDeepEquals\")\r\npublic actual infix fun <T> Array<out T>.contentDeepEquals(other: Array<out T>): Boolean {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Returns a hash code based on the contents of this array as if it is [List].\r\n * Nested arrays are treated as lists too.\r\n * \r\n * If any of arrays contains itself on any nesting level the behavior is undefined.\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@library(\"arrayDeepHashCode\")\r\npublic actual fun <T> Array<out T>.contentDeepHashCode(): Int {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Returns a string representation of the contents of this array as if it is a [List].\r\n * Nested arrays are treated as lists too.\r\n * \r\n * If any of arrays contains itself on any nesting level that reference\r\n * is rendered as `\"[...]\"` to prevent recursion.\r\n * \r\n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@library(\"arrayDeepToString\")\r\npublic actual fun <T> Array<out T>.contentDeepToString(): String {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\r\n * i.e. contain the same number of the same elements in the same order.\r\n * \r\n * The elements are compared for equality with the [equals][Any.equals] function.\r\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@library(\"arrayEquals\")\r\npublic actual infix fun <T> Array<out T>.contentEquals(other: Array<out T>): Boolean {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\r\n * i.e. contain the same number of the same elements in the same order.\r\n * \r\n * The elements are compared for equality with the [equals][Any.equals] function.\r\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@library(\"arrayEquals\")\r\npublic actual infix fun ByteArray.contentEquals(other: ByteArray): Boolean {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\r\n * i.e. contain the same number of the same elements in the same order.\r\n * \r\n * The elements are compared for equality with the [equals][Any.equals] function.\r\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@library(\"arrayEquals\")\r\npublic actual infix fun ShortArray.contentEquals(other: ShortArray): Boolean {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\r\n * i.e. contain the same number of the same elements in the same order.\r\n * \r\n * The elements are compared for equality with the [equals][Any.equals] function.\r\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@library(\"arrayEquals\")\r\npublic actual infix fun IntArray.contentEquals(other: IntArray): Boolean {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\r\n * i.e. contain the same number of the same elements in the same order.\r\n * \r\n * The elements are compared for equality with the [equals][Any.equals] function.\r\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@library(\"arrayEquals\")\r\npublic actual infix fun LongArray.contentEquals(other: LongArray): Boolean {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\r\n * i.e. contain the same number of the same elements in the same order.\r\n * \r\n * The elements are compared for equality with the [equals][Any.equals] function.\r\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@library(\"arrayEquals\")\r\npublic actual infix fun FloatArray.contentEquals(other: FloatArray): Boolean {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\r\n * i.e. contain the same number of the same elements in the same order.\r\n * \r\n * The elements are compared for equality with the [equals][Any.equals] function.\r\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@library(\"arrayEquals\")\r\npublic actual infix fun DoubleArray.contentEquals(other: DoubleArray): Boolean {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\r\n * i.e. contain the same number of the same elements in the same order.\r\n * \r\n * The elements are compared for equality with the [equals][Any.equals] function.\r\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@library(\"arrayEquals\")\r\npublic actual infix fun BooleanArray.contentEquals(other: BooleanArray): Boolean {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\r\n * i.e. contain the same number of the same elements in the same order.\r\n * \r\n * The elements are compared for equality with the [equals][Any.equals] function.\r\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@library(\"arrayEquals\")\r\npublic actual infix fun CharArray.contentEquals(other: CharArray): Boolean {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Returns a hash code based on the contents of this array as if it is [List].\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@library(\"arrayHashCode\")\r\npublic actual fun <T> Array<out T>.contentHashCode(): Int {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Returns a hash code based on the contents of this array as if it is [List].\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@library(\"arrayHashCode\")\r\npublic actual fun ByteArray.contentHashCode(): Int {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Returns a hash code based on the contents of this array as if it is [List].\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@library(\"arrayHashCode\")\r\npublic actual fun ShortArray.contentHashCode(): Int {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Returns a hash code based on the contents of this array as if it is [List].\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@library(\"arrayHashCode\")\r\npublic actual fun IntArray.contentHashCode(): Int {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Returns a hash code based on the contents of this array as if it is [List].\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@library(\"arrayHashCode\")\r\npublic actual fun LongArray.contentHashCode(): Int {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Returns a hash code based on the contents of this array as if it is [List].\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@library(\"arrayHashCode\")\r\npublic actual fun FloatArray.contentHashCode(): Int {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Returns a hash code based on the contents of this array as if it is [List].\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@library(\"arrayHashCode\")\r\npublic actual fun DoubleArray.contentHashCode(): Int {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Returns a hash code based on the contents of this array as if it is [List].\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@library(\"arrayHashCode\")\r\npublic actual fun BooleanArray.contentHashCode(): Int {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Returns a hash code based on the contents of this array as if it is [List].\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@library(\"arrayHashCode\")\r\npublic actual fun CharArray.contentHashCode(): Int {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Returns a string representation of the contents of the specified array as if it is [List].\r\n * \r\n * @sample samples.collections.Arrays.ContentOperations.contentToString\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@library(\"arrayToString\")\r\npublic actual fun <T> Array<out T>.contentToString(): String {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Returns a string representation of the contents of the specified array as if it is [List].\r\n * \r\n * @sample samples.collections.Arrays.ContentOperations.contentToString\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@library(\"arrayToString\")\r\npublic actual fun ByteArray.contentToString(): String {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Returns a string representation of the contents of the specified array as if it is [List].\r\n * \r\n * @sample samples.collections.Arrays.ContentOperations.contentToString\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@library(\"arrayToString\")\r\npublic actual fun ShortArray.contentToString(): String {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Returns a string representation of the contents of the specified array as if it is [List].\r\n * \r\n * @sample samples.collections.Arrays.ContentOperations.contentToString\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@library(\"arrayToString\")\r\npublic actual fun IntArray.contentToString(): String {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Returns a string representation of the contents of the specified array as if it is [List].\r\n * \r\n * @sample samples.collections.Arrays.ContentOperations.contentToString\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@library(\"arrayToString\")\r\npublic actual fun LongArray.contentToString(): String {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Returns a string representation of the contents of the specified array as if it is [List].\r\n * \r\n * @sample samples.collections.Arrays.ContentOperations.contentToString\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@library(\"arrayToString\")\r\npublic actual fun FloatArray.contentToString(): String {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Returns a string representation of the contents of the specified array as if it is [List].\r\n * \r\n * @sample samples.collections.Arrays.ContentOperations.contentToString\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@library(\"arrayToString\")\r\npublic actual fun DoubleArray.contentToString(): String {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Returns a string representation of the contents of the specified array as if it is [List].\r\n * \r\n * @sample samples.collections.Arrays.ContentOperations.contentToString\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@library(\"arrayToString\")\r\npublic actual fun BooleanArray.contentToString(): String {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Returns a string representation of the contents of the specified array as if it is [List].\r\n * \r\n * @sample samples.collections.Arrays.ContentOperations.contentToString\r\n */\r\n@SinceKotlin(\"1.1\")\r\n@library(\"arrayToString\")\r\npublic actual fun CharArray.contentToString(): String {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Copies this array or its subrange into the [destination] array and returns that array.\r\n * \r\n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\r\n * \r\n * @param destination the array to copy to.\r\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\r\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\r\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\r\n * \r\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\r\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\r\n * or when that index is out of the [destination] array indices range.\r\n * \r\n * @return the [destination] array.\r\n */\r\n@SinceKotlin(\"1.3\")\r\n@kotlin.internal.InlineOnly\r\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\r\npublic actual inline fun <T> Array<out T>.copyInto(destination: Array<T>, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): Array<T> {\r\n    arrayCopy(this, destination, destinationOffset, startIndex, endIndex)\r\n    return destination\r\n}\r\n\r\n/**\r\n * Copies this array or its subrange into the [destination] array and returns that array.\r\n * \r\n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\r\n * \r\n * @param destination the array to copy to.\r\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\r\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\r\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\r\n * \r\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\r\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\r\n * or when that index is out of the [destination] array indices range.\r\n * \r\n * @return the [destination] array.\r\n */\r\n@SinceKotlin(\"1.3\")\r\n@kotlin.internal.InlineOnly\r\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\r\npublic actual inline fun ByteArray.copyInto(destination: ByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ByteArray {\r\n    arrayCopy(this.unsafeCast<Array<Byte>>(), destination.unsafeCast<Array<Byte>>(), destinationOffset, startIndex, endIndex)\r\n    return destination\r\n}\r\n\r\n/**\r\n * Copies this array or its subrange into the [destination] array and returns that array.\r\n * \r\n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\r\n * \r\n * @param destination the array to copy to.\r\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\r\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\r\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\r\n * \r\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\r\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\r\n * or when that index is out of the [destination] array indices range.\r\n * \r\n * @return the [destination] array.\r\n */\r\n@SinceKotlin(\"1.3\")\r\n@kotlin.internal.InlineOnly\r\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\r\npublic actual inline fun ShortArray.copyInto(destination: ShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ShortArray {\r\n    arrayCopy(this.unsafeCast<Array<Short>>(), destination.unsafeCast<Array<Short>>(), destinationOffset, startIndex, endIndex)\r\n    return destination\r\n}\r\n\r\n/**\r\n * Copies this array or its subrange into the [destination] array and returns that array.\r\n * \r\n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\r\n * \r\n * @param destination the array to copy to.\r\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\r\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\r\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\r\n * \r\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\r\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\r\n * or when that index is out of the [destination] array indices range.\r\n * \r\n * @return the [destination] array.\r\n */\r\n@SinceKotlin(\"1.3\")\r\n@kotlin.internal.InlineOnly\r\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\r\npublic actual inline fun IntArray.copyInto(destination: IntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): IntArray {\r\n    arrayCopy(this.unsafeCast<Array<Int>>(), destination.unsafeCast<Array<Int>>(), destinationOffset, startIndex, endIndex)\r\n    return destination\r\n}\r\n\r\n/**\r\n * Copies this array or its subrange into the [destination] array and returns that array.\r\n * \r\n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\r\n * \r\n * @param destination the array to copy to.\r\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\r\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\r\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\r\n * \r\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\r\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\r\n * or when that index is out of the [destination] array indices range.\r\n * \r\n * @return the [destination] array.\r\n */\r\n@SinceKotlin(\"1.3\")\r\n@kotlin.internal.InlineOnly\r\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\r\npublic actual inline fun LongArray.copyInto(destination: LongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): LongArray {\r\n    arrayCopy(this.unsafeCast<Array<Long>>(), destination.unsafeCast<Array<Long>>(), destinationOffset, startIndex, endIndex)\r\n    return destination\r\n}\r\n\r\n/**\r\n * Copies this array or its subrange into the [destination] array and returns that array.\r\n * \r\n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\r\n * \r\n * @param destination the array to copy to.\r\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\r\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\r\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\r\n * \r\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\r\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\r\n * or when that index is out of the [destination] array indices range.\r\n * \r\n * @return the [destination] array.\r\n */\r\n@SinceKotlin(\"1.3\")\r\n@kotlin.internal.InlineOnly\r\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\r\npublic actual inline fun FloatArray.copyInto(destination: FloatArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): FloatArray {\r\n    arrayCopy(this.unsafeCast<Array<Float>>(), destination.unsafeCast<Array<Float>>(), destinationOffset, startIndex, endIndex)\r\n    return destination\r\n}\r\n\r\n/**\r\n * Copies this array or its subrange into the [destination] array and returns that array.\r\n * \r\n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\r\n * \r\n * @param destination the array to copy to.\r\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\r\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\r\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\r\n * \r\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\r\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\r\n * or when that index is out of the [destination] array indices range.\r\n * \r\n * @return the [destination] array.\r\n */\r\n@SinceKotlin(\"1.3\")\r\n@kotlin.internal.InlineOnly\r\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\r\npublic actual inline fun DoubleArray.copyInto(destination: DoubleArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): DoubleArray {\r\n    arrayCopy(this.unsafeCast<Array<Double>>(), destination.unsafeCast<Array<Double>>(), destinationOffset, startIndex, endIndex)\r\n    return destination\r\n}\r\n\r\n/**\r\n * Copies this array or its subrange into the [destination] array and returns that array.\r\n * \r\n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\r\n * \r\n * @param destination the array to copy to.\r\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\r\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\r\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\r\n * \r\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\r\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\r\n * or when that index is out of the [destination] array indices range.\r\n * \r\n * @return the [destination] array.\r\n */\r\n@SinceKotlin(\"1.3\")\r\n@kotlin.internal.InlineOnly\r\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\r\npublic actual inline fun BooleanArray.copyInto(destination: BooleanArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): BooleanArray {\r\n    arrayCopy(this.unsafeCast<Array<Boolean>>(), destination.unsafeCast<Array<Boolean>>(), destinationOffset, startIndex, endIndex)\r\n    return destination\r\n}\r\n\r\n/**\r\n * Copies this array or its subrange into the [destination] array and returns that array.\r\n * \r\n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\r\n * \r\n * @param destination the array to copy to.\r\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\r\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\r\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\r\n * \r\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\r\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\r\n * or when that index is out of the [destination] array indices range.\r\n * \r\n * @return the [destination] array.\r\n */\r\n@SinceKotlin(\"1.3\")\r\n@kotlin.internal.InlineOnly\r\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\r\npublic actual inline fun CharArray.copyInto(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): CharArray {\r\n    arrayCopy(this.unsafeCast<Array<Char>>(), destination.unsafeCast<Array<Char>>(), destinationOffset, startIndex, endIndex)\r\n    return destination\r\n}\r\n\r\n/**\r\n * Returns new array which is a copy of the original array.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\r\n */\r\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\r\npublic actual inline fun <T> Array<out T>.copyOf(): Array<T> {\r\n    return this.asDynamic().slice()\r\n}\r\n\r\n/**\r\n * Returns new array which is a copy of the original array.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\r\n */\r\n@Suppress(\"NOTHING_TO_INLINE\")\r\npublic actual inline fun ByteArray.copyOf(): ByteArray {\r\n    return this.asDynamic().slice()\r\n}\r\n\r\n/**\r\n * Returns new array which is a copy of the original array.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\r\n */\r\n@Suppress(\"NOTHING_TO_INLINE\")\r\npublic actual inline fun ShortArray.copyOf(): ShortArray {\r\n    return this.asDynamic().slice()\r\n}\r\n\r\n/**\r\n * Returns new array which is a copy of the original array.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\r\n */\r\n@Suppress(\"NOTHING_TO_INLINE\")\r\npublic actual inline fun IntArray.copyOf(): IntArray {\r\n    return this.asDynamic().slice()\r\n}\r\n\r\n/**\r\n * Returns new array which is a copy of the original array.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\r\n */\r\npublic actual fun LongArray.copyOf(): LongArray {\r\n    return withType(\"LongArray\", this.asDynamic().slice())\r\n}\r\n\r\n/**\r\n * Returns new array which is a copy of the original array.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\r\n */\r\n@Suppress(\"NOTHING_TO_INLINE\")\r\npublic actual inline fun FloatArray.copyOf(): FloatArray {\r\n    return this.asDynamic().slice()\r\n}\r\n\r\n/**\r\n * Returns new array which is a copy of the original array.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\r\n */\r\n@Suppress(\"NOTHING_TO_INLINE\")\r\npublic actual inline fun DoubleArray.copyOf(): DoubleArray {\r\n    return this.asDynamic().slice()\r\n}\r\n\r\n/**\r\n * Returns new array which is a copy of the original array.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\r\n */\r\npublic actual fun BooleanArray.copyOf(): BooleanArray {\r\n    return withType(\"BooleanArray\", this.asDynamic().slice())\r\n}\r\n\r\n/**\r\n * Returns new array which is a copy of the original array.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\r\n */\r\npublic actual fun CharArray.copyOf(): CharArray {\r\n    return withType(\"CharArray\", this.asDynamic().slice())\r\n}\r\n\r\n/**\r\n * Returns new array which is a copy of the original array, resized to the given [newSize].\r\n * The copy is either truncated or padded at the end with zero values if necessary.\r\n * \r\n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\r\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\r\n */\r\npublic actual fun ByteArray.copyOf(newSize: Int): ByteArray {\r\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\r\n    return fillFrom(this, ByteArray(newSize))\r\n}\r\n\r\n/**\r\n * Returns new array which is a copy of the original array, resized to the given [newSize].\r\n * The copy is either truncated or padded at the end with zero values if necessary.\r\n * \r\n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\r\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\r\n */\r\npublic actual fun ShortArray.copyOf(newSize: Int): ShortArray {\r\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\r\n    return fillFrom(this, ShortArray(newSize))\r\n}\r\n\r\n/**\r\n * Returns new array which is a copy of the original array, resized to the given [newSize].\r\n * The copy is either truncated or padded at the end with zero values if necessary.\r\n * \r\n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\r\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\r\n */\r\npublic actual fun IntArray.copyOf(newSize: Int): IntArray {\r\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\r\n    return fillFrom(this, IntArray(newSize))\r\n}\r\n\r\n/**\r\n * Returns new array which is a copy of the original array, resized to the given [newSize].\r\n * The copy is either truncated or padded at the end with zero values if necessary.\r\n * \r\n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\r\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\r\n */\r\npublic actual fun LongArray.copyOf(newSize: Int): LongArray {\r\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\r\n    return withType(\"LongArray\", arrayCopyResize(this, newSize, 0L))\r\n}\r\n\r\n/**\r\n * Returns new array which is a copy of the original array, resized to the given [newSize].\r\n * The copy is either truncated or padded at the end with zero values if necessary.\r\n * \r\n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\r\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\r\n */\r\npublic actual fun FloatArray.copyOf(newSize: Int): FloatArray {\r\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\r\n    return fillFrom(this, FloatArray(newSize))\r\n}\r\n\r\n/**\r\n * Returns new array which is a copy of the original array, resized to the given [newSize].\r\n * The copy is either truncated or padded at the end with zero values if necessary.\r\n * \r\n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\r\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\r\n */\r\npublic actual fun DoubleArray.copyOf(newSize: Int): DoubleArray {\r\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\r\n    return fillFrom(this, DoubleArray(newSize))\r\n}\r\n\r\n/**\r\n * Returns new array which is a copy of the original array, resized to the given [newSize].\r\n * The copy is either truncated or padded at the end with `false` values if necessary.\r\n * \r\n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\r\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `false` values.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\r\n */\r\npublic actual fun BooleanArray.copyOf(newSize: Int): BooleanArray {\r\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\r\n    return withType(\"BooleanArray\", arrayCopyResize(this, newSize, false))\r\n}\r\n\r\n/**\r\n * Returns new array which is a copy of the original array, resized to the given [newSize].\r\n * The copy is either truncated or padded at the end with null char (`\\u0000`) values if necessary.\r\n * \r\n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\r\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with null char (`\\u0000`) values.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\r\n */\r\npublic actual fun CharArray.copyOf(newSize: Int): CharArray {\r\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\r\n    return withType(\"CharArray\", fillFrom(this, CharArray(newSize)))\r\n}\r\n\r\n/**\r\n * Returns new array which is a copy of the original array, resized to the given [newSize].\r\n * The copy is either truncated or padded at the end with `null` values if necessary.\r\n * \r\n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\r\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `null` values.\r\n * \r\n * @sample samples.collections.Arrays.CopyOfOperations.resizingCopyOf\r\n */\r\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\r\npublic actual fun <T> Array<out T>.copyOf(newSize: Int): Array<T?> {\r\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\r\n    return arrayCopyResize(this, newSize, null)\r\n}\r\n\r\n/**\r\n * Returns a new array which is a copy of the specified range of the original array.\r\n * \r\n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\r\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\r\n */\r\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\r\npublic actual fun <T> Array<out T>.copyOfRange(fromIndex: Int, toIndex: Int): Array<T> {\r\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\r\n    return this.asDynamic().slice(fromIndex, toIndex)\r\n}\r\n\r\n/**\r\n * Returns a new array which is a copy of the specified range of the original array.\r\n * \r\n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\r\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\r\n */\r\npublic actual fun ByteArray.copyOfRange(fromIndex: Int, toIndex: Int): ByteArray {\r\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\r\n    return this.asDynamic().slice(fromIndex, toIndex)\r\n}\r\n\r\n/**\r\n * Returns a new array which is a copy of the specified range of the original array.\r\n * \r\n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\r\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\r\n */\r\npublic actual fun ShortArray.copyOfRange(fromIndex: Int, toIndex: Int): ShortArray {\r\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\r\n    return this.asDynamic().slice(fromIndex, toIndex)\r\n}\r\n\r\n/**\r\n * Returns a new array which is a copy of the specified range of the original array.\r\n * \r\n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\r\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\r\n */\r\npublic actual fun IntArray.copyOfRange(fromIndex: Int, toIndex: Int): IntArray {\r\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\r\n    return this.asDynamic().slice(fromIndex, toIndex)\r\n}\r\n\r\n/**\r\n * Returns a new array which is a copy of the specified range of the original array.\r\n * \r\n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\r\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\r\n */\r\npublic actual fun LongArray.copyOfRange(fromIndex: Int, toIndex: Int): LongArray {\r\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\r\n    return withType(\"LongArray\", this.asDynamic().slice(fromIndex, toIndex))\r\n}\r\n\r\n/**\r\n * Returns a new array which is a copy of the specified range of the original array.\r\n * \r\n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\r\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\r\n */\r\npublic actual fun FloatArray.copyOfRange(fromIndex: Int, toIndex: Int): FloatArray {\r\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\r\n    return this.asDynamic().slice(fromIndex, toIndex)\r\n}\r\n\r\n/**\r\n * Returns a new array which is a copy of the specified range of the original array.\r\n * \r\n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\r\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\r\n */\r\npublic actual fun DoubleArray.copyOfRange(fromIndex: Int, toIndex: Int): DoubleArray {\r\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\r\n    return this.asDynamic().slice(fromIndex, toIndex)\r\n}\r\n\r\n/**\r\n * Returns a new array which is a copy of the specified range of the original array.\r\n * \r\n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\r\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\r\n */\r\npublic actual fun BooleanArray.copyOfRange(fromIndex: Int, toIndex: Int): BooleanArray {\r\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\r\n    return withType(\"BooleanArray\", this.asDynamic().slice(fromIndex, toIndex))\r\n}\r\n\r\n/**\r\n * Returns a new array which is a copy of the specified range of the original array.\r\n * \r\n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\r\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\r\n */\r\npublic actual fun CharArray.copyOfRange(fromIndex: Int, toIndex: Int): CharArray {\r\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\r\n    return withType(\"CharArray\", this.asDynamic().slice(fromIndex, toIndex))\r\n}\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then the given [element].\r\n */\r\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\r\npublic actual inline operator fun <T> Array<out T>.plus(element: T): Array<T> {\r\n    return this.asDynamic().concat(arrayOf(element))\r\n}\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then the given [element].\r\n */\r\n@Suppress(\"NOTHING_TO_INLINE\")\r\npublic actual inline operator fun ByteArray.plus(element: Byte): ByteArray {\r\n    return plus(byteArrayOf(element))\r\n}\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then the given [element].\r\n */\r\n@Suppress(\"NOTHING_TO_INLINE\")\r\npublic actual inline operator fun ShortArray.plus(element: Short): ShortArray {\r\n    return plus(shortArrayOf(element))\r\n}\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then the given [element].\r\n */\r\n@Suppress(\"NOTHING_TO_INLINE\")\r\npublic actual inline operator fun IntArray.plus(element: Int): IntArray {\r\n    return plus(intArrayOf(element))\r\n}\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then the given [element].\r\n */\r\n@Suppress(\"NOTHING_TO_INLINE\")\r\npublic actual inline operator fun LongArray.plus(element: Long): LongArray {\r\n    return plus(longArrayOf(element))\r\n}\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then the given [element].\r\n */\r\n@Suppress(\"NOTHING_TO_INLINE\")\r\npublic actual inline operator fun FloatArray.plus(element: Float): FloatArray {\r\n    return plus(floatArrayOf(element))\r\n}\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then the given [element].\r\n */\r\n@Suppress(\"NOTHING_TO_INLINE\")\r\npublic actual inline operator fun DoubleArray.plus(element: Double): DoubleArray {\r\n    return plus(doubleArrayOf(element))\r\n}\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then the given [element].\r\n */\r\n@Suppress(\"NOTHING_TO_INLINE\")\r\npublic actual inline operator fun BooleanArray.plus(element: Boolean): BooleanArray {\r\n    return plus(booleanArrayOf(element))\r\n}\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then the given [element].\r\n */\r\n@Suppress(\"NOTHING_TO_INLINE\")\r\npublic actual inline operator fun CharArray.plus(element: Char): CharArray {\r\n    return plus(charArrayOf(element))\r\n}\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\r\n */\r\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\r\npublic actual operator fun <T> Array<out T>.plus(elements: Collection<T>): Array<T> {\r\n    return arrayPlusCollection(this, elements)\r\n}\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\r\n */\r\npublic actual operator fun ByteArray.plus(elements: Collection<Byte>): ByteArray {\r\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\r\n}\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\r\n */\r\npublic actual operator fun ShortArray.plus(elements: Collection<Short>): ShortArray {\r\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\r\n}\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\r\n */\r\npublic actual operator fun IntArray.plus(elements: Collection<Int>): IntArray {\r\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\r\n}\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\r\n */\r\npublic actual operator fun LongArray.plus(elements: Collection<Long>): LongArray {\r\n    return arrayPlusCollection(this, elements)\r\n}\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\r\n */\r\npublic actual operator fun FloatArray.plus(elements: Collection<Float>): FloatArray {\r\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\r\n}\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\r\n */\r\npublic actual operator fun DoubleArray.plus(elements: Collection<Double>): DoubleArray {\r\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\r\n}\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\r\n */\r\npublic actual operator fun BooleanArray.plus(elements: Collection<Boolean>): BooleanArray {\r\n    return arrayPlusCollection(this, elements)\r\n}\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\r\n */\r\npublic actual operator fun CharArray.plus(elements: Collection<Char>): CharArray {\r\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\r\n}\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\r\n */\r\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\r\npublic actual inline operator fun <T> Array<out T>.plus(elements: Array<out T>): Array<T> {\r\n    return this.asDynamic().concat(elements)\r\n}\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\r\n */\r\n@Suppress(\"NOTHING_TO_INLINE\")\r\npublic actual inline operator fun ByteArray.plus(elements: ByteArray): ByteArray {\r\n    return primitiveArrayConcat(this, elements)\r\n}\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\r\n */\r\n@Suppress(\"NOTHING_TO_INLINE\")\r\npublic actual inline operator fun ShortArray.plus(elements: ShortArray): ShortArray {\r\n    return primitiveArrayConcat(this, elements)\r\n}\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\r\n */\r\n@Suppress(\"NOTHING_TO_INLINE\")\r\npublic actual inline operator fun IntArray.plus(elements: IntArray): IntArray {\r\n    return primitiveArrayConcat(this, elements)\r\n}\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\r\n */\r\n@Suppress(\"NOTHING_TO_INLINE\")\r\npublic actual inline operator fun LongArray.plus(elements: LongArray): LongArray {\r\n    return primitiveArrayConcat(this, elements)\r\n}\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\r\n */\r\n@Suppress(\"NOTHING_TO_INLINE\")\r\npublic actual inline operator fun FloatArray.plus(elements: FloatArray): FloatArray {\r\n    return primitiveArrayConcat(this, elements)\r\n}\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\r\n */\r\n@Suppress(\"NOTHING_TO_INLINE\")\r\npublic actual inline operator fun DoubleArray.plus(elements: DoubleArray): DoubleArray {\r\n    return primitiveArrayConcat(this, elements)\r\n}\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\r\n */\r\n@Suppress(\"NOTHING_TO_INLINE\")\r\npublic actual inline operator fun BooleanArray.plus(elements: BooleanArray): BooleanArray {\r\n    return primitiveArrayConcat(this, elements)\r\n}\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\r\n */\r\n@Suppress(\"NOTHING_TO_INLINE\")\r\npublic actual inline operator fun CharArray.plus(elements: CharArray): CharArray {\r\n    return primitiveArrayConcat(this, elements)\r\n}\r\n\r\n/**\r\n * Returns an array containing all elements of the original array and then the given [element].\r\n */\r\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\r\npublic actual inline fun <T> Array<out T>.plusElement(element: T): Array<T> {\r\n    return this.asDynamic().concat(arrayOf(element))\r\n}\r\n\r\n/**\r\n * Sorts the array in-place.\r\n */\r\n@library(\"primitiveArraySort\")\r\npublic actual fun IntArray.sort(): Unit {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Sorts the array in-place.\r\n */\r\npublic actual fun LongArray.sort(): Unit {\r\n    if (size > 1) sort { a: Long, b: Long -> a.compareTo(b) }\r\n}\r\n\r\n/**\r\n * Sorts the array in-place.\r\n */\r\n@library(\"primitiveArraySort\")\r\npublic actual fun ByteArray.sort(): Unit {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Sorts the array in-place.\r\n */\r\n@library(\"primitiveArraySort\")\r\npublic actual fun ShortArray.sort(): Unit {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Sorts the array in-place.\r\n */\r\n@library(\"primitiveArraySort\")\r\npublic actual fun DoubleArray.sort(): Unit {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Sorts the array in-place.\r\n */\r\n@library(\"primitiveArraySort\")\r\npublic actual fun FloatArray.sort(): Unit {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Sorts the array in-place.\r\n */\r\n@library(\"primitiveArraySort\")\r\npublic actual fun CharArray.sort(): Unit {\r\n    definedExternally\r\n}\r\n\r\n/**\r\n * Sorts the array in-place according to the natural order of its elements.\r\n * \r\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\r\n */\r\npublic actual fun <T : Comparable<T>> Array<out T>.sort(): Unit {\r\n    if (size > 1) sortArray(this)\r\n}\r\n\r\n/**\r\n * Sorts the array in-place according to the order specified by the given [comparison] function.\r\n * \r\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\r\n */\r\npublic fun <T> Array<out T>.sort(comparison: (a: T, b: T) -> Int): Unit {\r\n    if (size > 1) sortArrayWith(this, comparison)\r\n}\r\n\r\n/**\r\n * Sorts the array in-place according to the order specified by the given [comparison] function.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun ByteArray.sort(noinline comparison: (a: Byte, b: Byte) -> Int): Unit {\r\n    asDynamic().sort(comparison)\r\n}\r\n\r\n/**\r\n * Sorts the array in-place according to the order specified by the given [comparison] function.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun ShortArray.sort(noinline comparison: (a: Short, b: Short) -> Int): Unit {\r\n    asDynamic().sort(comparison)\r\n}\r\n\r\n/**\r\n * Sorts the array in-place according to the order specified by the given [comparison] function.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun IntArray.sort(noinline comparison: (a: Int, b: Int) -> Int): Unit {\r\n    asDynamic().sort(comparison)\r\n}\r\n\r\n/**\r\n * Sorts the array in-place according to the order specified by the given [comparison] function.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun LongArray.sort(noinline comparison: (a: Long, b: Long) -> Int): Unit {\r\n    asDynamic().sort(comparison)\r\n}\r\n\r\n/**\r\n * Sorts the array in-place according to the order specified by the given [comparison] function.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun FloatArray.sort(noinline comparison: (a: Float, b: Float) -> Int): Unit {\r\n    asDynamic().sort(comparison)\r\n}\r\n\r\n/**\r\n * Sorts the array in-place according to the order specified by the given [comparison] function.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun DoubleArray.sort(noinline comparison: (a: Double, b: Double) -> Int): Unit {\r\n    asDynamic().sort(comparison)\r\n}\r\n\r\n/**\r\n * Sorts the array in-place according to the order specified by the given [comparison] function.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun CharArray.sort(noinline comparison: (a: Char, b: Char) -> Int): Unit {\r\n    asDynamic().sort(comparison)\r\n}\r\n\r\n/**\r\n * Sorts the array in-place according to the order specified by the given [comparator].\r\n * \r\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\r\n */\r\npublic actual fun <T> Array<out T>.sortWith(comparator: Comparator<in T>): Unit {\r\n    if (size > 1) sortArrayWith(this, comparator)\r\n}\r\n\r\n/**\r\n * Returns a *typed* object array containing all of the elements of this primitive array.\r\n */\r\npublic actual fun ByteArray.toTypedArray(): Array<Byte> {\r\n    return js(\"[]\").slice.call(this)\r\n}\r\n\r\n/**\r\n * Returns a *typed* object array containing all of the elements of this primitive array.\r\n */\r\npublic actual fun ShortArray.toTypedArray(): Array<Short> {\r\n    return js(\"[]\").slice.call(this)\r\n}\r\n\r\n/**\r\n * Returns a *typed* object array containing all of the elements of this primitive array.\r\n */\r\npublic actual fun IntArray.toTypedArray(): Array<Int> {\r\n    return js(\"[]\").slice.call(this)\r\n}\r\n\r\n/**\r\n * Returns a *typed* object array containing all of the elements of this primitive array.\r\n */\r\npublic actual fun LongArray.toTypedArray(): Array<Long> {\r\n    return js(\"[]\").slice.call(this)\r\n}\r\n\r\n/**\r\n * Returns a *typed* object array containing all of the elements of this primitive array.\r\n */\r\npublic actual fun FloatArray.toTypedArray(): Array<Float> {\r\n    return js(\"[]\").slice.call(this)\r\n}\r\n\r\n/**\r\n * Returns a *typed* object array containing all of the elements of this primitive array.\r\n */\r\npublic actual fun DoubleArray.toTypedArray(): Array<Double> {\r\n    return js(\"[]\").slice.call(this)\r\n}\r\n\r\n/**\r\n * Returns a *typed* object array containing all of the elements of this primitive array.\r\n */\r\npublic actual fun BooleanArray.toTypedArray(): Array<Boolean> {\r\n    return js(\"[]\").slice.call(this)\r\n}\r\n\r\n/**\r\n * Returns a *typed* object array containing all of the elements of this primitive array.\r\n */\r\npublic actual fun CharArray.toTypedArray(): Array<Char> {\r\n    return Array(size) { index -> this[index] }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;EAuDA,yD;;IC/CI,qB;MAAA,QDsD0C,U;;ICrD1C,wB;MAAA,WAA8B,E;IAR9B,gB;IACA,gC;IACA,8B;IACA,8B;IACA,0B;IACA,wB;IACA,8B;IACA,kB;IACA,wB;EATiB,C;;IAWI,oB;EAAA,C;;IACkB,iDAAmB,mBAAc,QAAd,IAAnB,C;EAAA,C;;IAER,OAAA,UAAM,mBAAY,QAAZ,C;EAAN,C;;;;;;;IAb/B,gB;EADJ,C;;IAEI,wB;EAFJ,C;;IAGI,uB;EAHJ,C;;IAII,uB;EAJJ,C;;IAKI,qB;EALJ,C;;IAMI,oB;EANJ,C;;IAOI,uB;EAPJ,C;;IAQI,iB;EARJ,C;;IASI,oB;EATJ,C;;IAAA,sBACI,kCADJ,EAEI,0DAFJ,EAGI,uDAHJ,EAII,uDAJJ,EAKI,iDALJ,EAMI,8CANJ,EAOI,uDAPJ,EAQI,qCARJ,EASI,8CATJ,C;EAAA,C;;IAAA,OACI,+CADJ,IAEI,sDAFJ,KAGI,oDAHJ,KAII,oDAJJ,KAKI,gDALJ,KAMI,8CANJ,KAOI,oDAPJ,KAQI,wCARJ,KASI,8CATJ,O;EAAA,C;;IAAA,c;IACI,qD;IACA,6D;IACA,4D;IACA,4D;IACA,0D;IACA,yD;IACA,4D;IACA,sD;IACA,yD;IATJ,a;EAAA,C;;IAAA,4IACI,oCADJ,IAEI,oDAFJ,IAGI,kDAHJ,IAII,kDAJJ,IAKI,8CALJ,IAMI,4CANJ,IAOI,kDAPJ,IAQI,sCARJ,IASI,4CATJ,I;EAAA,C;;ECAA,C;;;;;;;EAEA,C;;;;;;;ICII,QAAQ,IAAR,C;EACJ,C;ECshRA,qE;EC/gRA,uD;;IFJI,wBAAwB,eACb,4BAAK,cAAK,IAAK,KAAV,CAAqC,8BAAW,CAAX,CAD7B,EAEL,IAAK,aAFA,EAGN,IAAK,YAHC,EAIN,IAAK,YAJC,EAKR,IAAK,UALG,EAMT,aAAS,IAAK,SAAS,KAAvB,EAA6B,IAAK,SAAS,KAA3C,CANS,EAON,gBAA0B,IAAK,MAAM,YAArC,CAPM,C;IASxB,WAAW,e;IC+gRJ,kBAAM,eD9gRiB,MC8gRJ,OAAb,C;IA6TA,Q;IAAb,wBD30R8B,MC20R9B,gB;MAAa,WD30RiB,MC20R9B,M;mBACI,W;MD30RmB,U;MAAR,QC20Re,ID30RP,KAAR,C;aACP,U;UAAc,sBC00RQ,ID10RG,MAAX,EC00RQ,ID10RY,gBAApB,EC00RQ,ID10R+B,SAAvC,C;UAAd,K;aACA,U;UAAc,sBACV,QCw0RkB,IDx0RR,cAAV,CADU,ECy0RQ,IDv0RhB,MAFQ,ECy0RQ,IDt0RhB,iBAHQ,ECy0RQ,IDr0RhB,iBAJQ,ECy0RQ,IDp0RhB,UALQ,C;UAAd,K;aAOA,Q;UAAU,yBCk0RY,IDl0RE,KAAd,ECk0RY,IDl0RU,UAAtB,ECk0RY,IDl0RuB,OAAnC,C;UAAV,K;gBACQ,2B;UAVD,K;;MC20RC,YAAZ,WAAY,S;;ID50RhB,cC60RO,W;ID/zRP,YAAY,eEnBsD,YFmB1C,OEnB0C,CFmBtD,S;IAEZ,YAAY,YAAY,IAAK,MAAjB,C;IACZ,WAAW,iB;IACX,UAAU,eAAc,iBAAd,E;IACV,aAAU,CAAV,MAAkB,KAAlB,M;MACI,OAAO,IAAK,8EG5B2B,EH4B3B,C;MACZ,QAAU,CAAF,6BAAQ,IAAR,CAAR,C;MACA,OAAO,KAAM,aAAI,IAAJ,C;MACb,OAAO,IAAK,aAAI,IAAJ,C;MACZ,GAAI,WAAI,IAAJ,C;;IAER,OE/BkE,YF+B3D,GE/B2D,C;EFgCtE,C;;IAGI,OAAO,C;EACX,C;;IAE6D,qB;MAAE,OAAA,EAAG,MAAM,mBAAY,YAAZ,C;IAAX,C;EAAA,C;;IAAA,2B;EAAA,C;;IAEtC,2B;MAAA,cAAuB,C;IAAvB,8B;EAAD,C;;;;;;;IAAC,uB;EAAvB,C;;IAAA,uBAAuB,uDAAvB,C;EAAA,C;;IAAA,OAAuB,8DAAvB,M;EAAA,C;;IAAA,c;IAAuB,4D;IAAvB,a;EAAA,C;;IAAA,2IAAuB,kDAAvB,G;EAAA,C;;IAIkD,wB;MAAA,WAAoB,C;IAAlD,gB;IAAe,gB;IAAe,wB;IAC9C,aAAY,YAAO,SAAP,GAAc,aAAd,I;EADG,C;;;;;;;IAAC,gB;EAApB,C;;IAAmC,gB;EAAnC,C;;IAAkD,oB;EAAlD,C;;IAAA,oBAAoB,kCAApB,EAAmC,kCAAnC,EAAkD,8CAAlD,C;EAAA,C;;IAAA,OAAoB,6CAApB,IAAmC,sCAAnC,KAAkD,8CAAlD,O;EAAA,C;;IAAA,c;IAAoB,qD;IAAe,qD;IAAe,yD;IAAlD,a;EAAA,C;;IAAA,4IAAoB,oCAApB,IAAmC,oCAAnC,IAAkD,4CAAlD,I;EAAA,C;;EAIA,C;EIu8BA,iB;;IJj8B2B,UACD,MADC,EAEH,MAFG,EAGc,M;IAPjC,aAAa,EAAG,aAAH,GAAkB,EAAG,YAArB,I;IACb,cAAc,SAAS,EAAG,SAAS,MAArB,I;IACL,QAAa,EAAG,YAAY,Y;IAArC,SIw8B4C,MAAW,KJx8B1C,OIw8B0C,EAAO,CAAP,C;IJt8BpC,OAAR,EAAG,KAAK,oBAAW,CAAX,C;IACD,SAAA,EAAG,YAAH,GAAiB,EAAjB,I;IACF,SAAA,EAAG,UAAH,IAAgB,OAAhB,GAA0B,EAA1B,K;IACiB,SAAf,EAAG,YAAY,e;IAJjC,OAAO,EAAG,oDAKK,EAAG,SAAS,eALjB,S;EAOd,C;;;;;;;IAYA,4B;IATY,gB;IAAe,kB;IAAgB,c;EAAhC,C;;IAEP,eAAe,CAAC,aAAQ,SAAR,IAAD,IAAsB,EAAtB,I;IACf,eAAe,CAAC,aAAQ,SAAR,IAAD,IAAsB,E;IACrC,OAAO,WAAK,YAAO,QAAP,IAAL,EAAsB,QAAtB,EAAgC,QAAhC,C;EACX,C;;IAE0B,OAAkB,SAAf,QAAI,WAAW,EAAS,CAAT,EAAY,EAAZ,CAAlB,SAAuD,SAAjB,UAAM,WAAW,EAAS,CAAT,EAAY,EAAZ,CAAvD,SAA0E,S;EAA1E,C;;IAE1B,8B;EAAA,C;;IACgB,yBAAK,UAAL,C;EAAA,C;;IACa,OAAa,WAAR,IAAa,cAAL,EAAR,IAA4B,WAApB,EAAR,IAAwC,UAAhC,C;EAAb,C;;;;;;;;IAF7B,qC;MAAA,oB;;IAAA,8B;EAAA,C;;;;;;;IATY,gB;EAAhB,C;;IAA+B,iB;EAA/B,C;;IAA+C,e;EAA/C,C;;IAAA,kBAAgB,kCAAhB,EAA+B,qCAA/B,EAA+C,+BAA/C,C;EAAA,C;;IAAA,c;IAAgB,qD;IAAe,sD;IAAgB,oD;IAA/C,a;EAAA,C;;IAAA,4IAAgB,oCAAhB,IAA+B,sCAA/B,IAA+C,kCAA/C,I;EAAA,C;;IK5Ee,kB;IAAgB,sC;IAA0B,wB;IACrD,gBAAe,K;IACf,2BAA0B,wBAAQ,oBAAR,IAA0B,GAA1B,I;EAFhB,C;;IAIN,IAAI,EAAG,YAAH,IAAkB,wBAAlB,IAAyC,CAAC,aAA9C,C;MACI,gBAAW,I;MACS,gBAAb,gBAAS,EAAT,C;MAAoB,MAAkB,WAAT,WAAS,CAAlB,C;MAA3B,OCgFD,S;;ID9EH,OAAO,E;EACX,C;;IAGO,WAAH,EAAG,2BAAkB,CAAC,wBAAD,IAAlB,C;;;;;;IAE4B,aAAZ,EAAG,SAAS,sBAAY,CAAZ,EAA0B,EAAG,SAAS,SAAZ,GAAuB,aAAvB,IAA1B,C;;IACN,kBAAT,EAAG,MAAM,EAAK,kBAAiB,IAAjB,CAAL,C;IACM,gBAAZ,EAAG,S;IAAS,cAAK,yBAAsB,UAAtB,gCAAoD,wBAApD,e;IAJpC,OACK,kFEy7BG,SAAY,QAAO,CAAQ,OAAR,CAAP,CFz7Bf,C;EADL,C;;;;;;;IAUJ,qB;MAAA,QAAiB,C;IACjB,yC;MAAA,4BAAqC,C;IACrC,gC;MAAA,mBAA4B,C;IAH5B,0B;IACA,kB;IACA,0D;IACA,wC;IACA,0B;IAEA,eAAc,K;IACd,uD;EARU,C;;;;;MAQV,iC;IAAA,C;;MAAA,wC;IAAA,C;;;IASqB,UAAN,M;IANX,IAAI,CAAC,YAAL,C;MACI,eAAU,eAAU,EAAV,C;MACV,mBAAc,EAAG,K;;IAErB,IAAI,YAAJ,C;MAEiB,wBAAU,gBAAV,EAAuB,EAAG,KAA1B,C;MACT,e;QACI,UAAU,6B;QACV,QAAQ,GAAR,C;QACG,SAAH,EAAG,8EAAgB,EAAG,SE65Bd,QAAO,CF75BqB,GE65BrB,CAAP,CF75BL,C;;YAEP,wB;QACI,YAAU,gB;QACV,QAAQ,KAAR,C;QACG,SAAH,EAAG,sEAAsB,KAAT,EAAG,MAAM,EAAK,mBAAkB,IAAlB,CAAL,CAAtB,EAA+D,EAAG,SEw5B7D,QAAO,CFx5BoE,KEw5BpE,CAAP,CFx5BL,C;;YAEP,2BAAQ,8BAAR,M;QACI,YAAU,wB;QACV,QAAQ,KAAR,C;QACG,SAAH,EAAG,8BAAmB,CAAnB,0CAAiC,EAAG,SEm5B/B,QAAO,CFn5BsC,KEm5BtC,CAAP,CFn5BL,C;;YAEP,2BAAQ,CAAR,M;QACI,YAAU,a;QACV,QAAQ,KAAR,C;QACG,SAAH,EAAG,sEAAsB,KAAT,EAAG,MAAM,EAAK,gBAAe,IAAf,CAAL,CAAtB,EAA4D,EAAG,SE84B1D,QAAO,CF94BiE,KE84BjE,CAAP,CF94BL,C;;YAEP,2BAAQ,CAAR,GAAY,qBAAZ,M;QACI,YAAU,yB;QACV,QAAQ,KAAR,C;QACG,SAAH,EAAG,8BAAmB,cAAnB,0CAAyC,EAAG,SEy4BvC,QAAO,CFz4B8C,KEy4B9C,CAAP,CFz4BL,C;;;QAEC,W;MA1BZ,a;;IA6BJ,OAAO,E;EACX,C;;IAGI,OAAO,OAAM,KAAM,KAAN,GAAa,KAAM,KAAnB,IAAN,UAAkC,KAAM,MAAxC,GAAgD,KAAM,MAAtD,K;EACX,C;;;;;;;IAGe,sB;IAAqB,wB;IAAoB,gC;IAAuB,8B;IAE/E,oBAAmB,WAAY,aAAS,KAAT,IAAoB,aAAS,MAAT,GAAiB,CAArB,GAAwB,CAAxB,GAA+B,CAA/C,KAAZ,EAAsE,CAAtE,EAA+E,CAA/E,C;EAFL,C;;IAIV,OAAO,E;EACX,C;;;;;;;EAIJ,C;;IAEQ,QAAQ,EAAR,C;IACA,OAAO,E;EACX,C;;;;;;;;;;;;;;IAQa,oB;EAAD,C;;IAEM,gBAAP,W;IJ27TK,Q;IADhB,kBI17TuB,E;IJ27TvB,wBAAgB,SAAhB,gB;MAAgB,cAAA,SAAhB,M;MAAsB,cAAqC,OI37TnB,aJ27TM,WI37TN,C;;IAApC,OJ47TG,W;EI37TP,C;;;;;;;IAGc,gB;IAAmB,0B;IAAuB,oB;IACxD,gBAAe,K;EADF,C;;IAGT,SAAS,UAAW,e;IACpB,IAAI,aAAQ,aAAZ,C;MAAsB,OAAO,E;;MAEzB,IAAI,KAAK,cAAL,CAAJ,C;QACI,gBAAW,I;QACX,KAAK,WAAL,C;;;;MAEN,gC;QACE,OAAQ,KAAI,SAAJ,C;QACR,OAAQ,KAAI,CAAJ,C;;;QAPZ,O;;IASA,OAAO,E;EACX,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}